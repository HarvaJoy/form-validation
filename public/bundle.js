/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/normalize.css/normalize.css":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/normalize.css/normalize.css ***!
  \*******************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */
/* Document
   ========================================================================== */
/**
 * 1. Correct the line height in all browsers.
 * 2. Prevent adjustments of font size after orientation changes in iOS.
 */
html {
  line-height: 1.15;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */ }

/* Sections
   ========================================================================== */
/**
 * Remove the margin in all browsers.
 */
body {
  margin: 0; }

/**
 * Render the \`main\` element consistently in IE.
 */
main {
  display: block; }

/**
 * Correct the font size and margin on \`h1\` elements within \`section\` and
 * \`article\` contexts in Chrome, Firefox, and Safari.
 */
h1 {
  font-size: 2em;
  margin: 0.67em 0; }

/* Grouping content
   ========================================================================== */
/**
 * 1. Add the correct box sizing in Firefox.
 * 2. Show the overflow in Edge and IE.
 */
hr {
  box-sizing: content-box;
  /* 1 */
  height: 0;
  /* 1 */
  overflow: visible;
  /* 2 */ }

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd \`em\` font sizing in all browsers.
 */
pre {
  font-family: monospace, monospace;
  /* 1 */
  font-size: 1em;
  /* 2 */ }

/* Text-level semantics
   ========================================================================== */
/**
 * Remove the gray background on active links in IE 10.
 */
a {
  background-color: transparent; }

/**
 * 1. Remove the bottom border in Chrome 57-
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */
abbr[title] {
  border-bottom: none;
  /* 1 */
  text-decoration: underline;
  /* 2 */
  text-decoration: underline dotted;
  /* 2 */ }

/**
 * Add the correct font weight in Chrome, Edge, and Safari.
 */
b,
strong {
  font-weight: bolder; }

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd \`em\` font sizing in all browsers.
 */
code,
kbd,
samp {
  font-family: monospace, monospace;
  /* 1 */
  font-size: 1em;
  /* 2 */ }

/**
 * Add the correct font size in all browsers.
 */
small {
  font-size: 80%; }

/**
 * Prevent \`sub\` and \`sup\` elements from affecting the line height in
 * all browsers.
 */
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline; }

sub {
  bottom: -0.25em; }

sup {
  top: -0.5em; }

/* Embedded content
   ========================================================================== */
/**
 * Remove the border on images inside links in IE 10.
 */
img {
  border-style: none; }

/* Forms
   ========================================================================== */
/**
 * 1. Change the font styles in all browsers.
 * 2. Remove the margin in Firefox and Safari.
 */
button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  line-height: 1.15;
  /* 1 */
  margin: 0;
  /* 2 */ }

/**
 * Show the overflow in IE.
 * 1. Show the overflow in Edge.
 */
button,
input {
  /* 1 */
  overflow: visible; }

/**
 * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * 1. Remove the inheritance of text transform in Firefox.
 */
button,
select {
  /* 1 */
  text-transform: none; }

/**
 * Correct the inability to style clickable types in iOS and Safari.
 */
button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button; }

/**
 * Remove the inner border and padding in Firefox.
 */
button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0; }

/**
 * Restore the focus styles unset by the previous rule.
 */
button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText; }

/**
 * Correct the padding in Firefox.
 */
fieldset {
  padding: 0.35em 0.75em 0.625em; }

/**
 * 1. Correct the text wrapping in Edge and IE.
 * 2. Correct the color inheritance from \`fieldset\` elements in IE.
 * 3. Remove the padding so developers are not caught out when they zero out
 *    \`fieldset\` elements in all browsers.
 */
legend {
  box-sizing: border-box;
  /* 1 */
  color: inherit;
  /* 2 */
  display: table;
  /* 1 */
  max-width: 100%;
  /* 1 */
  padding: 0;
  /* 3 */
  white-space: normal;
  /* 1 */ }

/**
 * Add the correct vertical alignment in Chrome, Firefox, and Opera.
 */
progress {
  vertical-align: baseline; }

/**
 * Remove the default vertical scrollbar in IE 10+.
 */
textarea {
  overflow: auto; }

/**
 * 1. Add the correct box sizing in IE 10.
 * 2. Remove the padding in IE 10.
 */
[type="checkbox"],
[type="radio"] {
  box-sizing: border-box;
  /* 1 */
  padding: 0;
  /* 2 */ }

/**
 * Correct the cursor style of increment and decrement buttons in Chrome.
 */
[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto; }

/**
 * 1. Correct the odd appearance in Chrome and Safari.
 * 2. Correct the outline style in Safari.
 */
[type="search"] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */ }

/**
 * Remove the inner padding in Chrome and Safari on macOS.
 */
[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none; }

/**
 * 1. Correct the inability to style clickable types in iOS and Safari.
 * 2. Change font properties to \`inherit\` in Safari.
 */
::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */ }

/* Interactive
   ========================================================================== */
/*
 * Add the correct display in Edge, IE 10+, and Firefox.
 */
details {
  display: block; }

/*
 * Add the correct display in all browsers.
 */
summary {
  display: list-item; }

/* Misc
   ========================================================================== */
/**
 * Add the correct display in IE 10+.
 */
template {
  display: none; }

/**
 * Add the correct display in IE 10.
 */
[hidden] {
  display: none; }
`, "",{"version":3,"sources":["webpack://./node_modules/normalize.css/normalize.css"],"names":[],"mappings":"AAAA,2EAAA;AAEA;+EAA+E;AAG/E;;;EACE;AAIF;EACE,iBAAiB;EAAE,MAAA;EACnB,8BAA8B;EAAE,MAAA,EAAO;;AAGzC;+EAD+E;AAI/E;;EADE;AAKF;EACE,SAAS,EAAA;;AAGX;;EAHE;AAOF;EACE,cAAc,EAAA;;AAGhB;;;EAJE;AASF;EACE,cAAc;EACd,gBAAgB,EAAA;;AAGlB;+EAR+E;AAW/E;;;EAPE;AAYF;EACE,uBAAuB;EAAE,MAAA;EACzB,SAAS;EAAE,MAAA;EACX,iBAAiB;EAAE,MAAA,EAAO;;AAG5B;;;EANE;AAWF;EACE,iCAAiC;EAAE,MAAA;EACnC,cAAc;EAAE,MAAA,EAAO;;AAGzB;+EAR+E;AAW/E;;EARE;AAYF;EACE,6BAA6B,EAAA;;AAG/B;;;EATE;AAcF;EACE,mBAAmB;EAAE,MAAA;EACrB,0BAA0B;EAAE,MAAA;EAC5B,iCAAiC;EAAE,MAAA,EAAO;;AAG5C;;EATE;AAaF;;EAEE,mBAAmB,EAAA;;AAGrB;;;EAVE;AAeF;;;EAGE,iCAAiC;EAAE,MAAA;EACnC,cAAc;EAAE,MAAA,EAAO;;AAGzB;;EAXE;AAeF;EACE,cAAc,EAAA;;AAGhB;;;EAZE;AAiBF;;EAEE,cAAc;EACd,cAAc;EACd,kBAAkB;EAClB,wBAAwB,EAAA;;AAG1B;EACE,eAAe,EAAA;;AAGjB;EACE,WAAW,EAAA;;AAGb;+EAlB+E;AAqB/E;;EAlBE;AAsBF;EACE,kBAAkB,EAAA;;AAGpB;+EArB+E;AAwB/E;;;EApBE;AAyBF;;;;;EAKE,oBAAoB;EAAE,MAAA;EACtB,eAAe;EAAE,MAAA;EACjB,iBAAiB;EAAE,MAAA;EACnB,SAAS;EAAE,MAAA,EAAO;;AAGpB;;;EAlBE;AAuBF;;EACQ,MAAA;EACN,iBAAiB,EAAA;;AAGnB;;;EAnBE;AAwBF;;EACS,MAAA;EACP,oBAAoB,EAAA;;AAGtB;;EArBE;AAyBF;;;;EAIE,0BAA0B,EAAA;;AAG5B;;EAvBE;AA2BF;;;;EAIE,kBAAkB;EAClB,UAAU,EAAA;;AAGZ;;EAzBE;AA6BF;;;;EAIE,8BAA8B,EAAA;;AAGhC;;EA3BE;AA+BF;EACE,8BAA8B,EAAA;;AAGhC;;;;;EA1BE;AAiCF;EACE,sBAAsB;EAAE,MAAA;EACxB,cAAc;EAAE,MAAA;EAChB,cAAc;EAAE,MAAA;EAChB,eAAe;EAAE,MAAA;EACjB,UAAU;EAAE,MAAA;EACZ,mBAAmB;EAAE,MAAA,EAAO;;AAG9B;;EAzBE;AA6BF;EACE,wBAAwB,EAAA;;AAG1B;;EA3BE;AA+BF;EACE,cAAc,EAAA;;AAGhB;;;EA5BE;AACF;;EAkCE,sBAAsB;EAAE,MAAA;EACxB,UAAU;EAAE,MAAA,EAAO;;AAGrB;;EA7BE;AACF;;EAkCE,YAAY,EAAA;;AAGd;;;EA9BE;AACF;EAmCE,6BAA6B;EAAE,MAAA;EAC/B,oBAAoB;EAAE,MAAA,EAAO;;AAG/B;;EA/BE;AACF;EAmCE,wBAAwB,EAAA;;AAG1B;;;EAhCE;AAqCF;EACE,0BAA0B;EAAE,MAAA;EAC5B,aAAa;EAAE,MAAA,EAAO;;AAGxB;+EAlC+E;AAqC/E;;EAlCE;AAsCF;EACE,cAAc,EAAA;;AAGhB;;EApCE;AAwCF;EACE,kBAAkB,EAAA;;AAGpB;+EAvC+E;AA0C/E;;EAvCE;AA2CF;EACE,aAAa,EAAA;;AAGf;;EAzCE;AACF;EA6CE,aAAa,EAAA","sourcesContent":["/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers.\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\n\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * Remove the gray background on active links in IE 10.\n */\n\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10.\n */\n\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\n\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10+.\n */\n\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n\n[hidden] {\n  display: none;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss ***!
  \***********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `* {
  box-sizing: border-box; }

html {
  font-size: 62.5%; }

body {
  font-family: Raleway, Lato, Helvetica, Arial, sans-serif;
  font-size: 1.6rem;
  background: #cee3f1; }

button {
  cursor: pointer; }

button:disabled {
  cursor: default; }

.content-container {
  margin: 0 auto;
  max-width: 115rem; }

header {
  position: relative;
  background: white;
  padding: 1.6rem 0 1.2rem 0;
  box-shadow: 0 1px 5px 2px rgba(0, 0, 0, 0.2); }
  header .logo {
    padding-left: 4.8rem; }

@media only screen and (max-width: 45rem) {
  header {
    padding: 1.6rem 0; }
    header .logo {
      max-height: 20%;
      padding: 0;
      text-align: center; } }

.article__content {
  background: #0EA5DC;
  height: 32rem;
  display: flex;
  align-items: center; }
  .article__content .article__text {
    color: white;
    text-align: center; }
    .article__content .article__text h1 {
      font-weight: 800;
      margin: 0;
      padding: 0 0 1.2rem 0; }
    .article__content .article__text p {
      margin: 0;
      color: #a9dff7;
      font-weight: 500;
      padding-bottom: 0.6rem; }

.content__article {
  display: inline-flex;
  flex-direction: column;
  width: 46rem;
  padding: 10rem 1.6rem 0 1.2rem; }
  .content__article h4 {
    text-transform: uppercase;
    color: #fff; }
  .content__article article {
    text-decoration: none;
    margin-bottom: 1.2rem; }
  .content__article--features {
    display: flex;
    align-items: center; }
    .content__article--features img {
      margin-right: 1.6rem; }
    .content__article--features a {
      text-decoration: none;
      color: #0EA5DC;
      margin: 1.2rem 0; }

.help {
  display: inline-flex;
  background-color: #f6f7f8;
  padding: 3em 0;
  font-size: 1.6rem; }
  .help img {
    width: 15%; }
  .help div {
    margin-left: 1.6rem; }
  .help a {
    text-decoration: none;
    color: #0EA5DC; }

@media only screen and (max-width: 45rem) {
  .content__article {
    padding: 1rem 0 0 0;
    display: flex;
    justify-content: center; }
    .content__article--features {
      display: block;
      text-align: center; }
      .content__article--features img {
        width: 105px;
        justify-content: center; }
  .help {
    justify-content: center; } }

.flex__section {
  background: #f6f7f8;
  padding-bottom: 25rem;
  box-shadow: 0 1px 5px 2px rgba(0, 0, 0, 0.2); }
  .flex__section--content {
    position: relative;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    align-items: flex-start; }
  .flex__section .register-form {
    padding: 10rem 6rem 7rem 6rem;
    background: white;
    box-shadow: 0 1px 3px 0.5px rgba(0, 0, 0, 0.2); }
  .flex__section .wrapper {
    max-width: 960px; }
    .flex__section .wrapper label {
      color: #707070;
      font-weight: 500; }
    .flex__section .wrapper__row {
      background: white;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      width: 100%; }
      .flex__section .wrapper__row [class*='col-5'] input {
        width: 100%; }
    .flex__section .wrapper__col-1 {
      width: 8.33333%; }
    .flex__section .wrapper__col-2 {
      width: 16.66667%; }
    .flex__section .wrapper__col-3 {
      width: 25%; }
    .flex__section .wrapper__col-4 {
      width: 33.33333%; }
    .flex__section .wrapper__col-5 {
      width: 41.66667%; }
    .flex__section .wrapper__col-6 {
      width: 50%; }
    .flex__section .wrapper__col-7 {
      width: 58.33333%; }
    .flex__section .wrapper__col-8 {
      width: 66.66667%; }
    .flex__section .wrapper__col-9 {
      width: 75%; }
    .flex__section .wrapper__col-10 {
      width: 83.33333%; }
    .flex__section .wrapper__col-11 {
      width: 91.66667%; }
    .flex__section .wrapper__col-12 {
      width: 100%; }
    .flex__section .wrapper [class*='col-'] {
      padding-top: 1.2rem;
      padding-bottom: 0.8rem; }
    .flex__section .wrapper input {
      height: 3.2rem;
      padding: 0.8rem;
      width: 100%;
      border: 0.5px solid #ccc;
      margin: 4px 1px;
      display: block;
      border-radius: 4px; }
    .flex__section .wrapper button {
      display: block;
      background-color: #0EA5DC;
      font-weight: 700;
      font-size: 1.6rem;
      text-transform: uppercase;
      padding: 1.2rem 3.2rem;
      border: none;
      color: #fff;
      border-radius: 4px;
      cursor: pointer; }
      .flex__section .wrapper button:hover {
        background-color: white;
        color: #0EA5DC;
        border: 1px solid #0EA5DC; }

.center-span {
  position: relative; }
  .center-span span#register-img {
    position: absolute;
    width: 88px;
    height: 88px;
    top: -40px;
    left: calc(50% - 40px);
    display: block;
    background: white;
    border-radius: 50%;
    box-shadow: 0 1px 3px 2px rgba(0, 0, 0, 0.2); }
    .center-span span#register-img img {
      position: relative;
      width: 57%;
      top: 18px;
      left: 18px; }

@media only screen and (max-width: 45rem) {
  .flex__section {
    padding-bottom: 10rem; }
  --content {
    display: flex;
    flex-direction: column; }
  .register-form {
    max-width: 700px;
    margin: 0 0 30px 0; } }

input.error {
  border: 0.5px solid #db7f7f !important;
  background-color: #f1d3d3;
  color: #832929; }

.wrapper__row {
  position: relative; }
  .wrapper__row span#error {
    position: absolute;
    background: #db7f7f;
    border-radius: 4px;
    text-align: center;
    top: -4px;
    right: 0;
    width: 15rem;
    height: 30px;
    font-size: 1.1rem;
    color: white;
    font-weight: 500;
    padding: 0.7rem; }
  .wrapper__row span#error:before {
    position: absolute;
    right: 30px;
    top: -4px;
    display: block;
    width: 8px;
    height: 8px;
    border-right: none;
    border-bottom: none;
    border-radius: 2px;
    transform: rotate(45deg);
    background-color: #db7f7f;
    content: ''; }

footer {
  background: #0873a0; }
  footer .footer__nav {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    text-align: left;
    font-size: 1.6rem; }
    footer .footer__nav .logo-footer {
      margin-top: 3.2rem; }
  footer .footer__nav--links {
    display: flex;
    flex-direction: column;
    margin: 3.2rem 0 0 0; }
    footer .footer__nav--links h4 {
      text-transform: uppercase;
      color: white; }
    footer .footer__nav--links a {
      text-decoration: none;
      color: #a9dff7;
      margin-bottom: 1.2rem; }
      footer .footer__nav--links a:hover {
        color: white;
        font-weight: 500; }
      footer .footer__nav--links a:active {
        text-decoration: underline; }
    footer .footer__nav--links .social-link {
      display: flex;
      align-items: center; }
      footer .footer__nav--links .social-link img {
        margin-right: 0.8rem; }
      footer .footer__nav--links .social-link a {
        margin: 1.2rem 0; }
  footer #copy {
    padding: 3.2rem 0 3.2rem 3.2rem;
    color: #a9dff7;
    font-size: 1.6rem; }

@media only screen and (max-width: 45rem) {
  .footer__nav {
    width: 100%;
    margin: 0; }
    .footer__nav .logo-footer {
      width: 100%;
      margin: 0 auto;
      text-align: center; }
    .footer__nav--links {
      padding: 1.2rem;
      margin: 1.6rem; } }
`, "",{"version":3,"sources":["webpack://./src/sass/base/_base.scss","webpack://./src/sass/base/_settings.scss","webpack://./src/sass/components/_header.scss","webpack://./src/sass/components/_homepage.scss","webpack://./src/sass/components/_registerUser.scss","webpack://./src/sass/components/_footer.scss"],"names":[],"mappings":"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","sourcesContent":["// rBase scss\n*{\n    box-sizing: border-box;\n}\nhtml {\n    font-size: 62.5%;\n    \n}\n\nbody {\n    font-family: Raleway, Lato, Helvetica, Arial, sans-serif;\n    font-size: $m-size;\n    background: #cee3f1;\n}\n\nbutton {\n    cursor: pointer;\n}\n\nbutton:disabled {\n    cursor: default;\n}\n\n.content-container {\n    margin: 0 auto;\n    max-width: 115rem;    \n\n}\n","//colors\n$light-Blue: #a9dff7;\n$blue: #0EA5DC;\n$dark-blue: #0873a0;\n$red-error: #ebc0c0;\n$redDark-error: #db7f7f;\n\n//font\n\n//spacing\n$xs-size: 0.8rem;\n$s-size: 1.2rem;\n$m-size: 1.6rem;\n$l-size: 3.2rem;\n$xl-size: 4.8rem;\n$desktop-breakpoint: 45rem;\n\n\n//grid\n$grid__cols: 12;\n\n","header {\n    position: relative;\n    background: white;\n    padding: $m-size 0 $s-size 0;\n    box-shadow: 0 1px 5px 2px rgba(0, 0, 0, 0.2);\n    .logo {\n        padding-left: $xl-size ;\n    }\n}\n\n\n@media only screen and (max-width: $desktop-breakpoint) {\n    header{\n        padding: $m-size 0;        \n        .logo {\n            max-height: 20%;\n            padding: 0;\n            text-align: center;\n        }\n    }\n}","// Article content\n.article__content {\n    background: $blue;\n    height: 32rem;\n    display: flex;\n    align-items: center;\n    .article__text {\n        color:white;\n        text-align: center;\n        h1 {\n            font-weight: 800;\n            margin: 0;\n            padding: 0 0 $s-size 0;\n        }\n        p{\n            margin: 0;\n            color: $light-Blue;\n            font-weight: 500;\n            padding-bottom: 0.6rem;\n        }\n    }\n}\n\n//Features facilities Hubgets\n .content__article {\n    display: inline-flex;\n    flex-direction: column;\n    width: 46rem;\n    padding: 10rem $m-size 0 $s-size;\n    h4 {\n        text-transform: uppercase;\n        color: #fff;       \n    }\n    article {\n        text-decoration: none;\n        margin-bottom: $s-size;\n    }\n    &--features {\n        display: flex;\n        align-items: center;\n        img{\n            margin-right: $m-size;\n        }\n        a {\n            text-decoration: none ;\n            color: $blue;\n            margin: $s-size 0;\n        }        \n\n    }\n    \n}\n\n.help {\n    display: inline-flex;\n    background-color: #f6f7f8;\n    padding: 3em 0;\n    font-size: $m-size;\n    img {\n      width: 15%;\n    }\n    div {\n    margin-left:$m-size  \n    }\n    a {\n        text-decoration: none;\n        color: $blue;\n    }\n}\n\n@media only screen and (max-width: $desktop-breakpoint) {\n    .content__article {\n        padding: 1rem 0 0 0;\n        display: flex;\n        justify-content:center ;\n        &--features {\n            display: block;\n            text-align: center;\n            img {\n                width: 105px;\n                justify-content: center;\n            }\n        }\n    }\n    .help{\n        justify-content: center;\n    }\n}","//Register section content\n.flex__section {\n    background: #f6f7f8;\n    padding-bottom: 25rem;\n    box-shadow: 0 1px 5px 2px rgba(0, 0, 0, 0.2);\n    &--content{\n        position:relative;\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: space-around;\n        align-items: flex-start;           \n    } \n    .register-form {\n        padding: 10rem 6rem 7rem 6rem;\n        background: white;\n        box-shadow: 0 1px 3px 0.5px rgba(0, 0, 0, 0.2);\n    }\n    \n    //grid-form\n    .wrapper {\n        max-width: 960px;;\n        label {\n        color:#707070;\n        font-weight: 500;\n        }\n        &__row {\n           background: white;  \n           display: flex;\n           justify-content: space-between;\n           flex-wrap: wrap;\n           width: 100%;\n            [class*='col-5'] input {\n               width: 100%;\n            }\n        }    \n        @for $i from 1 through $grid__cols {\n           &__col-#{$i} {\n           width: 100% / $grid__cols *$i;\n            }\n        }\n        [class*='col-'] {\n            padding-top: $s-size;\n            padding-bottom: $xs-size;\n        }        \n        input {\n            height: $l-size ;  \n            padding: $xs-size;\n            width: 100%; \n            border: 0.5px solid #ccc;              \n            margin: 4px 1px;\n            display: block;         \n            border-radius: 4px;\n        }\n        button {\n            display: block;\n            background-color: $blue;\n            font-weight: 700;\n            font-size: $m-size;\n            text-transform: uppercase;\n            padding: $s-size $l-size;\n            border:none;\n            color: #fff;\n            border-radius: 4px;\n            cursor: pointer;\n            &:hover {\n                background-color: white;\n                color: $blue;\n                border: 1px solid $blue; \n            }    \n        }\n    }  \n    \n}\n\n//img content\n.center-span{\n    position: relative;\n    span#register-img {\n        position: absolute;\n        width: 88px;\n        height: 88px;\n        top: -40px;\n        left: calc(50% - 40px);\n        display: block;\n        background: white;\n        border-radius: 50%;\n        box-shadow: 0 1px 3px 2px rgba(0, 0, 0, 0.2);\n        img{\n            position: relative;\n            width: 57%;\n            top:18px;\n            left: 18px;\n        }\n    }\n}\n\n\n@media only screen and (max-width: $desktop-breakpoint) {\n        .flex__section {\n            padding-bottom: 10rem;\n            }\n            &--content{\n                display: flex;\n                flex-direction: column;\n            }\n\n        .register-form {\n            max-width: 700px;\n            margin: 0 0 30px 0;\n    }       \n}\n\n///input validation\ninput.error {\n    border: 0.5px solid $redDark-error !important ;\n    background-color: lighten($red-error, 5%);\n    color: darken($red-error, 50%); \n}\n.wrapper__row{\n    position: relative;\n    span#error{\n        position: absolute;\n        background:$redDark-error;\n        border-radius: 4px;\n        text-align: center;\n        top: -4px;\n        right: 0;\n        width: 15rem;\n        height: 30px;\n        font-size: 1.1rem;\n        color: white;\n        font-weight: 500;\n        padding: 0.7rem;        \n    }\n    span#error:before{\n        position: absolute;\n        right: 30px;\n        top: -4px;\n        display: block;\n        width: 8px;\n        height: 8px;\n        border-right: none;\n        border-bottom: none;\n        border-radius: 2px;\n        transform: rotate(45deg);\n        background-color: $redDark-error;\n        content: '';\n    }\n}\n","footer {\n    background: $dark-blue;\n    .footer__nav {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: space-around;\n        text-align: left;\n        font-size: $m-size;\n        .logo-footer {\n            margin-top: $l-size;   \n        }                 \n    }\n    .footer__nav--links {\n        display: flex;\n        flex-direction: column;\n        margin: $l-size 0 0 0;\n        h4 {\n            text-transform: uppercase;\n            color: white;       \n        }\n        a {\n            text-decoration: none;\n            color: $light-Blue;\n            margin-bottom: $s-size;\n            &:hover {\n                color: white;\n                font-weight: 500;\n              }\n            &:active {\n                text-decoration: underline;\n            }         \n        }\n        .social-link {\n            display: flex;\n            align-items: center;\n            img{\n                margin-right: $xs-size;\n            }\n            a {\n                margin: $s-size 0;\n            }          \n        }\n    }\n    #copy {\n        padding: $l-size 0 $l-size $l-size ;\n        color: $light-Blue;\n        font-size: $m-size;\n    }\n\n}\n\n\n@media only screen and (max-width: $desktop-breakpoint) {\n    .footer__nav {\n        width: 100%;\n        margin:0;\n        .logo-footer{\n            width: 100%;\n            margin: 0 auto ;\n            text-align: center;\n        }\n        &--links {\n            padding: $s-size;\n            margin: $m-size; \n        }\n    }\n}\n\n\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/normalize.css/normalize.css":
/*!**************************************************!*\
  !*** ./node_modules/normalize.css/normalize.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_sass_loader_dist_cjs_js_normalize_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../css-loader/dist/cjs.js!../sass-loader/dist/cjs.js!./normalize.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/normalize.css/normalize.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_sass_loader_dist_cjs_js_normalize_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_sass_loader_dist_cjs_js_normalize_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_sass_loader_dist_cjs_js_normalize_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_sass_loader_dist_cjs_js_normalize_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result &&
        (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            key[Symbol.toStringTag]) ||
            key.constructor.name ||
            "Object"
        ),
        testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : "string" === typeof thing
              ? JSON.stringify(thing)
              : "number" === typeof thing
                ? "`" + thing + "`"
                : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      Internals;
    exports.createPortal = function (children, container) {
      var key =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (
        !container ||
        (1 !== container.nodeType &&
          9 !== container.nodeType &&
          11 !== container.nodeType)
      )
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))
          return fn();
      } finally {
        (ReactSharedInternals.T = previousTransition),
          (Internals.p = previousUpdatePriority),
          Internals.d.f() &&
            console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href
        ? null != options && "object" !== typeof options
          ? console.error(
              "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : null != options &&
            "string" !== typeof options.crossOrigin &&
            console.error(
              "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
            )
        : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      "string" === typeof href &&
        (options
          ? ((options = options.crossOrigin),
            (options =
              "string" === typeof options
                ? "use-credentials" === options
                  ? options
                  : ""
                : void 0))
          : (options = null),
        Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
      else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin")
          ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href
        ? null == options || "object" !== typeof options
          ? console.error(
              "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : "style" !== options.as &&
            "script" !== options.as &&
            console.error(
              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
              getValueDescriptorExpectingEnumForWarning(options.as)
            )
        : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      if (
        "string" === typeof href &&
        options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity =
            "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority =
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0;
        "style" === as
          ? Internals.d.S(
              href,
              "string" === typeof options.precedence
                ? options.precedence
                : void 0,
              {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority
              }
            )
          : "script" === as &&
            Internals.d.X(href, {
              crossOrigin: crossOrigin,
              integrity: integrity,
              fetchPriority: fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "script" !== options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingEnumForWarning(options.as) +
            ".");
      if (encountered)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          encountered
        );
      else
        switch (
          ((encountered =
            options && "string" === typeof options.as ? options.as : "script"),
          encountered)
        ) {
          case "script":
            break;
          default:
            (encountered =
              getValueDescriptorExpectingEnumForWarning(encountered)),
              console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
        }
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as)
            (encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
              Internals.d.M(href, {
                crossOrigin: encountered,
                integrity:
                  "string" === typeof options.integrity
                    ? options.integrity
                    : void 0,
                nonce:
                  "string" === typeof options.nonce ? options.nonce : void 0
              });
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      null == options || "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : ("string" === typeof options.as && options.as) ||
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
      if (
        "string" === typeof href &&
        "object" === typeof options &&
        null !== options &&
        "string" === typeof options.as
      ) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(
          encountered,
          options.crossOrigin
        );
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority:
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0,
          referrerPolicy:
            "string" === typeof options.referrerPolicy
              ? options.referrerPolicy
              : void 0,
          imageSrcSet:
            "string" === typeof options.imageSrcSet
              ? options.imageSrcSet
              : void 0,
          imageSizes:
            "string" === typeof options.imageSizes
              ? options.imageSizes
              : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "string" !== typeof options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
      "string" === typeof href &&
        (options
          ? ((encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
            Internals.d.m(href, {
              as:
                "string" === typeof options.as && "script" !== options.as
                  ? options.as
                  : void 0,
              crossOrigin: encountered,
              integrity:
                "string" === typeof options.integrity
                  ? options.integrity
                  : void 0
            }))
          : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Action: () => (/* binding */ Action),
/* harmony export */   Await: () => (/* binding */ Await),
/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),
/* harmony export */   DataRouterContext: () => (/* binding */ DataRouterContext),
/* harmony export */   DataRouterStateContext: () => (/* binding */ DataRouterStateContext),
/* harmony export */   ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),
/* harmony export */   FetchersContext: () => (/* binding */ FetchersContext),
/* harmony export */   Form: () => (/* binding */ Form),
/* harmony export */   FrameworkContext: () => (/* binding */ FrameworkContext),
/* harmony export */   HashRouter: () => (/* binding */ HashRouter),
/* harmony export */   HistoryRouter: () => (/* binding */ HistoryRouter),
/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),
/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   Link: () => (/* binding */ Link),
/* harmony export */   Links: () => (/* binding */ Links),
/* harmony export */   LocationContext: () => (/* binding */ LocationContext),
/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   NavLink: () => (/* binding */ NavLink),
/* harmony export */   Navigate: () => (/* binding */ Navigate),
/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),
/* harmony export */   Outlet: () => (/* binding */ Outlet),
/* harmony export */   PrefetchPageLinks: () => (/* binding */ PrefetchPageLinks),
/* harmony export */   RemixErrorBoundary: () => (/* binding */ RemixErrorBoundary),
/* harmony export */   Route: () => (/* binding */ Route),
/* harmony export */   RouteContext: () => (/* binding */ RouteContext),
/* harmony export */   Router: () => (/* binding */ Router),
/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),
/* harmony export */   Routes: () => (/* binding */ Routes),
/* harmony export */   Scripts: () => (/* binding */ Scripts),
/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),
/* harmony export */   ServerMode: () => (/* binding */ ServerMode),
/* harmony export */   ServerRouter: () => (/* binding */ ServerRouter),
/* harmony export */   SingleFetchRedirectSymbol: () => (/* binding */ SingleFetchRedirectSymbol),
/* harmony export */   StaticRouter: () => (/* binding */ StaticRouter),
/* harmony export */   StaticRouterProvider: () => (/* binding */ StaticRouterProvider),
/* harmony export */   ViewTransitionContext: () => (/* binding */ ViewTransitionContext),
/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),
/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),
/* harmony export */   createClientRoutes: () => (/* binding */ createClientRoutes),
/* harmony export */   createClientRoutesWithHMRRevalidationOptOut: () => (/* binding */ createClientRoutesWithHMRRevalidationOptOut),
/* harmony export */   createCookie: () => (/* binding */ createCookie),
/* harmony export */   createCookieSessionStorage: () => (/* binding */ createCookieSessionStorage),
/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),
/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),
/* harmony export */   createMemorySessionStorage: () => (/* binding */ createMemorySessionStorage),
/* harmony export */   createPath: () => (/* binding */ createPath),
/* harmony export */   createRequestHandler: () => (/* binding */ createRequestHandler),
/* harmony export */   createRouter: () => (/* binding */ createRouter),
/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),
/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromElements),
/* harmony export */   createRoutesStub: () => (/* binding */ createRoutesStub),
/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),
/* harmony export */   createSession: () => (/* binding */ createSession),
/* harmony export */   createSessionStorage: () => (/* binding */ createSessionStorage),
/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler2),
/* harmony export */   createStaticRouter: () => (/* binding */ createStaticRouter),
/* harmony export */   data: () => (/* binding */ data),
/* harmony export */   decodeViaTurboStream: () => (/* binding */ decodeViaTurboStream),
/* harmony export */   deserializeErrors: () => (/* binding */ deserializeErrors2),
/* harmony export */   generatePath: () => (/* binding */ generatePath),
/* harmony export */   getPatchRoutesOnNavigationFunction: () => (/* binding */ getPatchRoutesOnNavigationFunction),
/* harmony export */   getSingleFetchDataStrategy: () => (/* binding */ getSingleFetchDataStrategy),
/* harmony export */   href: () => (/* binding */ href),
/* harmony export */   invariant: () => (/* binding */ invariant),
/* harmony export */   isCookie: () => (/* binding */ isCookie),
/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),
/* harmony export */   isSession: () => (/* binding */ isSession),
/* harmony export */   mapRouteProperties: () => (/* binding */ mapRouteProperties),
/* harmony export */   matchPath: () => (/* binding */ matchPath),
/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),
/* harmony export */   parsePath: () => (/* binding */ parsePath),
/* harmony export */   redirect: () => (/* binding */ redirect),
/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),
/* harmony export */   renderMatches: () => (/* binding */ renderMatches),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   setDevServerHooks: () => (/* binding */ setDevServerHooks),
/* harmony export */   shouldHydrateRouteLoader: () => (/* binding */ shouldHydrateRouteLoader),
/* harmony export */   useActionData: () => (/* binding */ useActionData),
/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),
/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),
/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),
/* harmony export */   useBlocker: () => (/* binding */ useBlocker),
/* harmony export */   useFetcher: () => (/* binding */ useFetcher),
/* harmony export */   useFetchers: () => (/* binding */ useFetchers),
/* harmony export */   useFogOFWarDiscovery: () => (/* binding */ useFogOFWarDiscovery),
/* harmony export */   useFormAction: () => (/* binding */ useFormAction),
/* harmony export */   useHref: () => (/* binding */ useHref),
/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),
/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),
/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),
/* harmony export */   useLocation: () => (/* binding */ useLocation),
/* harmony export */   useMatch: () => (/* binding */ useMatch),
/* harmony export */   useMatches: () => (/* binding */ useMatches),
/* harmony export */   useNavigate: () => (/* binding */ useNavigate),
/* harmony export */   useNavigation: () => (/* binding */ useNavigation),
/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),
/* harmony export */   useOutlet: () => (/* binding */ useOutlet),
/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),
/* harmony export */   useParams: () => (/* binding */ useParams),
/* harmony export */   usePrompt: () => (/* binding */ usePrompt),
/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),
/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),
/* harmony export */   useRouteError: () => (/* binding */ useRouteError),
/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),
/* harmony export */   useRoutes: () => (/* binding */ useRoutes),
/* harmony export */   useScrollRestoration: () => (/* binding */ useScrollRestoration),
/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),
/* harmony export */   useSubmit: () => (/* binding */ useSubmit),
/* harmony export */   useViewTransitionState: () => (/* binding */ useViewTransitionState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var turbo_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! turbo-stream */ "./node_modules/turbo-stream/dist/turbo-stream.mjs");
/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cookie */ "./node_modules/react-router/node_modules/cookie/dist/index.js");
/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ "./node_modules/set-cookie-parser/lib/set-cookie.js");
/**
 * react-router v7.2.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

// lib/router/history.ts
var Action = /* @__PURE__ */ ((Action2) => {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
  return Action2;
})(Action || {});
var PopStateEventType = "popstate";
function createMemoryHistory(options = {}) {
  let { initialEntries = ["/"], initialIndex, v5Compat = false } = options;
  let entries;
  entries = initialEntries.map(
    (entry, index2) => createMemoryLocation(
      entry,
      typeof entry === "string" ? null : entry.state,
      index2 === 0 ? "default" : void 0
    )
  );
  let index = clampIndex(
    initialIndex == null ? entries.length - 1 : initialIndex
  );
  let action = "POP" /* Pop */;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state = null, key) {
    let location = createLocation(
      entries ? getCurrentLocation().pathname : "/",
      to,
      state,
      key
    );
    warning(
      location.pathname.charAt(0) === "/",
      `relative pathnames are not supported in memory history: ${JSON.stringify(
        to
      )}`
    );
    return location;
  }
  function createHref2(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref: createHref2,
    createURL(to) {
      return new URL(createHref2(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = "PUSH" /* Push */;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({ action, location: nextLocation, delta: 1 });
      }
    },
    replace(to, state) {
      action = "REPLACE" /* Replace */;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({ action, location: nextLocation, delta: 0 });
      }
    },
    go(delta) {
      action = "POP" /* Pop */;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({ action, location: nextLocation, delta });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function createHashHistory(options = {}) {
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substring(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base");
    let href2 = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href2 + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(
      location.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        to
      )})`
    );
  }
  return getUrlBasedHistory(
    createHashLocation,
    createHashHref,
    validateHashLocation,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...typeof to === "string" ? parsePath(to) : to,
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP" /* Pop */;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP" /* Pop */;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH" /* Push */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE" /* Replace */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href2 = typeof to === "string" ? to : createPath(to);
    href2 = href2.replace(/ $/, "%20");
    invariant(
      base,
      `No window.location.(origin|href) available to create URL for href: ${href2}`
    );
    return new URL(href2, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}

// lib/router/utils.ts
var immutableRouteKeys = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
  return routes.map((route, index) => {
    let treePath = [...parentPath, String(index)];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(
      route.index !== true || !route.children,
      `Cannot specify children on an index route`
    );
    invariant(
      !manifest[id],
      `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
    );
    if (isIndexRoute(route)) {
      let indexRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id
      };
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id,
        children: void 0
      };
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(
          route.children,
          mapRouteProperties2,
          treePath,
          manifest
        );
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let { route, pathname, params } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function generatePath(originalPath, params = {}) {
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(
      false,
      `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
    );
    path = path.replace(/\*$/, "/*");
  }
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = (p) => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    if (isLastSegment && segment === "*") {
      const star = "*";
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, `Missing ":${key}" param`);
      return stringify(param);
    }
    return segment.replace(/\?$/g, "");
  }).filter((segment) => !!segment);
  return prefix + segments.join("/");
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  );
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else {
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
var DataWithResponseInit = class {
  constructor(data2, init) {
    this.type = "DataWithResponseInit";
    this.data = data2;
    this.init = init || null;
  }
};
function data(data2, init) {
  return new DataWithResponseInit(
    data2,
    typeof init === "number" ? { status: init } : init
  );
}
var redirect = (url, init = 302) => {
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = { status: responseInit };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, { ...responseInit, headers });
};
var redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
var replace = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Replace", "true");
  return response;
};
var ErrorResponseImpl = class {
  constructor(status, statusText, data2, internal = false) {
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data2 instanceof Error) {
      this.data = data2.toString();
      this.error = data2;
    } else {
      this.data = data2;
    }
  }
};
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

// lib/router/router.ts
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
var validMutationMethods = new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
var validRequestMethods = new Set(validRequestMethodsArr);
var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
var IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  invariant(
    init.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(
    init.routes,
    mapRouteProperties2,
    void 0,
    manifest
  );
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;
  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;
  let future = {
    ...init.future
  };
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions2 = null;
  let getScrollRestorationKey2 = null;
  let getScrollPosition = null;
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialMatchesIsFOW = false;
  let initialErrors = null;
  if (initialMatches == null && !patchRoutesOnNavigationImpl) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let { matches, route } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = { [route.id]: error };
  }
  if (initialMatches && !init.hydrationData) {
    let fogOfWar = checkFogOfWar(
      initialMatches,
      dataRoutes,
      init.history.location.pathname
    );
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    initialized = false;
    initialMatches = [];
    let fogOfWar = checkFogOfWar(
      null,
      dataRoutes,
      init.history.location.pathname
    );
    if (fogOfWar.active && fogOfWar.matches) {
      initialMatchesIsFOW = true;
      initialMatches = fogOfWar.matches;
    }
  } else if (initialMatches.some((m) => m.route.lazy)) {
    initialized = false;
  } else if (!initialMatches.some((m) => m.route.loader)) {
    initialized = true;
  } else {
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    if (errors) {
      let idx = initialMatches.findIndex(
        (m) => errors[m.route.id] !== void 0
      );
      initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    } else {
      initialized = initialMatches.every(
        (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
      );
    }
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = "POP" /* Pop */;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */ new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledFetcherLoads = /* @__PURE__ */ new Set();
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeFetchers = /* @__PURE__ */ new Map();
  let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let unblockBlockerHistoryUpdate = void 0;
  let pendingRevalidationDfd = null;
  function initialize() {
    unlistenHistory = init.history.listen(
      ({ action: historyAction, location, delta }) => {
        if (unblockBlockerHistoryUpdate) {
          unblockBlockerHistoryUpdate();
          unblockBlockerHistoryUpdate = void 0;
          return;
        }
        warning(
          blockerFunctions.size === 0 || delta != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let blockerKey = shouldBlockNavigation({
          currentLocation: state.location,
          nextLocation: location,
          historyAction
        });
        if (blockerKey && delta != null) {
          let nextHistoryUpdatePromise = new Promise((resolve) => {
            unblockBlockerHistoryUpdate = resolve;
          });
          init.history.go(delta * -1);
          updateBlocker(blockerKey, {
            state: "blocked",
            location,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location
              });
              nextHistoryUpdatePromise.then(() => init.history.go(delta));
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({ blockers });
            }
          });
          return;
        }
        return startNavigation(historyAction, location);
      }
    );
    if (isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    if (!state.initialized) {
      startNavigation("POP" /* Pop */, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState, opts = {}) {
    state = {
      ...state,
      ...newState
    };
    let unmountedFetchers = [];
    let mountedFetchers = [];
    state.fetchers.forEach((fetcher, key) => {
      if (fetcher.state === "idle") {
        if (fetchersQueuedForDeletion.has(key)) {
          unmountedFetchers.push(key);
        } else {
          mountedFetchers.push(key);
        }
      }
    });
    fetchersQueuedForDeletion.forEach((key) => {
      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
        unmountedFetchers.push(key);
      }
    });
    [...subscribers].forEach(
      (subscriber) => subscriber(state, {
        deletedFetchers: unmountedFetchers,
        viewTransitionOpts: opts.viewTransitionOpts,
        flushSync: opts.flushSync === true
      })
    );
    unmountedFetchers.forEach((key) => deleteFetcher(key));
    mountedFetchers.forEach((key) => state.fetchers.delete(key));
  }
  function completeNavigation(location, newState, { flushSync } = {}) {
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location.state?._isRedirect !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(
      state.loaderData,
      newState.loaderData,
      newState.matches || [],
      newState.errors
    ) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation) {
    } else if (pendingAction === "POP" /* Pop */) {
    } else if (pendingAction === "PUSH" /* Push */) {
      init.history.push(location, location.state);
    } else if (pendingAction === "REPLACE" /* Replace */) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    if (pendingAction === "POP" /* Pop */) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = /* @__PURE__ */ new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(
      {
        ...newState,
        // matches, errors, fetchers go through as-is
        actionData,
        loaderData,
        historyAction: pendingAction,
        location,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        revalidation: "idle",
        restoreScrollPosition: getSavedScrollPosition(
          location,
          newState.matches || state.matches
        ),
        preventScrollReset,
        blockers
      },
      {
        viewTransitionOpts,
        flushSync: flushSync === true
      }
    );
    pendingAction = "POP" /* Pop */;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    pendingRevalidationDfd?.resolve();
    pendingRevalidationDfd = null;
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(
      state.location,
      state.matches,
      basename,
      to,
      opts?.fromRouteId,
      opts?.relative
    );
    let { path, submission, error } = normalizeNavigateOptions(
      false,
      normalizedPath,
      opts
    );
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = {
      ...nextLocation,
      ...init.history.encodeLocation(nextLocation)
    };
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = "PUSH" /* Push */;
    if (userReplace === true) {
      historyAction = "REPLACE" /* Replace */;
    } else if (userReplace === false) {
    } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = "REPLACE" /* Replace */;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync = (opts && opts.flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({ blockers });
        }
      });
      return;
    }
    await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync
    });
  }
  function revalidate() {
    if (!pendingRevalidationDfd) {
      pendingRevalidationDfd = createDeferred();
    }
    interruptActiveLoads();
    updateState({ revalidation: "loading" });
    let promise = pendingRevalidationDfd.promise;
    if (state.navigation.state === "submitting") {
      return promise;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return promise;
    }
    startNavigation(
      pendingAction || state.historyAction,
      state.navigation.location,
      {
        overrideNavigation: state.navigation,
        // Proxy through any rending view transition
        enableViewTransition: pendingViewTransitionEnabled === true
      }
    );
    return promise;
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      state.matches
    ) : matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, { matches }, { flushSync });
      return;
    }
    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      let { error, notFoundMatches, route } = handleNavigational404(
        location.pathname
      );
      completeNavigation(
        location,
        {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        },
        { flushSync }
      );
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(
      init.history,
      location,
      pendingNavigationController.signal,
      opts && opts.submission
    );
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [
        findNearestBoundary(matches).route.id,
        { type: "error" /* error */, error: opts.pendingError }
      ];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(
        request,
        location,
        opts.submission,
        matches,
        fogOfWar.active,
        { replace: opts.replace, flushSync }
      );
      if (actionResult.shortCircuited) {
        return;
      }
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches = actionResult.matches || matches;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      fogOfWar.active = false;
      request = createClientSideRequest(
        init.history,
        request.url,
        request.signal
      );
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(
      request,
      location,
      matches,
      fogOfWar.active,
      loadingNavigation,
      opts && opts.submission,
      opts && opts.fetcherSubmission,
      opts && opts.replace,
      opts && opts.initialHydration === true,
      flushSync,
      pendingActionResult
    );
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, {
      matches: updatedMatches || matches,
      ...getActionDataForCommit(pendingActionResult),
      loaderData,
      errors
    });
  }
  async function handleAction(request, location, submission, matches, isFogOfWar, opts = {}) {
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({ navigation }, { flushSync: opts.flushSync === true });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        matches,
        location.pathname,
        request.signal
      );
      if (discoverResult.type === "aborted") {
        return { shortCircuited: true };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [
            boundaryId,
            {
              type: "error" /* error */,
              error: discoverResult.error
            }
          ]
        };
      } else if (!discoverResult.matches) {
        let { notFoundMatches, error, route } = handleNavigational404(
          location.pathname
        );
        return {
          matches: notFoundMatches,
          pendingActionResult: [
            route.id,
            {
              type: "error" /* error */,
              error
            }
          ]
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: "error" /* error */,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy(
        "action",
        state,
        request,
        [actionMatch],
        matches,
        null
      );
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        return { shortCircuited: true };
      }
    }
    if (isRedirectResult(result)) {
      let replace2;
      if (opts && opts.replace != null) {
        replace2 = opts.replace;
      } else {
        let location2 = normalizeRedirectLocation(
          result.response.headers.get("Location"),
          new URL(request.url),
          basename
        );
        replace2 = location2 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, true, {
        submission,
        replace: replace2
      });
      return { shortCircuited: true };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = "PUSH" /* Push */;
      }
      return {
        matches,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(
          {
            navigation: loadingNavigation,
            ...actionData !== void 0 ? { actionData } : {}
          },
          {
            flushSync
          }
        );
      }
      let discoverResult = await discoverRoutes(
        matches,
        location.pathname,
        request.signal
      );
      if (discoverResult.type === "aborted") {
        return { shortCircuited: true };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (!discoverResult.matches) {
        let { error, notFoundMatches, route } = handleNavigational404(
          location.pathname
        );
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      activeSubmission,
      location,
      initialHydration === true,
      isRevalidationRequired,
      cancelledFetcherLoads,
      fetchersQueuedForDeletion,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      pendingActionResult
    );
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(
        location,
        {
          matches,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
          ...getActionDataForCommit(pendingActionResult),
          ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
        },
        { flushSync }
      );
      return { shortCircuited: true };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== void 0) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, { flushSync });
    }
    revalidatingFetchers.forEach((rf) => {
      abortFetcher(rf.key);
      if (rf.controller) {
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
    }
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      state,
      matches,
      matchesToLoad,
      revalidatingFetchers,
      request
    );
    if (request.signal.aborted) {
      return { shortCircuited: true };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
    }
    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return { shortCircuited: true };
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return { shortCircuited: true };
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      pendingActionResult,
      revalidatingFetchers,
      fetcherResults
    );
    if (initialHydration && state.errors) {
      errors = { ...state.errors, ...errors };
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return {
      matches,
      loaderData,
      errors,
      ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
    };
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach((rf) => {
      let fetcher = state.fetchers.get(rf.key);
      let revalidatingFetcher = getLoadingFetcher(
        void 0,
        fetcher ? fetcher.data : void 0
      );
      state.fetchers.set(rf.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  async function fetch2(key, routeId, href2, opts) {
    abortFetcher(key);
    let flushSync = (opts && opts.flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(
      state.location,
      state.matches,
      basename,
      href2,
      routeId,
      opts?.relative
    );
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      setFetcherError(
        key,
        routeId,
        getInternalRouterError(404, { pathname: normalizedPath }),
        { flushSync }
      );
      return;
    }
    let { path, submission, error } = normalizeNavigateOptions(
      true,
      normalizedPath,
      opts
    );
    if (error) {
      setFetcherError(key, routeId, error, { flushSync });
      return;
    }
    let match = getTargetMatch(matches, path);
    let preventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      await handleFetcherAction(
        key,
        routeId,
        path,
        match,
        matches,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission
      );
      return;
    }
    fetchLoadMatches.set(key, { routeId, path });
    await handleFetcherLoader(
      key,
      routeId,
      path,
      match,
      matches,
      fogOfWar.active,
      flushSync,
      preventScrollReset,
      submission
    );
  }
  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        setFetcherError(key, routeId, error, { flushSync });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match)) {
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal,
      submission
    );
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        requestMatches,
        path,
        fetchRequest.signal
      );
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, { flushSync });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: path }),
          { flushSync }
        );
        return;
      } else {
        requestMatches = discoverResult.matches;
        match = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match)) {
          return;
        }
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy(
      "action",
      state,
      fetchRequest,
      [match],
      requestMatches,
      key
    );
    let actionResult = actionResults[match.route.id];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, false, {
            fetcherSubmission: submission,
            preventScrollReset
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(
      init.history,
      nextLocation,
      abortController.signal
    );
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      submission,
      nextLocation,
      false,
      isRevalidationRequired,
      cancelledFetcherLoads,
      fetchersQueuedForDeletion,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      [match.route.id, actionResult]
    );
    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
      let staleKey = rf.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(
        void 0,
        existingFetcher2 ? existingFetcher2.data : void 0
      );
      state.fetchers.set(staleKey, revalidatingFetcher);
      abortFetcher(staleKey);
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({ fetchers: new Map(state.fetchers) });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
    abortController.signal.addEventListener(
      "abort",
      abortPendingFetchRevalidations
    );
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      state,
      matches,
      matchesToLoad,
      revalidatingFetchers,
      revalidationRequest
    );
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener(
      "abort",
      abortPendingFetchRevalidations
    );
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      return startRedirectNavigation(
        revalidationRequest,
        redirect2.result,
        false,
        { preventScrollReset }
      );
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      return startRedirectNavigation(
        revalidationRequest,
        redirect2.result,
        false,
        { preventScrollReset }
      );
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      void 0,
      revalidatingFetchers,
      fetcherResults
    );
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(
          state.loaderData,
          loaderData,
          matches,
          errors
        ),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(
      key,
      getLoadingFetcher(
        submission,
        existingFetcher ? existingFetcher.data : void 0
      ),
      { flushSync }
    );
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal
    );
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        matches,
        path,
        fetchRequest.signal
      );
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, { flushSync });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: path }),
          { flushSync }
        );
        return;
      } else {
        matches = discoverResult.matches;
        match = getTargetMatch(matches, path);
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy(
      "loader",
      state,
      fetchRequest,
      [match],
      matches,
      key
    );
    let result = results[match.route.id];
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result, false, {
          preventScrollReset
        });
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  async function startRedirectNavigation(request, redirect2, isNavigation, {
    submission,
    fetcherSubmission,
    preventScrollReset,
    replace: replace2
  } = {}) {
    if (redirect2.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect2.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(
      location,
      new URL(request.url),
      basename
    );
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init.history.createURL(location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace2) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectNavigationType = replace2 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" /* Replace */ : "PUSH" /* Push */;
    let { formMethod, formAction, formEncType } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectNavigationType, redirectLocation, {
        submission: {
          ...activeSubmission,
          formAction: location
        },
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    } else {
      let overrideNavigation = getLoadingNavigation(
        redirectLocation,
        submission
      );
      await startNavigation(redirectNavigationType, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, state2, request, matchesToLoad, matches, fetcherKey) {
    let results;
    let dataResults = {};
    try {
      results = await callDataStrategyImpl(
        dataStrategyImpl,
        type,
        state2,
        request,
        matchesToLoad,
        matches,
        fetcherKey,
        manifest,
        mapRouteProperties2
      );
    } catch (e) {
      matchesToLoad.forEach((m) => {
        dataResults[m.route.id] = {
          type: "error" /* error */,
          error: e
        };
      });
      return dataResults;
    }
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: "redirect" /* redirect */,
          response: normalizeRelativeRoutingRedirectResponse(
            response,
            request,
            routeId,
            matches,
            basename
          )
        };
      } else {
        dataResults[routeId] = await convertDataStrategyResultToDataResult(
          result
        );
      }
    }
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {
    let loaderResultsPromise = callDataStrategy(
      "loader",
      state2,
      request,
      matchesToLoad,
      matches,
      null
    );
    let fetcherResultsPromise = Promise.all(
      fetchersToLoad.map(async (f) => {
        if (f.matches && f.match && f.controller) {
          let results = await callDataStrategy(
            "loader",
            state2,
            createClientSideRequest(init.history, f.path, f.controller.signal),
            [f.match],
            f.matches,
            f.key
          );
          let result = results[f.match.route.id];
          return { [f.key]: result };
        } else {
          return Promise.resolve({
            [f.key]: {
              type: "error" /* error */,
              error: getInternalRouterError(404, {
                pathname: f.path
              })
            }
          });
        }
      })
    );
    let loaderResults = await loaderResultsPromise;
    let fetcherResults = (await fetcherResultsPromise).reduce(
      (acc, r) => Object.assign(acc, r),
      {}
    );
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.add(key);
      }
      abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts = {}) {
    state.fetchers.set(key, fetcher);
    updateState(
      { fetchers: new Map(state.fetchers) },
      { flushSync: (opts && opts.flushSync) === true }
    );
  }
  function setFetcherError(key, routeId, error, opts = {}) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState(
      {
        errors: {
          [boundaryMatch.route.id]: error
        },
        fetchers: new Map(state.fetchers)
      },
      { flushSync: (opts && opts.flushSync) === true }
    );
  }
  function getFetcher(key) {
    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
    if (fetchersQueuedForDeletion.has(key)) {
      fetchersQueuedForDeletion.delete(key);
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    fetchersQueuedForDeletion.delete(key);
    cancelledFetcherLoads.delete(key);
    state.fetchers.delete(key);
  }
  function queueFetcherForDeletion(key) {
    let count = (activeFetchers.get(key) || 0) - 1;
    if (count <= 0) {
      activeFetchers.delete(key);
      fetchersQueuedForDeletion.add(key);
    } else {
      activeFetchers.set(key, count);
    }
    updateState({ fetchers: new Map(state.fetchers) });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    if (controller) {
      controller.abort();
      fetchControllers.delete(key);
    }
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, `Expected fetcher: ${key}`);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(
      blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
    );
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({ blockers });
  }
  function shouldBlockNavigation({
    currentLocation,
    nextLocation,
    historyAction
  }) {
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, { pathname });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let { matches, route } = getShortCircuitMatches(routesToUse);
    return { notFoundMatches: matches, route, error };
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions2 = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey2 = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({ restoreScrollPosition: y });
      }
    }
    return () => {
      savedScrollPositions2 = null;
      getScrollPosition = null;
      getScrollRestorationKey2 = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey2) {
      let key = getScrollRestorationKey2(
        location,
        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
      );
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions2[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions2) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions2[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (patchRoutesOnNavigationImpl) {
      if (!matches) {
        let fogMatches = matchRoutesImpl(
          routesToUse,
          pathname,
          basename,
          true
        );
        return { active: true, matches: fogMatches || [] };
      } else {
        if (Object.keys(matches[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename,
            true
          );
          return { active: true, matches: partialMatches };
        }
      }
    }
    return { active: false, matches: null };
  }
  async function discoverRoutes(matches, pathname, signal) {
    if (!patchRoutesOnNavigationImpl) {
      return { type: "success", matches };
    }
    let partialMatches = matches;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let localManifest = manifest;
      try {
        await patchRoutesOnNavigationImpl({
          signal,
          path: pathname,
          matches: partialMatches,
          patch: (routeId, children) => {
            if (signal.aborted) return;
            patchRoutesImpl(
              routeId,
              children,
              routesToUse,
              localManifest,
              mapRouteProperties2
            );
          }
        });
      } catch (e) {
        return { type: "error", error: e, partialMatches };
      } finally {
        if (isNonHMR && !signal.aborted) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return { type: "aborted" };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches) {
        return { type: "success", matches: newMatches };
      }
      let newPartialMatches = matchRoutesImpl(
        routesToUse,
        pathname,
        basename,
        true
      );
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
        (m, i) => m.route.id === newPartialMatches[i].route.id
      )) {
        return { type: "success", matches: null };
      }
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(
      newRoutes,
      mapRouteProperties2,
      void 0,
      manifest
    );
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(
      routeId,
      children,
      routesToUse,
      manifest,
      mapRouteProperties2
    );
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    encodeLocation: (to) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: queueFetcherForDeletion,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
function createStaticHandler(routes, opts) {
  invariant(
    routes.length > 0,
    "You must provide a non-empty routes array to createStaticHandler"
  );
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;
  let dataRoutes = convertRoutesToDataRoutes(
    routes,
    mapRouteProperties2,
    void 0,
    manifest
  );
  async function query(request, {
    requestContext,
    skipLoaderErrorBubbling,
    dataStrategy
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, { method });
      let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, { pathname: location.pathname });
      let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    let result = await queryImpl(
      request,
      location,
      matches,
      requestContext,
      dataStrategy || null,
      skipLoaderErrorBubbling === true,
      null
    );
    if (isResponse(result)) {
      return result;
    }
    return { location, basename, ...result };
  }
  async function queryRoute(request, {
    routeId,
    requestContext,
    dataStrategy
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, { method });
    } else if (!matches) {
      throw getInternalRouterError(404, { pathname: location.pathname });
    }
    let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      throw getInternalRouterError(404, { pathname: location.pathname });
    }
    let result = await queryImpl(
      request,
      location,
      matches,
      requestContext,
      dataStrategy || null,
      false,
      match
    );
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : void 0;
    if (error !== void 0) {
      throw error;
    }
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      return Object.values(result.loaderData)[0];
    }
    return void 0;
  }
  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {
    invariant(
      request.signal,
      "query()/queryRoute() requests must contain an AbortController signal"
    );
    try {
      if (isMutationMethod(request.method)) {
        let result2 = await submit(
          request,
          matches,
          routeMatch || getTargetMatch(matches, location),
          requestContext,
          dataStrategy,
          skipLoaderErrorBubbling,
          routeMatch != null
        );
        return result2;
      }
      let result = await loadRouteData(
        request,
        matches,
        requestContext,
        dataStrategy,
        skipLoaderErrorBubbling,
        routeMatch
      );
      return isResponse(result) ? result : {
        ...result,
        actionData: null,
        actionHeaders: {}
      };
    } catch (e) {
      if (isDataStrategyResult(e) && isResponse(e.result)) {
        if (e.type === "error" /* error */) {
          throw e.result;
        }
        return e.result;
      }
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: "error" /* error */,
        error
      };
    } else {
      let results = await callDataStrategy(
        "action",
        request,
        [actionMatch],
        matches,
        isRouteRequest,
        requestContext,
        dataStrategy
      );
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest);
      }
    }
    if (isRedirectResult(result)) {
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    }
    if (isRouteRequest) {
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: { [actionMatch.route.id]: result.data },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    if (isErrorResult(result)) {
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
      let context2 = await loadRouteData(
        loaderRequest,
        matches,
        requestContext,
        dataStrategy,
        skipLoaderErrorBubbling,
        null,
        [boundaryMatch.route.id, result]
      );
      return {
        ...context2,
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: {
          ...result.headers ? { [actionMatch.route.id]: result.headers } : {}
        }
      };
    }
    let context = await loadRouteData(
      loaderRequest,
      matches,
      requestContext,
      dataStrategy,
      skipLoaderErrorBubbling,
      null
    );
    return {
      ...context,
      actionData: {
        [actionMatch.route.id]: result.data
      },
      // action status codes take precedence over loader status codes
      ...result.statusCode ? { statusCode: result.statusCode } : {},
      actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}
    };
  }
  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
    let isRouteRequest = routeMatch != null;
    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch?.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;
    let matchesToLoad = requestMatches.filter(
      (m) => m.route.loader || m.route.lazy
    );
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce(
          (acc, m) => Object.assign(acc, { [m.route.id]: null }),
          {}
        ),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {}
      };
    }
    let results = await callDataStrategy(
      "loader",
      request,
      matchesToLoad,
      matches,
      isRouteRequest,
      requestContext,
      dataStrategy
    );
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest);
    }
    let context = processRouteLoaderData(
      matches,
      results,
      pendingActionResult,
      true,
      skipLoaderErrorBubbling
    );
    let executedLoaders = new Set(
      matchesToLoad.map((match) => match.route.id)
    );
    matches.forEach((match) => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return {
      ...context,
      matches
    };
  }
  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {
    let results = await callDataStrategyImpl(
      dataStrategy || defaultDataStrategy,
      type,
      null,
      request,
      matchesToLoad,
      matches,
      null,
      manifest,
      mapRouteProperties2,
      requestContext
    );
    let dataResults = {};
    await Promise.all(
      matches.map(async (match) => {
        if (!(match.route.id in results)) {
          return;
        }
        let result = results[match.route.id];
        if (isRedirectDataStrategyResult(result)) {
          let response = result.result;
          throw normalizeRelativeRoutingRedirectResponse(
            response,
            request,
            match.route.id,
            matches,
            basename
          );
        }
        if (isResponse(result.result) && isRouteRequest) {
          throw result;
        }
        dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
      })
    );
    return dataResults;
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
function getStaticContextFromError(routes, context, error) {
  let newContext = {
    ...context,
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  };
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest) {
  if (request.signal.reason !== void 0) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(
    `${method}() call aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
  );
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches, basename, to, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(
    to ? to : ".",
    getResolveToMatches(contextualMatches),
    stripBasename(location.pathname, basename) || location.pathname,
    relative === "path"
  );
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return { path };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, { method: opts.formMethod })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, { type: "invalid-body" })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = rawFormMethod.toUpperCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce(
          (acc, [name, value]) => `${acc}${name}=${value}
`,
          ""
        )
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(
    typeof FormData === "function",
    "FormData is not available in this environment"
  );
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return { path, submission };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = `?${searchParams}`;
  return { path: createPath(parsedPath), submission };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary = false) {
  let index = matches.findIndex((m) => m.route.id === boundaryId);
  if (index >= 0) {
    return matches.slice(0, includeBoundary ? index + 1 : index);
  }
  return matches;
}
function getMatchesToLoad(history, state, matches, submission, location, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryMatches = matches;
  if (initialHydration && state.errors) {
    boundaryMatches = getLoaderMatchesUntilBoundary(
      matches,
      Object.keys(state.errors)[0],
      true
    );
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    boundaryMatches = getLoaderMatchesUntilBoundary(
      matches,
      pendingActionResult[0]
    );
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let { route } = match;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (initialHydration) {
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    }
    if (isNewLoader(state.loaderData, state.matches[index], match)) {
      return true;
    }
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, {
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params,
      ...submission,
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    });
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.has(key)) {
      cancelledFetcherLoads.delete(key);
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params,
        ...submission,
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      });
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy) {
    return true;
  }
  if (!route.loader) {
    return false;
  }
  let hasData = loaderData != null && loaderData[route.id] !== void 0;
  let hasError = errors != null && errors[route.id] !== void 0;
  if (!hasData && hasError) {
    return false;
  }
  if (typeof route.loader === "function" && route.loader.hydrate === true) {
    return true;
  }
  return !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id
  );
  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(
      route,
      `No route found to patch children into: routeId = ${routeId}`
    );
    if (!route.children) {
      route.children = [];
    }
    childrenToPatch = route.children;
  } else {
    childrenToPatch = routesToUse;
  }
  let uniqueChildren = children.filter(
    (newRoute) => !childrenToPatch.some(
      (existingRoute) => isSameRoute(newRoute, existingRoute)
    )
  );
  let newRoutes = convertRoutesToDataRoutes(
    uniqueChildren,
    mapRouteProperties2,
    [routeId || "_", "patch", String(childrenToPatch?.length || "0")],
    manifest
  );
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
    return true;
  }
  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
    return false;
  }
  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
    return true;
  }
  return newRoute.children.every(
    (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))
  );
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(
      !isPropertyStaticallyDefined,
      `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
    );
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, {
    // To keep things framework agnostic, we use the provided `mapRouteProperties`
    // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
    // since the logic will differ between frameworks.
    ...mapRouteProperties2(routeToUpdate),
    lazy: void 0
  });
}
async function defaultDataStrategy({
  matches
}) {
  let matchesToLoad = matches.filter((m) => m.shouldLoad);
  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
  return results.reduce(
    (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),
    {}
  );
}
async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {
  let loadRouteDefinitionsPromises = matches.map(
    (m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0
  );
  let dsMatches = matches.map((match, i) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i];
    let shouldLoad = matchesToLoad.some((m) => m.route.id === match.route.id);
    let resolve = async (handlerOverride) => {
      if (handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
        shouldLoad = true;
      }
      return shouldLoad ? callLoaderOrAction(
        type,
        request,
        match,
        loadRoutePromise,
        handlerOverride,
        requestContext
      ) : Promise.resolve({ type: "data" /* data */, result: void 0 });
    };
    return {
      ...match,
      shouldLoad,
      resolve
    };
  });
  let results = await dataStrategyImpl({
    matches: dsMatches,
    request,
    params: matches[0].params,
    fetcherKey,
    context: requestContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch (e) {
  }
  return results;
}
async function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = (ctx) => {
      if (typeof handler !== "function") {
        return Promise.reject(
          new Error(
            `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match.route.id}]`
          )
        );
      }
      return handler(
        {
          request,
          params: match.params,
          context: staticContext
        },
        ...ctx !== void 0 ? [ctx] : []
      );
    };
    let handlerPromise = (async () => {
      try {
        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
        return { type: "data", result: val };
      } catch (e) {
        return { type: "error", result: e };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (loadRoutePromise) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e) => {
            handlerError = e;
          }),
          loadRoutePromise
        ]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadRoutePromise;
        handler = match.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          return { type: "data" /* data */, result: void 0 };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
  } catch (e) {
    return { type: "error" /* error */, result: e };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let { result, type } = dataStrategyResult;
  if (isResponse(result)) {
    let data2;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data2 = null;
        } else {
          data2 = await result.json();
        }
      } else {
        data2 = await result.text();
      }
    } catch (e) {
      return { type: "error" /* error */, error: e };
    }
    if (type === "error" /* error */) {
      return {
        type: "error" /* error */,
        error: new ErrorResponseImpl(result.status, result.statusText, data2),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: "data" /* data */,
      data: data2,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === "error" /* error */) {
    if (isDataWithResponseInit(result)) {
      if (result.data instanceof Error) {
        return {
          type: "error" /* error */,
          error: result.data,
          statusCode: result.init?.status,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: "error" /* error */,
        error: new ErrorResponseImpl(
          result.init?.status || 500,
          void 0,
          result.data
        ),
        statusCode: isRouteErrorResponse(result) ? result.status : void 0,
        headers: result.init?.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: "error" /* error */,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDataWithResponseInit(result)) {
    return {
      type: "data" /* data */,
      data: result.data,
      statusCode: result.init?.status,
      headers: result.init?.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return { type: "data" /* data */, data: result };
}
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {
  let location = response.headers.get("Location");
  invariant(
    location,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  );
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches.slice(
      0,
      matches.findIndex((m) => m.route.id === routeId) + 1
    );
    location = normalizeTo(
      new URL(request.url),
      trimmedMatches,
      basename,
      location
    );
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = { signal };
  if (submission && isMutationMethod(submission.formMethod)) {
    let { formMethod, formEncType } = submission;
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({ "Content-Type": formEncType });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  matches.forEach((match) => {
    if (!(match.route.id in results)) {
      return;
    }
    let id = match.route.id;
    let result = results[id];
    invariant(
      !isRedirectResult(result),
      "Cannot handle redirect results in processLoaderData"
    );
    if (isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0) {
        error = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id] = error;
      } else {
        let boundaryMatch = findNearestBoundary(matches, id);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      if (!isStaticHandler) {
        loaderData[id] = ResetLoaderDataSymbol;
      }
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      loaderData[id] = result.data;
      if (result.statusCode && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = { [pendingActionResult[0]]: pendingError };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
  let { loaderData, errors } = processRouteLoaderData(
    matches,
    results,
    pendingActionResult
  );
  revalidatingFetchers.forEach((rf) => {
    let { key, match, controller } = rf;
    let result = fetcherResults[key];
    invariant(result, "Did not find corresponding fetcher result");
    if (controller && controller.signal.aborted) {
      return;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = {
          ...errors,
          [boundaryMatch.route.id]: result.error
        };
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  });
  return { loaderData, errors };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
    merged[k] = v;
    return merged;
  }, {});
  for (let match of matches) {
    let id = match.route.id;
    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === "/") || {
    id: `__shim-error-route__`
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route
      }
    ],
    route
  };
}
function getInternalRouterError(status, {
  pathname,
  routeId,
  method,
  type,
  message
} = {}) {
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = `No route matches URL "${pathname}"`;
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (method) {
      errorMessage = `Invalid request method "${method.toUpperCase()}"`;
    }
  }
  return new ErrorResponseImpl(
    status || 500,
    statusText,
    new Error(errorMessage),
    true
  );
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i = entries.length - 1; i >= 0; i--) {
    let [key, result] = entries[i];
    if (isRedirectResult(result)) {
      return { key, result };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath({ ...parsedPath, hash: "" });
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    return true;
  } else if (b.hash !== "") {
    return true;
  }
  return false;
}
function isDataStrategyResult(result) {
  return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === "data" /* data */ || result.type === "error" /* error */);
}
function isRedirectDataStrategyResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isErrorResult(result) {
  return result.type === "error" /* error */;
}
function isRedirectResult(result) {
  return (result && result.type) === "redirect" /* redirect */;
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectStatusCode(statusCode) {
  return redirectStatusCodes.has(statusCode);
}
function isRedirectResponse(result) {
  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has("Location");
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toUpperCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toUpperCase());
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v) => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let { formMethod, formAction, formEncType, text, formData, json } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data2) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: data2
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
function getDoneFetcher(data2) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data2
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(
      TRANSITIONS_STORAGE_KEY
    );
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(
        TRANSITIONS_STORAGE_KEY,
        JSON.stringify(json)
      );
    } catch (error) {
      warning(
        false,
        `Failed to save applied view transitions in sessionStorage (${error}).`
      );
    }
  }
}
function createDeferred() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async (val) => {
      res(val);
      try {
        await promise;
      } catch (e) {
      }
    };
    reject = async (error) => {
      rej(error);
      try {
        await promise;
      } catch (e) {
      }
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/components.tsx


// lib/context.ts

var DataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
RouteErrorContext.displayName = "RouteError";

// lib/hooks.tsx

var ENABLE_DEV_WARNINGS = true;
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;
}
function useNavigationType() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;
}
function useMatch(pattern) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useMatch() may be used only in the context of a <Router> component.`
  );
  let { pathname } = useLocation();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matchPath(pattern, decodePath(pathname)),
    [pathname, pattern]
  );
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;
  if (!isStatic) {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
var OutletContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
function useOutletContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, { value: context }, outlet);
  }
  return outlet;
}
function useParams() {
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, { relative } = {}) {
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2, static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (ENABLE_DEV_WARNINGS) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, { pathname: remainingPathname });
  if (ENABLE_DEV_WARNINGS) {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP" /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  if (ENABLE_DEV_WARNINGS) {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "React Router caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && errors?.[m.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce(
            "route-fallback",
            false,
            "No `HydrateFallback` element provided to render during initial hydration"
          );
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        RenderedRoute,
        {
          match,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        }
      );
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      RenderErrorBoundary,
      {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: { outlet: null, matches: matches2, isDataRoute: true }
      }
    ) : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId("useRouteId" /* UseRouteId */);
}
function useNavigation() {
  let state = useDataRouterState("useNavigation" /* UseNavigation */);
  return state.navigation;
}
function useRevalidator() {
  let dataRouterContext = useDataRouterContext("useRevalidator" /* UseRevalidator */);
  let state = useDataRouterState("useRevalidator" /* UseRevalidator */);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      async revalidate() {
        await dataRouterContext.router.revalidate();
      },
      state: state.revalidation
    }),
    [dataRouterContext.router, state.revalidation]
  );
}
function useMatches() {
  let { matches, loaderData } = useDataRouterState(
    "useMatches" /* UseMatches */
  );
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
    [matches, loaderData]
  );
}
function useLoaderData() {
  let state = useDataRouterState("useLoaderData" /* UseLoaderData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.loaderData[routeId];
}
function useRouteLoaderData(routeId) {
  let state = useDataRouterState("useRouteLoaderData" /* UseRouteLoaderData */);
  return state.loaderData[routeId];
}
function useActionData() {
  let state = useDataRouterState("useActionData" /* UseActionData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.actionData ? state.actionData[routeId] : void 0;
}
function useRouteError() {
  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);
  let state = useDataRouterState("useRouteError" /* UseRouteError */);
  let routeId = useCurrentRouteId("useRouteError" /* UseRouteError */);
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useAsyncValue() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._data;
}
function useAsyncError() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._error;
}
var blockerId = 0;
function useBlocker(shouldBlock) {
  let { router, basename } = useDataRouterContext("useBlocker" /* UseBlocker */);
  let state = useDataRouterState("useBlocker" /* UseBlocker */);
  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (arg) => {
      if (typeof shouldBlock !== "function") {
        return !!shouldBlock;
      }
      if (basename === "/") {
        return shouldBlock(arg);
      }
      let { currentLocation, nextLocation, historyAction } = arg;
      return shouldBlock({
        currentLocation: {
          ...currentLocation,
          pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
        },
        nextLocation: {
          ...nextLocation,
          pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
        },
        historyAction
      });
    },
    [basename, shouldBlock]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}
function useNavigateStable() {
  let { router } = useDataRouterContext("useNavigate" /* UseNavigateStable */);
  let id = useCurrentRouteId("useNavigate" /* UseNavigateStable */);
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}

// lib/server-runtime/warnings.ts
var alreadyWarned2 = {};
function warnOnce(condition, message) {
  if (!condition && !alreadyWarned2[message]) {
    alreadyWarned2[message] = true;
    console.warn(message);
  }
}

// lib/components.tsx
var ENABLE_DEV_WARNINGS2 = true;
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.element) {
        warning(
          false,
          "You should not include both `Component` and `element` on your route - `Component` will be used."
        );
      }
    }
    Object.assign(updates, {
      element: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.hydrateFallbackElement) {
        warning(
          false,
          "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
        );
      }
    }
    Object.assign(updates, {
      hydrateFallbackElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.errorElement) {
        warning(
          false,
          "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
        );
      }
    }
    Object.assign(updates, {
      errorElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createMemoryHistory({
      initialEntries: opts?.initialEntries,
      initialIndex: opts?.initialIndex
    }),
    hydrationData: opts?.hydrationData,
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation
  }).initialize();
}
var Deferred = class {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = (reason) => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
};
function RouterProvider({
  router,
  flushSync: reactDomFlushSyncImpl
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);
  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map());
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
      newState.fetchers.forEach((fetcher, key) => {
        if (fetcher.data !== void 0) {
          fetcherData.current.set(key, fetcher.data);
        }
      });
      deletedFetchers.forEach((key) => fetcherData.current.delete(key));
      warnOnce(
        flushSync === false || reactDomFlushSyncImpl != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === "function";
      warnOnce(
        viewTransitionOpts == null || isViewTransitionAvailable,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      );
      if (!viewTransitionOpts || !isViewTransitionAvailable) {
        if (reactDomFlushSyncImpl && flushSync) {
          reactDomFlushSyncImpl(() => setStateImpl(newState));
        } else {
          react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
        }
        return;
      }
      if (reactDomFlushSyncImpl && flushSync) {
        reactDomFlushSyncImpl(() => {
          if (transition) {
            renderDfd && renderDfd.resolve();
            transition.skipTransition();
          }
          setVtContext({
            isTransitioning: true,
            flushSync: true,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        });
        let t = router.window.document.startViewTransition(() => {
          reactDomFlushSyncImpl(() => setStateImpl(newState));
        });
        t.finished.finally(() => {
          reactDomFlushSyncImpl(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({ isTransitioning: false });
          });
        });
        reactDomFlushSyncImpl(() => setTransition(t));
        return;
      }
      if (transition) {
        renderDfd && renderDfd.resolve();
        transition.skipTransition();
        setInterruption({
          state: newState,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      } else {
        setPendingState(newState);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      }
    },
    [router.window, reactDomFlushSyncImpl, transition, renderDfd]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router.window.document.startViewTransition(async () => {
        react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({ isTransitioning: false });
      });
      setTransition(transition2);
    }
  }, [pendingState, renderDfd, router.window]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  let navigator2 = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: (n) => router.navigate(n),
      push: (to, state2, opts) => router.navigate(to, {
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      }),
      replace: (to, state2, opts) => router.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      router,
      navigator: navigator2,
      static: false,
      basename
    }),
    [router, navigator2, basename]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: navigator2
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      MemoizedDataRoutes,
      {
        routes: router.routes,
        future: router.future,
        state
      }
    )
  ))))), null);
}
var MemoizedDataRoutes = react__WEBPACK_IMPORTED_MODULE_0__.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function MemoryRouter({
  basename,
  children,
  initialEntries,
  initialIndex
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function Navigate({
  to,
  replace: replace2,
  state,
  relative
}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    `<Navigate> may be used only in the context of a <Router> component.`
  );
  let { static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  warning(
    !isStatic,
    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
  );
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(
    to,
    getResolveToMatches(matches),
    locationPathname,
    relative === "path"
  );
  let jsonPath = JSON.stringify(path);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
  }, [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP" /* Pop */,
  navigator: navigator2,
  static: staticProp = false
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: {}
    }),
    [basename, navigator2, staticProp]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function Await({
  children,
  errorElement,
  resolve
}) {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, { resolve, errorElement }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));
}
var AwaitErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "<Await> caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    let { children, errorElement, resolve } = this.props;
    let promise = null;
    let status = 0 /* pending */;
    if (!(resolve instanceof Promise)) {
      status = 1 /* success */;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_data", { get: () => resolve });
    } else if (this.state.error) {
      status = 2 /* error */;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {
      });
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_error", { get: () => renderError });
    } else if (resolve._tracked) {
      promise = resolve;
      status = "_error" in promise ? 2 /* error */ : "_data" in promise ? 1 /* success */ : 0 /* pending */;
    } else {
      status = 0 /* pending */;
      Object.defineProperty(resolve, "_tracked", { get: () => true });
      promise = resolve.then(
        (data2) => Object.defineProperty(resolve, "_data", { get: () => data2 }),
        (error) => Object.defineProperty(resolve, "_error", { get: () => error })
      );
    }
    if (status === 2 /* error */ && !errorElement) {
      throw promise._error;
    }
    if (status === 2 /* error */) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children: errorElement });
    }
    if (status === 1 /* success */) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children });
    }
    throw promise;
  }
};
function ResolveAwait({
  children
}) {
  let data2 = useAsyncValue();
  let toRender = typeof children === "function" ? children(data2) : children;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {
    if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var createRoutesFromElements = createRoutesFromChildren;
function renderMatches(matches) {
  return _renderMatches(matches);
}

// lib/dom/lib.tsx


// lib/dom/dom.ts
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init = "") {
  return new URLSearchParams(
    typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
      let value = init[key];
      return memo2.concat(
        Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]
      );
    }, [])
  );
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}

// lib/dom/ssr/components.tsx


// lib/dom/ssr/invariant.ts
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// lib/dom/ssr/routeModules.ts
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    /* unsupported import.meta.hot */ undefined) {}
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// lib/dom/ssr/links.ts
function getKeyedLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    let module = routeModules[match.route.id];
    let route = manifest.routes[match.route.id];
    return [
      route && route.css ? route.css.map((href2) => ({ rel: "stylesheet", href: href2 })) : [],
      module?.links?.() || []
    ];
  }).flat(2);
  let preloads = getModuleLinkHrefs(matches, manifest);
  return dedupeLinkDescriptors(descriptors, preloads);
}
function getRouteCssDescriptors(route) {
  if (!route.css) return [];
  return route.css.map((href2) => ({ rel: "stylesheet", href: href2 }));
}
async function prefetchRouteCss(route) {
  if (!route.css) return;
  let descriptors = getRouteCssDescriptors(route);
  await Promise.all(descriptors.map(prefetchStyleLink));
}
async function prefetchStyleLinks(route, routeModule) {
  if (!route.css && !routeModule.links || !isPreloadSupported()) return;
  let descriptors = [];
  if (route.css) {
    descriptors.push(...getRouteCssDescriptors(route));
  }
  if (routeModule.links) {
    descriptors.push(...routeModule.links());
  }
  if (descriptors.length === 0) return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push({
        ...descriptor,
        rel: "preload",
        as: "style"
      });
    }
  }
  await Promise.all(styleLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(
      `link[rel="stylesheet"][href="${descriptor.href}"]`
    )) {
      return resolve();
    }
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
var _isPreloadSupported;
function isPreloadSupported() {
  if (_isPreloadSupported !== void 0) {
    return _isPreloadSupported;
  }
  let el = document.createElement("link");
  _isPreloadSupported = el.relList.supports("preload");
  el = null;
  return _isPreloadSupported;
}

// lib/dom/ssr/markup.ts
var ESCAPE_LOOKUP = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
function createHtml(html) {
  return { __html: html };
}

// lib/dom/ssr/single-fetch.tsx



// lib/dom/ssr/data.ts
async function createRequestInit(request) {
  let init = { signal: request.signal };
  if (request.method !== "GET") {
    init.method = request.method;
    let contentType = request.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      init.headers = { "Content-Type": contentType };
      init.body = JSON.stringify(await request.json());
    } else if (contentType && /\btext\/plain\b/.test(contentType)) {
      init.headers = { "Content-Type": contentType };
      init.body = await request.text();
    } else if (contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType)) {
      init.body = new URLSearchParams(await request.text());
    } else {
      init.body = await request.formData();
    }
  }
  return init;
}

// lib/dom/ssr/single-fetch.tsx
var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
function StreamTransfer({
  context,
  identifier,
  reader,
  textDecoder,
  nonce
}) {
  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {
    return null;
  }
  if (!context.renderMeta.streamCache) {
    context.renderMeta.streamCache = {};
  }
  let { streamCache } = context.renderMeta;
  let promise = streamCache[identifier];
  if (!promise) {
    promise = streamCache[identifier] = reader.read().then((result) => {
      streamCache[identifier].result = {
        done: result.done,
        value: textDecoder.decode(result.value, { stream: true })
      };
    }).catch((e) => {
      streamCache[identifier].error = e;
    });
  }
  if (promise.error) {
    throw promise.error;
  }
  if (promise.result === void 0) {
    throw promise;
  }
  let { done, value } = promise.result;
  let scriptTag = value ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      nonce,
      dangerouslySetInnerHTML: {
        __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(
          JSON.stringify(value)
        )});`
      }
    }
  ) : null;
  if (done) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        nonce,
        dangerouslySetInnerHTML: {
          __html: `window.__reactRouterContext.streamController.close();`
        }
      }
    ));
  } else {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      StreamTransfer,
      {
        context,
        identifier: identifier + 1,
        reader,
        textDecoder,
        nonce
      }
    )));
  }
}
function getSingleFetchDataStrategy(manifest, routeModules, ssr, getRouter) {
  return async ({ request, matches, fetcherKey }) => {
    if (request.method !== "GET") {
      return singleFetchActionStrategy(request, matches);
    }
    if (!ssr) {
      let foundRevalidatingServerLoader = matches.some(
        (m) => m.shouldLoad && manifest.routes[m.route.id]?.hasLoader && !manifest.routes[m.route.id]?.hasClientLoader
      );
      if (!foundRevalidatingServerLoader) {
        let matchesToLoad = matches.filter((m) => m.shouldLoad);
        let url = stripIndexParam(singleFetchUrl(request.url));
        let init = await createRequestInit(request);
        let results = {};
        await Promise.all(
          matchesToLoad.map(
            (m) => m.resolve(async (handler) => {
              try {
                let result = manifest.routes[m.route.id]?.hasClientLoader ? await fetchSingleLoader(handler, url, init, m.route.id) : await handler();
                results[m.route.id] = { type: "data", result };
              } catch (e) {
                results[m.route.id] = { type: "error", result: e };
              }
            })
          )
        );
        return results;
      }
    }
    if (fetcherKey) {
      return singleFetchLoaderFetcherStrategy(request, matches);
    }
    return singleFetchLoaderNavigationStrategy(
      manifest,
      routeModules,
      ssr,
      getRouter(),
      request,
      matches
    );
  };
}
async function singleFetchActionStrategy(request, matches) {
  let actionMatch = matches.find((m) => m.shouldLoad);
  invariant2(actionMatch, "No action match found");
  let actionStatus = void 0;
  let result = await actionMatch.resolve(async (handler) => {
    let result2 = await handler(async () => {
      let url = singleFetchUrl(request.url);
      let init = await createRequestInit(request);
      let { data: data2, status } = await fetchAndDecode(url, init);
      actionStatus = status;
      return unwrapSingleFetchResult(
        data2,
        actionMatch.route.id
      );
    });
    return result2;
  });
  if (isResponse(result.result) || isRouteErrorResponse(result.result)) {
    return { [actionMatch.route.id]: result };
  }
  return {
    [actionMatch.route.id]: {
      type: result.type,
      result: data(result.result, actionStatus)
    }
  };
}
async function singleFetchLoaderNavigationStrategy(manifest, routeModules, ssr, router, request, matches) {
  let routesParams = /* @__PURE__ */ new Set();
  let foundOptOutRoute = false;
  let routeDfds = matches.map(() => createDeferred2());
  let routesLoadedPromise = Promise.all(routeDfds.map((d) => d.promise));
  let singleFetchDfd = createDeferred2();
  let url = stripIndexParam(singleFetchUrl(request.url));
  let init = await createRequestInit(request);
  let results = {};
  let resolvePromise = Promise.all(
    matches.map(
      async (m, i) => m.resolve(async (handler) => {
        routeDfds[i].resolve();
        let manifestRoute = manifest.routes[m.route.id];
        if (!m.shouldLoad) {
          if (!router.state.initialized) {
            return;
          }
          if (m.route.id in router.state.loaderData && manifestRoute && manifestRoute.hasLoader && routeModules[m.route.id]?.shouldRevalidate) {
            foundOptOutRoute = true;
            return;
          }
        }
        if (manifestRoute && manifestRoute.hasClientLoader) {
          if (manifestRoute.hasLoader) {
            foundOptOutRoute = true;
          }
          try {
            let result = await fetchSingleLoader(
              handler,
              url,
              init,
              m.route.id
            );
            results[m.route.id] = { type: "data", result };
          } catch (e) {
            results[m.route.id] = { type: "error", result: e };
          }
          return;
        }
        if (manifestRoute && manifestRoute.hasLoader) {
          routesParams.add(m.route.id);
        }
        try {
          let result = await handler(async () => {
            let data2 = await singleFetchDfd.promise;
            return unwrapSingleFetchResults(data2, m.route.id);
          });
          results[m.route.id] = {
            type: "data",
            result
          };
        } catch (e) {
          results[m.route.id] = {
            type: "error",
            result: e
          };
        }
      })
    )
  );
  await routesLoadedPromise;
  if ((!router.state.initialized || routesParams.size === 0) && !window.__reactRouterHdrActive) {
    singleFetchDfd.resolve({});
  } else {
    try {
      if (ssr && foundOptOutRoute && routesParams.size > 0) {
        url.searchParams.set(
          "_routes",
          matches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
        );
      }
      let data2 = await fetchAndDecode(url, init);
      singleFetchDfd.resolve(data2.data);
    } catch (e) {
      singleFetchDfd.reject(e);
    }
  }
  await resolvePromise;
  return results;
}
async function singleFetchLoaderFetcherStrategy(request, matches) {
  let fetcherMatch = matches.find((m) => m.shouldLoad);
  invariant2(fetcherMatch, "No fetcher match found");
  let result = await fetcherMatch.resolve(async (handler) => {
    let url = stripIndexParam(singleFetchUrl(request.url));
    let init = await createRequestInit(request);
    return fetchSingleLoader(handler, url, init, fetcherMatch.route.id);
  });
  return { [fetcherMatch.route.id]: result };
}
function fetchSingleLoader(handler, url, init, routeId) {
  return handler(async () => {
    let singleLoaderUrl = new URL(url);
    singleLoaderUrl.searchParams.set("_routes", routeId);
    let { data: data2 } = await fetchAndDecode(singleLoaderUrl, init);
    return unwrapSingleFetchResults(data2, routeId);
  });
}
function stripIndexParam(url) {
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return url;
}
function singleFetchUrl(reqUrl) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}
async function fetchAndDecode(url, init) {
  let res = await fetch(url, init);
  if (res.status === 404 && !res.headers.has("X-Remix-Response")) {
    throw new ErrorResponseImpl(404, "Not Found", true);
  }
  const NO_BODY_STATUS_CODES2 = /* @__PURE__ */ new Set([100, 101, 204, 205]);
  if (NO_BODY_STATUS_CODES2.has(res.status)) {
    if (!init.method || init.method === "GET") {
      return { status: res.status, data: {} };
    } else {
      return { status: res.status, data: { data: void 0 } };
    }
  }
  invariant2(res.body, "No response body to decode");
  try {
    let decoded = await decodeViaTurboStream(res.body, window);
    return { status: res.status, data: decoded.value };
  } catch (e) {
    throw new Error("Unable to decode turbo-stream response");
  }
}
function decodeViaTurboStream(body, global2) {
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.decode)(body, {
    plugins: [
      (type, ...rest) => {
        if (type === "SanitizedError") {
          let [name, message, stack] = rest;
          let Constructor = Error;
          if (name && name in global2 && typeof global2[name] === "function") {
            Constructor = global2[name];
          }
          let error = new Constructor(message);
          error.stack = stack;
          return { value: error };
        }
        if (type === "ErrorResponse") {
          let [data2, status, statusText] = rest;
          return {
            value: new ErrorResponseImpl(status, statusText, data2)
          };
        }
        if (type === "SingleFetchRedirect") {
          return { value: { [SingleFetchRedirectSymbol]: rest[0] } };
        }
        if (type === "SingleFetchClassInstance") {
          return { value: rest[0] };
        }
        if (type === "SingleFetchFallback") {
          return { value: void 0 };
        }
      }
    ]
  });
}
function unwrapSingleFetchResults(results, routeId) {
  let redirect2 = results[SingleFetchRedirectSymbol];
  if (redirect2) {
    return unwrapSingleFetchResult(redirect2, routeId);
  }
  return results[routeId] !== void 0 ? unwrapSingleFetchResult(results[routeId], routeId) : null;
}
function unwrapSingleFetchResult(result, routeId) {
  if ("error" in result) {
    throw result.error;
  } else if ("redirect" in result) {
    let headers = {};
    if (result.revalidate) {
      headers["X-Remix-Revalidate"] = "yes";
    }
    if (result.reload) {
      headers["X-Remix-Reload-Document"] = "yes";
    }
    if (result.replace) {
      headers["X-Remix-Replace"] = "yes";
    }
    throw redirect(result.redirect, { status: result.status, headers });
  } else if ("data" in result) {
    return result.data;
  } else {
    throw new Error(`No response found for routeId "${routeId}"`);
  }
}
function createDeferred2() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async (val) => {
      res(val);
      try {
        await promise;
      } catch (e) {
      }
    };
    reject = async (error) => {
      rej(error);
      try {
        await promise;
      } catch (e) {
      }
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/dom/ssr/fog-of-war.ts


// lib/dom/ssr/routes.tsx


// lib/dom/ssr/errorBoundaries.tsx

var RemixErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = { error: props.error || null, location: props.location };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return { error: props.error || null, location: props.location };
    }
    return { error: props.error || state.error, location: state.location };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        RemixRootDefaultErrorBoundary,
        {
          error: this.state.error,
          isOutsideRemixApp: true
        }
      );
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error,
  isOutsideRemixApp
}) {
  console.error(error);
  let heyDeveloper = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
        );
      `
      }
    }
  );
  if (isRouteErrorResponse(error)) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: "Unhandled Thrown Response!" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", { style: { fontSize: "24px" } }, error.status, " ", error.statusText), heyDeveloper);
  }
  let errorInstance;
  if (error instanceof Error) {
    errorInstance = error;
  } else {
    let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
    errorInstance = new Error(errorString);
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    BoundaryShell,
    {
      title: "Application Error!",
      isOutsideRemixApp
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "pre",
      {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      },
      errorInstance.stack
    ),
    heyDeveloper
  );
}
function BoundaryShell({
  title,
  renderScripts,
  isOutsideRemixApp,
  children
}) {
  let { routeModules } = useFrameworkContext();
  if (routeModules.root?.Layout && !isOutsideRemixApp) {
    return children;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("html", { lang: "en" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("head", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", null, title)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("body", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, children, renderScripts ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Scripts, null) : null)));
}

// lib/dom/ssr/fallback.tsx

function RemixRootDefaultHydrateFallback() {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: "Loading...", renderScripts: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
              console.log(
                "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://remix.run/route/hydrate-fallback " +
                "for more information."
              );
            `
      }
    }
  ));
}

// lib/dom/ssr/routes.tsx
function groupRoutesByParentId(manifest) {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function getRouteComponents(route, routeModule, isSpaMode) {
  let Component4 = getRouteModuleComponent(routeModule);
  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === "root") ? routeModule.HydrateFallback : route.id === "root" ? RemixRootDefaultHydrateFallback : void 0;
  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === "root" ? () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;
  if (route.id === "root" && routeModule.Layout) {
    return {
      ...Component4 ? {
        element: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component4, null))
      } : { Component: Component4 },
      ...ErrorBoundary ? {
        errorElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, null))
      } : { ErrorBoundary },
      ...HydrateFallback ? {
        hydrateFallbackElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HydrateFallback, null))
      } : { HydrateFallback }
    };
  }
  return { Component: Component4, ErrorBoundary, HydrateFallback };
}
function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {
  return (routesByParentId[parentId] || []).map((route) => {
    let routeModule = routeModules[route.id];
    invariant2(
      routeModule,
      "No `routeModule` available to create server routes"
    );
    let dataRoute = {
      ...getRouteComponents(route, routeModule, isSpaMode),
      caseSensitive: route.caseSensitive,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: routeModule.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0
      // We don't need action/shouldRevalidate on these routes since they're
      // for a static render
    };
    let children = createServerRoutes(
      manifest,
      routeModules,
      future,
      isSpaMode,
      route.id,
      routesByParentId,
      spaModeLazyPromise
    );
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {
  return createClientRoutes(
    manifest,
    routeModulesCache,
    initialState,
    ssr,
    isSpaMode,
    "",
    groupRoutesByParentId(manifest),
    needsRevalidation
  );
}
function preventInvalidServerHandlerCall(type, route) {
  if (type === "loader" && !route.hasLoader || type === "action" && !route.hasAction) {
    let fn = type === "action" ? "serverAction()" : "serverLoader()";
    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: "${route.id}")`;
    console.error(msg);
    throw new ErrorResponseImpl(400, "Bad Request", new Error(msg), true);
  }
}
function noActionDefinedError(type, routeId) {
  let article = type === "clientAction" ? "a" : "an";
  let msg = `Route "${routeId}" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \`${type}\` function to the route`;
  console.error(msg);
  throw new ErrorResponseImpl(405, "Method Not Allowed", new Error(msg), true);
}
function createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
  return (routesByParentId[parentId] || []).map((route) => {
    let routeModule = routeModulesCache[route.id];
    function fetchServerHandler(singleFetch) {
      invariant2(
        typeof singleFetch === "function",
        "No single fetch function available for route handler"
      );
      return singleFetch();
    }
    function fetchServerLoader(singleFetch) {
      if (!route.hasLoader) return Promise.resolve(null);
      return fetchServerHandler(singleFetch);
    }
    function fetchServerAction(singleFetch) {
      if (!route.hasAction) {
        throw noActionDefinedError("action", route.id);
      }
      return fetchServerHandler(singleFetch);
    }
    function prefetchModule(modulePath) {
      import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        modulePath
      );
    }
    function prefetchRouteModuleChunks(route2) {
      if (route2.clientActionModule) {
        prefetchModule(route2.clientActionModule);
      }
      if (route2.clientLoaderModule) {
        prefetchModule(route2.clientLoaderModule);
      }
    }
    async function prefetchStylesAndCallHandler(handler) {
      let cachedModule = routeModulesCache[route.id];
      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();
      try {
        return handler();
      } finally {
        await linkPrefetchPromise;
      }
    }
    let dataRoute = {
      id: route.id,
      index: route.index,
      path: route.path
    };
    if (routeModule) {
      Object.assign(dataRoute, {
        ...dataRoute,
        ...getRouteComponents(route, routeModule, isSpaMode),
        handle: routeModule.handle,
        shouldRevalidate: getShouldRevalidateFunction(
          routeModule,
          route,
          ssr,
          needsRevalidation
        )
      });
      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;
      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;
      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;
      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;
      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);
      dataRoute.loader = async ({ request, params }, singleFetch) => {
        try {
          let result = await prefetchStylesAndCallHandler(async () => {
            invariant2(
              routeModule,
              "No `routeModule` available for critical-route loader"
            );
            if (!routeModule.clientLoader) {
              return fetchServerLoader(singleFetch);
            }
            return routeModule.clientLoader({
              request,
              params,
              async serverLoader() {
                preventInvalidServerHandlerCall("loader", route);
                if (isHydrationRequest) {
                  if (hasInitialData) {
                    return initialData;
                  }
                  if (hasInitialError) {
                    throw initialError;
                  }
                }
                return fetchServerLoader(singleFetch);
              }
            });
          });
          return result;
        } finally {
          isHydrationRequest = false;
        }
      };
      dataRoute.loader.hydrate = shouldHydrateRouteLoader(
        route,
        routeModule,
        isSpaMode
      );
      dataRoute.action = ({ request, params }, singleFetch) => {
        return prefetchStylesAndCallHandler(async () => {
          invariant2(
            routeModule,
            "No `routeModule` available for critical-route action"
          );
          if (!routeModule.clientAction) {
            if (isSpaMode) {
              throw noActionDefinedError("clientAction", route.id);
            }
            return fetchServerAction(singleFetch);
          }
          return routeModule.clientAction({
            request,
            params,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        });
      };
    } else {
      if (!route.hasClientLoader) {
        dataRoute.loader = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {
          return fetchServerLoader(singleFetch);
        });
      } else if (route.clientLoaderModule) {
        dataRoute.loader = async (args, singleFetch) => {
          invariant2(route.clientLoaderModule);
          let { clientLoader } = await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            route.clientLoaderModule
          );
          return clientLoader({
            ...args,
            async serverLoader() {
              preventInvalidServerHandlerCall("loader", route);
              return fetchServerLoader(singleFetch);
            }
          });
        };
      }
      if (!route.hasClientAction) {
        dataRoute.action = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {
          if (isSpaMode) {
            throw noActionDefinedError("clientAction", route.id);
          }
          return fetchServerAction(singleFetch);
        });
      } else if (route.clientActionModule) {
        dataRoute.action = async (args, singleFetch) => {
          invariant2(route.clientActionModule);
          prefetchRouteModuleChunks(route);
          let { clientAction } = await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            route.clientActionModule
          );
          return clientAction({
            ...args,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        };
      }
      dataRoute.lazy = async () => {
        if (route.clientLoaderModule || route.clientActionModule) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        let modPromise = loadRouteModuleWithBlockingLinks(
          route,
          routeModulesCache
        );
        prefetchRouteModuleChunks(route);
        let mod = await modPromise;
        let lazyRoute = { ...mod };
        if (mod.clientLoader) {
          let clientLoader = mod.clientLoader;
          lazyRoute.loader = (args, singleFetch) => clientLoader({
            ...args,
            async serverLoader() {
              preventInvalidServerHandlerCall("loader", route);
              return fetchServerLoader(singleFetch);
            }
          });
        }
        if (mod.clientAction) {
          let clientAction = mod.clientAction;
          lazyRoute.action = (args, singleFetch) => clientAction({
            ...args,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        }
        return {
          ...lazyRoute.loader ? { loader: lazyRoute.loader } : {},
          ...lazyRoute.action ? { action: lazyRoute.action } : {},
          hasErrorBoundary: lazyRoute.hasErrorBoundary,
          shouldRevalidate: getShouldRevalidateFunction(
            lazyRoute,
            route,
            ssr,
            needsRevalidation
          ),
          handle: lazyRoute.handle,
          // No need to wrap these in layout since the root route is never
          // loaded via route.lazy()
          Component: lazyRoute.Component,
          ErrorBoundary: lazyRoute.ErrorBoundary
        };
      };
    }
    let children = createClientRoutes(
      manifest,
      routeModulesCache,
      initialState,
      ssr,
      isSpaMode,
      route.id,
      routesByParentId,
      needsRevalidation
    );
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function getShouldRevalidateFunction(route, manifestRoute, ssr, needsRevalidation) {
  if (needsRevalidation) {
    return wrapShouldRevalidateForHdr(
      manifestRoute.id,
      route.shouldRevalidate,
      needsRevalidation
    );
  }
  if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {
    if (route.shouldRevalidate) {
      let fn = route.shouldRevalidate;
      return (opts) => fn({ ...opts, defaultShouldRevalidate: false });
    } else {
      return () => false;
    }
  }
  if (ssr && route.shouldRevalidate) {
    let fn = route.shouldRevalidate;
    return (opts) => fn({ ...opts, defaultShouldRevalidate: true });
  }
  return route.shouldRevalidate;
}
function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {
  let handledRevalidation = false;
  return (arg) => {
    if (!handledRevalidation) {
      handledRevalidation = true;
      return needsRevalidation.has(routeId);
    }
    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;
  };
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModulePromise = loadRouteModule(route, routeModules);
  let prefetchRouteCssPromise = prefetchRouteCss(route);
  let routeModule = await routeModulePromise;
  await Promise.all([
    prefetchRouteCssPromise,
    prefetchStyleLinks(route, routeModule)
  ]);
  return {
    Component: getRouteModuleComponent(routeModule),
    ErrorBoundary: routeModule.ErrorBoundary,
    clientAction: routeModule.clientAction,
    clientLoader: routeModule.clientLoader,
    handle: routeModule.handle,
    links: routeModule.links,
    meta: routeModule.meta,
    shouldRevalidate: routeModule.shouldRevalidate
  };
}
function getRouteModuleComponent(routeModule) {
  if (routeModule.default == null) return void 0;
  let isEmptyObject = typeof routeModule.default === "object" && Object.keys(routeModule.default).length === 0;
  if (!isEmptyObject) {
    return routeModule.default;
  }
}
function shouldHydrateRouteLoader(route, routeModule, isSpaMode) {
  return isSpaMode && route.id !== "root" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);
}

// lib/dom/ssr/fog-of-war.ts
var nextPaths = /* @__PURE__ */ new Set();
var discoveredPathsMaxSize = 1e3;
var discoveredPaths = /* @__PURE__ */ new Set();
var URL_LIMIT = 7680;
function isFogOfWarEnabled(ssr) {
  return ssr === true;
}
function getPartialManifest(manifest, router) {
  let routeIds = new Set(router.state.matches.map((m) => m.route.id));
  let segments = router.state.location.pathname.split("/").filter(Boolean);
  let paths = ["/"];
  segments.pop();
  while (segments.length > 0) {
    paths.push(`/${segments.join("/")}`);
    segments.pop();
  }
  paths.forEach((path) => {
    let matches = matchRoutes(router.routes, path, router.basename);
    if (matches) {
      matches.forEach((m) => routeIds.add(m.route.id));
    }
  });
  let initialRoutes = [...routeIds].reduce(
    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),
    {}
  );
  return {
    ...manifest,
    routes: initialRoutes
  };
}
function getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, isSpaMode, basename) {
  if (!isFogOfWarEnabled(ssr)) {
    return void 0;
  }
  return async ({ path, patch, signal }) => {
    if (discoveredPaths.has(path)) {
      return;
    }
    await fetchAndApplyManifestPatches(
      [path],
      manifest,
      routeModules,
      ssr,
      isSpaMode,
      basename,
      patch,
      signal
    );
  };
}
function useFogOFWarDiscovery(router, manifest, routeModules, ssr, isSpaMode) {
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isFogOfWarEnabled(ssr) || navigator.connection?.saveData === true) {
      return;
    }
    function registerElement(el) {
      let path = el.tagName === "FORM" ? el.getAttribute("action") : el.getAttribute("href");
      if (!path) {
        return;
      }
      let pathname = el.tagName === "A" ? el.pathname : new URL(path, window.location.origin).pathname;
      if (!discoveredPaths.has(pathname)) {
        nextPaths.add(pathname);
      }
    }
    async function fetchPatches() {
      document.querySelectorAll("a[data-discover], form[data-discover]").forEach(registerElement);
      let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {
        if (discoveredPaths.has(path)) {
          nextPaths.delete(path);
          return false;
        }
        return true;
      });
      if (lazyPaths.length === 0) {
        return;
      }
      try {
        await fetchAndApplyManifestPatches(
          lazyPaths,
          manifest,
          routeModules,
          ssr,
          isSpaMode,
          router.basename,
          router.patchRoutes
        );
      } catch (e) {
        console.error("Failed to fetch manifest patches", e);
      }
    }
    let debouncedFetchPatches = debounce(fetchPatches, 100);
    fetchPatches();
    let observer = new MutationObserver(() => debouncedFetchPatches());
    observer.observe(document.documentElement, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["data-discover", "href", "action"]
    });
    return () => observer.disconnect();
  }, [ssr, isSpaMode, manifest, routeModules, router]);
}
async function fetchAndApplyManifestPatches(paths, manifest, routeModules, ssr, isSpaMode, basename, patchRoutes, signal) {
  let manifestPath = `${basename != null ? basename : "/"}/__manifest`.replace(
    /\/+/g,
    "/"
  );
  let url = new URL(manifestPath, window.location.origin);
  paths.sort().forEach((path) => url.searchParams.append("p", path));
  url.searchParams.set("version", manifest.version);
  if (url.toString().length > URL_LIMIT) {
    nextPaths.clear();
    return;
  }
  let serverPatches;
  try {
    let res = await fetch(url, { signal });
    if (!res.ok) {
      throw new Error(`${res.status} ${res.statusText}`);
    } else if (res.status >= 400) {
      throw new Error(await res.text());
    }
    serverPatches = await res.json();
  } catch (e) {
    if (signal?.aborted) return;
    throw e;
  }
  let knownRoutes = new Set(Object.keys(manifest.routes));
  let patches = Object.values(serverPatches).reduce((acc, route) => {
    if (route && !knownRoutes.has(route.id)) {
      acc[route.id] = route;
    }
    return acc;
  }, {});
  Object.assign(manifest.routes, patches);
  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));
  let parentIds = /* @__PURE__ */ new Set();
  Object.values(patches).forEach((patch) => {
    if (patch && (!patch.parentId || !patches[patch.parentId])) {
      parentIds.add(patch.parentId);
    }
  });
  parentIds.forEach(
    (parentId) => patchRoutes(
      parentId || null,
      createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)
    )
  );
}
function addToFifoQueue(path, queue) {
  if (queue.size >= discoveredPathsMaxSize) {
    let first = queue.values().next().value;
    queue.delete(first);
  }
  queue.add(path);
}
function debounce(callback, wait) {
  let timeoutId;
  return (...args) => {
    window.clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => callback(...args), wait);
  };
}

// lib/dom/ssr/components.tsx
function useDataRouterContext2() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function getActiveMatches(matches, errors, isSpaMode) {
  if (isSpaMode && !isHydrated) {
    return [matches[0]];
  }
  if (errors) {
    let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);
    return matches.slice(0, errorIdx + 1);
  }
  return matches;
}
function Links() {
  let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();
  let { errors, matches: routerMatches } = useDataRouterStateContext();
  let matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let keyedLinks = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getKeyedLinksForMatches(matches, routeModules, manifest),
    [matches, routeModules, manifest]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, criticalCss ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("style", { dangerouslySetInnerHTML: { __html: criticalCss } }) : null, keyedLinks.map(
    ({ key, link }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { key, ...link }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key, ...link })
  ));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let { router } = useDataRouterContext2();
  let matches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dataHrefs.map((href2) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key, ...link })
  )));
}
function Meta() {
  let { isSpaMode, routeModules } = useFrameworkContext();
  let {
    errors,
    matches: routerMatches,
    loaderData
  } = useDataRouterStateContext();
  let location = useLocation();
  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let error = null;
  if (errors) {
    error = errors[_matches[_matches.length - 1].route.id];
  }
  let meta = [];
  let leafMeta = null;
  let matches = [];
  for (let i = 0; i < _matches.length; i++) {
    let _match = _matches[i];
    let routeId = _match.route.id;
    let data2 = loaderData[routeId];
    let params = _match.params;
    let routeModule = routeModules[routeId];
    let routeMeta = [];
    let match = {
      id: routeId,
      data: data2,
      meta: [],
      params: _match.params,
      pathname: _match.pathname,
      handle: _match.route.handle,
      error
    };
    matches[i] = match;
    if (routeModule?.meta) {
      routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data: data2,
        params,
        location,
        matches,
        error
      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;
    } else if (leafMeta) {
      routeMeta = [...leafMeta];
    }
    routeMeta = routeMeta || [];
    if (!Array.isArray(routeMeta)) {
      throw new Error(
        "The route at " + _match.route.path + " returns an invalid value. All route meta functions must return an array of meta objects.\n\nTo reference the meta function API, see https://remix.run/route/meta"
      );
    }
    match.meta = routeMeta;
    matches[i] = match;
    meta = [...routeMeta];
    leafMeta = meta;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, meta.flat().map((metaProps) => {
    if (!metaProps) {
      return null;
    }
    if ("tagName" in metaProps) {
      let { tagName, ...rest } = metaProps;
      if (!isValidMetaTag(tagName)) {
        console.warn(
          `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`
        );
        return null;
      }
      let Comp = tagName;
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, { key: JSON.stringify(rest), ...rest });
    }
    if ("title" in metaProps) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", { key: "title" }, String(metaProps.title));
    }
    if ("charset" in metaProps) {
      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);
      delete metaProps.charset;
    }
    if ("charSet" in metaProps && metaProps.charSet != null) {
      return typeof metaProps.charSet === "string" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { key: "charSet", charSet: metaProps.charSet }) : null;
    }
    if ("script:ld+json" in metaProps) {
      try {
        let json = JSON.stringify(metaProps["script:ld+json"]);
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          "script",
          {
            key: `script:ld+json:${json}`,
            type: "application/ld+json",
            dangerouslySetInnerHTML: { __html: json }
          }
        );
      } catch (err) {
        return null;
      }
    }
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { key: JSON.stringify(metaProps), ...metaProps });
  }));
}
function isValidMetaTag(tagName) {
  return typeof tagName === "string" && /^(meta|link)$/.test(tagName);
}
var isHydrated = false;
function Scripts(props) {
  let { manifest, serverHandoffString, isSpaMode, ssr, renderMeta } = useFrameworkContext();
  let { router, static: isStatic, staticContext } = useDataRouterContext2();
  let { matches: routerMatches } = useDataRouterStateContext();
  let enableFogOfWar = isFogOfWarEnabled(ssr);
  if (renderMeta) {
    renderMeta.didRenderScripts = true;
  }
  let matches = getActiveMatches(routerMatches, null, isSpaMode);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
    let routeModulesScript = !isStatic ? " " : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};
${matches.map((match, routeIndex) => {
      let routeVarName = `route${routeIndex}`;
      let manifestEntry = manifest.routes[match.route.id];
      invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);
      let {
        clientActionModule,
        clientLoaderModule,
        hydrateFallbackModule,
        module
      } = manifestEntry;
      let chunks = [
        ...clientActionModule ? [
          {
            module: clientActionModule,
            varName: `${routeVarName}_clientAction`
          }
        ] : [],
        ...clientLoaderModule ? [
          {
            module: clientLoaderModule,
            varName: `${routeVarName}_clientLoader`
          }
        ] : [],
        ...hydrateFallbackModule ? [
          {
            module: hydrateFallbackModule,
            varName: `${routeVarName}_HydrateFallback`
          }
        ] : [],
        { module, varName: `${routeVarName}_main` }
      ];
      if (chunks.length === 1) {
        return `import * as ${routeVarName} from ${JSON.stringify(module)};`;
      }
      let chunkImportsSnippet = chunks.map((chunk) => `import * as ${chunk.varName} from "${chunk.module}";`).join("\n");
      let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) => `...${chunk.varName}`).join(",")}};`;
      return [chunkImportsSnippet, mergedChunksSnippet].join("\n");
    }).join("\n")}
  ${enableFogOfWar ? (
      // Inline a minimal manifest with the SSR matches
      `window.__reactRouterManifest = ${JSON.stringify(
        getPartialManifest(manifest, router),
        null,
        2
      )};`
    ) : ""}
  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: createHtml(contextScript),
        type: void 0
      }
    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: createHtml(routeModulesScript),
        type: "module",
        async: true
      }
    ));
  }, []);
  let preloads = isHydrated ? [] : manifest.entry.imports.concat(
    getModuleLinkHrefs(matches, manifest, {
      includeHydrateFallback: true
    })
  );
  return isHydrated ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !enableFogOfWar ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.url,
      crossOrigin: props.crossOrigin
    }
  ) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.entry.module,
      crossOrigin: props.crossOrigin
    }
  ), dedupe(preloads).map((path) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      key: path,
      rel: "modulepreload",
      href: path,
      crossOrigin: props.crossOrigin
    }
  )), initialScripts);
}
function dedupe(array) {
  return [...new Set(array)];
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

// lib/dom/lib.tsx
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = "7.2.0";
  }
} catch (e) {
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createBrowserHistory({ window: opts?.window }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createHashHistory({ window: opts?.window }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function parseHydrationData() {
  let state = window?.__staticRouterHydrationData;
  if (state && state.errors) {
    state = {
      ...state,
      errors: deserializeErrors(state.errors)
    };
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(
        val.status,
        val.statusText,
        val.data,
        val.internal === true
      );
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function HashRouter({ basename, children, window: window2 }) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function HistoryRouter({
  basename,
  children,
  history
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
HistoryRouter.displayName = "unstable_HistoryRouter";
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  }, forwardedRef) {
    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href2 = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: absoluteHref || href2,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, link, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { page: href2 })) : link;
  }
);
Link.displayName = "Link";
var NavLink = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    ...props
  }, forwardedRef) => {
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form.displayName = "Form";
function ScrollRestoration({
  getKey,
  storageKey,
  ...props
}) {
  let remixContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  useScrollRestoration({ getKey, storageKey });
  let ssrKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => {
      if (!remixContext || !getKey) return null;
      let userKey = getScrollRestorationKey(
        location,
        matches,
        basename,
        getKey
      );
      return userKey !== location.key ? userKey : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (!remixContext || remixContext.isSpaMode) {
    return null;
  }
  let restoreScroll = ((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  }).toString();
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      ...props,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: `(${restoreScroll})(${JSON.stringify(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY
        )}, ${JSON.stringify(ssrKey)})`
      }
    }
  );
}
ScrollRestoration.displayName = "ScrollRestoration";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError2(hookName));
  return state;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
function useSearchParams(defaultInit) {
  warning(
    typeof URLSearchParams !== "undefined",
    `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`
  );
  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  let location = useLocation();
  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      getSearchParamsForLocation(
        location.search,
        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current
      )
    ),
    [location.search]
  );
  let navigate = useNavigate();
  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (nextInit, navigateOptions) => {
      const newSearchParams = createSearchParams(
        typeof nextInit === "function" ? nextInit(searchParams) : nextInit
      );
      hasSetSearchParamsRef.current = true;
      navigate("?" + newSearchParams, navigateOptions);
    },
    [navigate, searchParams]
  );
  return [searchParams, setSearchParams];
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3("useSubmit" /* UseSubmit */);
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useFetcher({
  key
} = {}) {
  let { router } = useDataRouterContext3("useFetcher" /* UseFetcher */);
  let state = useDataRouterState2("useFetcher" /* UseFetcher */);
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeId = route.matches[route.matches.length - 1]?.route.id;
  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);
  invariant(route, `useFetcher must be used inside a RouteContext`);
  invariant(
    routeId != null,
    `useFetcher can only be used on routes that contain a unique "id"`
  );
  let defaultKey = react__WEBPACK_IMPORTED_MODULE_0__.useId();
  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);
  if (key && key !== fetcherKey) {
    setFetcherKey(key);
  }
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    router.getFetcher(fetcherKey);
    return () => router.deleteFetcher(fetcherKey);
  }, [router, fetcherKey]);
  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (href2, opts) => {
      invariant(routeId, "No routeId available for fetcher.load()");
      await router.fetch(fetcherKey, routeId, href2, opts);
    },
    [fetcherKey, routeId, router]
  );
  let submitImpl = useSubmit();
  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (target, opts) => {
      await submitImpl(target, {
        ...opts,
        navigate: false,
        fetcherKey
      });
    },
    [fetcherKey, submitImpl]
  );
  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let FetcherForm2 = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
      (props, ref) => {
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, { ...props, navigate: false, fetcherKey, ref });
      }
    );
    FetcherForm2.displayName = "fetcher.Form";
    return FetcherForm2;
  }, [fetcherKey]);
  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
  let data2 = fetcherData.get(fetcherKey);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      Form: FetcherForm,
      submit,
      load,
      ...fetcher,
      data: data2
    }),
    [FetcherForm, submit, load, fetcher, data2]
  );
  return fetcherWithComponents;
}
function useFetchers() {
  let state = useDataRouterState2("useFetchers" /* UseFetchers */);
  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({
    ...fetcher,
    key
  }));
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function getScrollRestorationKey(location, matches, basename, getKey) {
  let key = null;
  if (getKey) {
    if (basename !== "/") {
      key = getKey(
        {
          ...location,
          pathname: stripBasename(location.pathname, basename) || location.pathname
        },
        matches
      );
    } else {
      key = getKey(location, matches);
    }
  }
  if (key == null) {
    key = location.key;
  }
  return key;
}
function useScrollRestoration({
  getKey,
  storageKey
} = {}) {
  let { router } = useDataRouterContext3("useScrollRestoration" /* UseScrollRestoration */);
  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
    "useScrollRestoration" /* UseScrollRestoration */
  );
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(
    react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
      if (navigation.state === "idle") {
        let key = getScrollRestorationKey(location, matches, basename, getKey);
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY,
          JSON.stringify(savedScrollPositions)
        );
      } catch (error) {
        warning(
          false,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
        );
      }
      window.history.scrollRestoration = "auto";
    }, [navigation.state, getKey, basename, location, matches, storageKey])
  );
  if (typeof document !== "undefined") {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY
        );
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {
      }
    }, [storageKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      let disableScrollRestoration = router?.enableScrollRestoration(
        savedScrollPositions,
        () => window.scrollY,
        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0
      );
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(
          decodeURIComponent(location.hash.slice(1))
        );
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function useBeforeUnload(callback, options) {
  let { capture } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? { capture } : void 0;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
function usePageHide(callback, options) {
  let { capture } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? { capture } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function usePrompt({
  when,
  message
}) {
  let blocker = useBlocker(when);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState" /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative: opts.relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// lib/dom/server.tsx

function StaticRouter({
  basename,
  children,
  location: locationProp = "/"
}) {
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let action = "POP" /* Pop */;
  let location = {
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state != null ? locationProp.state : null,
    key: locationProp.key || "default"
  };
  let staticNavigator = getStatelessNavigator();
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location,
      navigationType: action,
      navigator: staticNavigator,
      static: true
    }
  );
}
function StaticRouterProvider({
  context,
  router,
  hydrate = true,
  nonce
}) {
  invariant(
    router && context,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let dataRouterContext = {
    router,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
  };
  let fetchersContext = /* @__PURE__ */ new Map();
  let hydrateScript = "";
  if (hydrate !== false) {
    let data2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
    };
    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
  }
  let { state } = dataRouterContext.router;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename: dataRouterContext.basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: dataRouterContext.navigator,
      static: dataRouterContext.static
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      DataRoutes2,
      {
        routes: router.routes,
        future: router.future,
        state
      }
    )
  ))))), hydrateScript ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      suppressHydrationWarning: true,
      nonce,
      dangerouslySetInnerHTML: { __html: hydrateScript }
    }
  ) : null);
}
function DataRoutes2({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function serializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = { ...val, __type: "RouteErrorResponse" };
    } else if (val instanceof Error) {
      serialized[key] = {
        message: val.message,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.
        ...val.name !== "Error" ? {
          __subType: val.name
        } : {}
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function getStatelessNavigator() {
  return {
    createHref,
    encodeLocation,
    push(to) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`
      );
    },
    replace(to) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(delta) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        `You cannot use navigator.back() on the server because it is a stateless environment.`
      );
    },
    forward() {
      throw new Error(
        `You cannot use navigator.forward() on the server because it is a stateless environment.`
      );
    }
  };
}
function createStaticHandler2(routes, opts) {
  return createStaticHandler(routes, {
    ...opts,
    mapRouteProperties
  });
}
function createStaticRouter(routes, context, opts = {}) {
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(
    routes,
    mapRouteProperties,
    void 0,
    manifest
  );
  let matches = context.matches.map((match) => {
    let route = manifest[match.route.id] || match.route;
    return {
      ...match,
      route
    };
  });
  let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return context.basename;
    },
    get future() {
      return {
        ...opts?.future
      };
    },
    get state() {
      return {
        historyAction: "POP" /* Pop */,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return void 0;
    },
    initialize() {
      throw msg("initialize");
    },
    subscribe() {
      throw msg("subscribe");
    },
    enableScrollRestoration() {
      throw msg("enableScrollRestoration");
    },
    navigate() {
      throw msg("navigate");
    },
    fetch() {
      throw msg("fetch");
    },
    revalidate() {
      throw msg("revalidate");
    },
    createHref,
    encodeLocation,
    getFetcher() {
      return IDLE_FETCHER;
    },
    deleteFetcher() {
      throw msg("deleteFetcher");
    },
    dispose() {
      throw msg("dispose");
    },
    getBlocker() {
      return IDLE_BLOCKER;
    },
    deleteBlocker() {
      throw msg("deleteBlocker");
    },
    patchRoutes() {
      throw msg("patchRoutes");
    },
    _internalFetchControllers: /* @__PURE__ */ new Map(),
    _internalSetRoutes() {
      throw msg("_internalSetRoutes");
    }
  };
}
function createHref(to) {
  return typeof to === "string" ? to : createPath(to);
}
function encodeLocation(to) {
  let href2 = typeof to === "string" ? to : createPath(to);
  href2 = href2.replace(/ $/, "%20");
  let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, "http://localhost");
  return {
    pathname: encoded.pathname,
    search: encoded.search,
    hash: encoded.hash
  };
}
var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var ESCAPE_LOOKUP2 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
function htmlEscape(str) {
  return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);
}

// lib/dom/ssr/server.tsx

function ServerRouter({
  context,
  url,
  nonce
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let { manifest, routeModules, criticalCss, serverHandoffString } = context;
  let routes = createServerRoutes(
    manifest.routes,
    routeModules,
    context.future,
    context.isSpaMode
  );
  context.staticHandlerContext.loaderData = {
    ...context.staticHandlerContext.loaderData
  };
  for (let match of context.staticHandlerContext.matches) {
    let routeId = match.route.id;
    let route = routeModules[routeId];
    let manifestRoute = context.manifest.routes[routeId];
    if (route && manifestRoute && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {
      delete context.staticHandlerContext.loaderData[routeId];
    }
  }
  let router = createStaticRouter(routes, context.staticHandlerContext);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    FrameworkContext.Provider,
    {
      value: {
        manifest,
        routeModules,
        criticalCss,
        serverHandoffString,
        future: context.future,
        ssr: context.ssr,
        isSpaMode: context.isSpaMode,
        serializeError: context.serializeError,
        renderMeta: context.renderMeta
      }
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      StaticRouterProvider,
      {
        router,
        context: context.staticHandlerContext,
        hydrate: false
      }
    ))
  ), context.serverHandoffStream ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    StreamTransfer,
    {
      context,
      identifier: 0,
      reader: context.serverHandoffStream.getReader(),
      textDecoder: new TextDecoder(),
      nonce
    }
  )) : null);
}

// lib/dom/ssr/routes-test-stub.tsx

function createRoutesStub(routes, context = {}) {
  return function RoutesTestStub({
    initialEntries,
    initialIndex,
    hydrationData,
    future
  }) {
    let routerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    let remixContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    if (routerRef.current == null) {
      remixContextRef.current = {
        future: {},
        manifest: {
          routes: {},
          entry: { imports: [], module: "" },
          url: "",
          version: ""
        },
        routeModules: {},
        ssr: false,
        isSpaMode: false
      };
      let patched = processRoutes(
        // @ts-expect-error loader/action context types don't match :/
        convertRoutesToDataRoutes(routes, (r) => r),
        context,
        remixContextRef.current.manifest,
        remixContextRef.current.routeModules
      );
      routerRef.current = createMemoryRouter(patched, {
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameworkContext.Provider, { value: remixContextRef.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouterProvider, { router: routerRef.current }));
  };
}
function processRoutes(routes, context, manifest, routeModules, parentId) {
  return routes.map((route) => {
    if (!route.id) {
      throw new Error(
        "Expected a route.id in @remix-run/testing processRoutes() function"
      );
    }
    let { loader, action } = route;
    let newRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      Component: route.Component,
      HydrateFallback: route.HydrateFallback,
      ErrorBoundary: route.ErrorBoundary,
      action: action ? (args) => action({ ...args, context }) : void 0,
      loader: loader ? (args) => loader({ ...args, context }) : void 0,
      handle: route.handle,
      shouldRevalidate: route.shouldRevalidate
    };
    let entryRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      parentId,
      hasAction: route.action != null,
      hasLoader: route.loader != null,
      // When testing routes, you should just be stubbing loader/action, not
      // trying to re-implement the full loader/clientLoader/SSR/hydration flow.
      // That is better tested via E2E tests.
      hasClientAction: false,
      hasClientLoader: false,
      hasErrorBoundary: route.ErrorBoundary != null,
      // any need for these?
      module: "build/stub-path-to-module.js",
      clientActionModule: void 0,
      clientLoaderModule: void 0,
      hydrateFallbackModule: void 0
    };
    manifest.routes[newRoute.id] = entryRoute;
    routeModules[route.id] = {
      default: route.Component || Outlet,
      ErrorBoundary: route.ErrorBoundary || void 0,
      handle: route.handle,
      links: route.links,
      meta: route.meta,
      shouldRevalidate: route.shouldRevalidate
    };
    if (route.children) {
      newRoute.children = processRoutes(
        route.children,
        context,
        manifest,
        routeModules,
        newRoute.id
      );
    }
    return newRoute;
  });
}

// lib/server-runtime/cookies.ts


// lib/server-runtime/crypto.ts
var encoder = new TextEncoder();
var sign = async (value, secret) => {
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["sign"]);
  let signature = await crypto.subtle.sign("HMAC", key, data2);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(
    /=+$/,
    ""
  );
  return value + "." + hash;
};
var unsign = async (cookie, secret) => {
  let index = cookie.lastIndexOf(".");
  let value = cookie.slice(0, index);
  let hash = cookie.slice(index + 1);
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["verify"]);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data2);
  return valid ? value : false;
};
var createKey2 = async (secret, usages) => crypto.subtle.importKey(
  "raw",
  encoder.encode(secret),
  { name: "HMAC", hash: "SHA-256" },
  false,
  usages
);
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// lib/server-runtime/cookies.ts
var createCookie = (name, cookieOptions = {}) => {
  let { secrets = [], ...options } = {
    path: "/",
    sameSite: "lax",
    ...cookieOptions
  };
  warnOnceAboutExpiresCookie(name, options.expires);
  return {
    get name() {
      return name;
    },
    get isSigned() {
      return secrets.length > 0;
    },
    get expires() {
      return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
    },
    async parse(cookieHeader, parseOptions) {
      if (!cookieHeader) return null;
      let cookies = (0,cookie__WEBPACK_IMPORTED_MODULE_2__.parse)(cookieHeader, { ...options, ...parseOptions });
      if (name in cookies) {
        let value = cookies[name];
        if (typeof value === "string" && value !== "") {
          let decoded = await decodeCookieValue(value, secrets);
          return decoded;
        } else {
          return "";
        }
      } else {
        return null;
      }
    },
    async serialize(value, serializeOptions) {
      return (0,cookie__WEBPACK_IMPORTED_MODULE_2__.serialize)(
        name,
        value === "" ? "" : await encodeCookieValue(value, secrets),
        {
          ...options,
          ...serializeOptions
        }
      );
    }
  };
};
var isCookie = (object) => {
  return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
};
async function encodeCookieValue(value, secrets) {
  let encoded = encodeData(value);
  if (secrets.length > 0) {
    encoded = await sign(encoded, secrets[0]);
  }
  return encoded;
}
async function decodeCookieValue(value, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value, secret);
      if (unsignedValue !== false) {
        return decodeData(unsignedValue);
      }
    }
    return null;
  }
  return decodeData(value);
}
function encodeData(value) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
}
function decodeData(value) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value))));
  } catch (error) {
    return {};
  }
}
function myEscape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, code;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (/[\w*+\-./@]/.exec(chr)) {
      result += chr;
    } else {
      code = chr.charCodeAt(0);
      if (code < 256) {
        result += "%" + hex(code, 2);
      } else {
        result += "%u" + hex(code, 4).toUpperCase();
      }
    }
  }
  return result;
}
function hex(code, length) {
  let result = code.toString(16);
  while (result.length < length) result = "0" + result;
  return result;
}
function myUnescape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, part;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (chr === "%") {
      if (str.charAt(index) === "u") {
        part = str.slice(index + 1, index + 5);
        if (/^[\da-f]{4}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 5;
          continue;
        }
      } else {
        part = str.slice(index, index + 2);
        if (/^[\da-f]{2}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 2;
          continue;
        }
      }
    }
    result += chr;
  }
  return result;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(
    !expires,
    `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`
  );
}

// lib/server-runtime/entry.ts
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo2, routeId) => {
    let route = manifest[routeId];
    if (route) {
      memo2[routeId] = route.module;
    }
    return memo2;
  }, {});
}

// lib/server-runtime/mode.ts
var ServerMode = /* @__PURE__ */ ((ServerMode2) => {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
  return ServerMode2;
})(ServerMode || {});
function isServerMode(value) {
  return value === "development" /* Development */ || value === "production" /* Production */ || value === "test" /* Test */;
}

// lib/server-runtime/errors.ts
function sanitizeError(error, serverMode) {
  if (error instanceof Error && serverMode !== "development" /* Development */) {
    let sanitized = new Error("Unexpected Server Error");
    sanitized.stack = void 0;
    return sanitized;
  }
  return error;
}
function sanitizeErrors(errors, serverMode) {
  return Object.entries(errors).reduce((acc, [routeId, error]) => {
    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });
  }, {});
}
function serializeError(error, serverMode) {
  let sanitized = sanitizeError(error, serverMode);
  return {
    message: sanitized.message,
    stack: sanitized.stack
  };
}
function serializeErrors2(errors, serverMode) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = { ...val, __type: "RouteErrorResponse" };
    } else if (val instanceof Error) {
      let sanitized = sanitizeError(val, serverMode);
      serialized[key] = {
        message: sanitized.message,
        stack: sanitized.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...sanitized.name !== "Error" ? {
          __subType: sanitized.name
        } : {}
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}

// lib/server-runtime/routeMatching.ts
function matchServerRoutes(routes, pathname, basename) {
  let matches = matchRoutes(
    routes,
    pathname,
    basename
  );
  if (!matches) return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// lib/server-runtime/data.ts
async function callRouteHandler(handler, args) {
  let result = await handler({
    request: stripRoutesParam(stripIndexParam2(args.request)),
    params: args.params,
    context: args.context
  });
  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {
    throw new Response(null, result.init);
  }
  return result;
}
function stripIndexParam2(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}
function stripRoutesParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_routes");
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}

// lib/server-runtime/invariant.ts
function invariant3(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}

// lib/server-runtime/routes.ts
function groupRoutesByParentId2(manifest) {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
}
function createStaticHandlerDataRoutes(manifest, future, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let commonRoute = {
      // Always include root due to default boundaries
      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      // Need to use RR's version in the param typed here to permit the optional
      // context even though we know it'll always be provided in remix
      loader: route.module.loader ? async (args) => {
        if (args.request.headers.has("X-React-Router-Prerender-Data")) {
          const preRenderedData = args.request.headers.get(
            "X-React-Router-Prerender-Data"
          );
          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;
          invariant3(encoded, "Missing prerendered data for route");
          let uint8array = new TextEncoder().encode(encoded);
          let stream = new ReadableStream({
            start(controller) {
              controller.enqueue(uint8array);
              controller.close();
            }
          });
          let decoded = await decodeViaTurboStream(stream, global);
          let data2 = decoded.value;
          invariant3(
            data2 && route.id in data2,
            "Unable to decode prerendered data"
          );
          let result = data2[route.id];
          invariant3("data" in result, "Unable to process prerendered data");
          return result.data;
        }
        let val = await callRouteHandler(route.module.loader, args);
        return val;
      } : void 0,
      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: true,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createStaticHandlerDataRoutes(
        manifest,
        future,
        route.id,
        routesByParentId
      ),
      ...commonRoute
    };
  });
}

// lib/server-runtime/markup.ts
var ESCAPE_LOOKUP3 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
function escapeHtml2(html) {
  return html.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
}

// lib/server-runtime/serverHandoff.ts
function createServerHandoffString(serverHandoff) {
  return escapeHtml2(JSON.stringify(serverHandoff));
}

// lib/server-runtime/dev.ts
var globalDevServerHooksKey = "__reactRouterDevServerHooks";
function setDevServerHooks(devServerHooks) {
  globalThis[globalDevServerHooksKey] = devServerHooks;
}
function getDevServerHooks() {
  return globalThis[globalDevServerHooksKey];
}

// lib/server-runtime/single-fetch.ts


// lib/server-runtime/headers.ts

function getDocumentHeaders(build, context) {
  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;
  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;
  let errorHeaders;
  if (boundaryIdx >= 0) {
    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;
    context.matches.slice(boundaryIdx).some((match) => {
      let id = match.route.id;
      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {
        errorHeaders = actionHeaders[id];
      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {
        errorHeaders = loaderHeaders[id];
      }
      return errorHeaders != null;
    });
  }
  return matches.reduce((parentHeaders, match, idx) => {
    let { id } = match.route;
    let route = build.routes[id];
    invariant3(route, `Route with id "${id}" not found in build`);
    let routeModule = route.module;
    let loaderHeaders = context.loaderHeaders[id] || new Headers();
    let actionHeaders = context.actionHeaders[id] || new Headers();
    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;
    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
    if (routeModule.headers == null) {
      let headers2 = new Headers(parentHeaders);
      if (includeErrorCookies) {
        prependCookies(errorHeaders, headers2);
      }
      prependCookies(actionHeaders, headers2);
      prependCookies(loaderHeaders, headers2);
      return headers2;
    }
    let headers = new Headers(
      routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
        loaderHeaders,
        parentHeaders,
        actionHeaders,
        errorHeaders: includeErrorHeaders ? errorHeaders : void 0
      }) : routeModule.headers : void 0
    );
    if (includeErrorCookies) {
      prependCookies(errorHeaders, headers);
    }
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString)(parentSetCookieString);
    let childCookies = new Set(childHeaders.getSetCookie());
    cookies.forEach((cookie) => {
      if (!childCookies.has(cookie)) {
        childHeaders.append("Set-Cookie", cookie);
      }
    });
  }
}

// lib/server-runtime/single-fetch.ts
var SINGLE_FETCH_REDIRECT_STATUS = 202;
function getSingleFetchDataStrategy2({
  isActionDataRequest,
  loadRouteIds
} = {}) {
  return async ({ request, matches }) => {
    if (isActionDataRequest && request.method === "GET") {
      return {};
    }
    let matchesToLoad = loadRouteIds ? matches.filter((m) => loadRouteIds.includes(m.route.id)) : matches;
    let results = await Promise.all(
      matchesToLoad.map((match) => match.resolve())
    );
    return results.reduce(
      (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),
      {}
    );
  };
}
async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let handlerRequest = new Request(handlerUrl, {
      method: request.method,
      body: request.body,
      headers: request.headers,
      signal: request.signal,
      ...request.body ? { duplex: "half" } : void 0
    });
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: true,
      dataStrategy: getSingleFetchDataStrategy2({
        isActionDataRequest: true
      })
    });
    if (isResponse(result)) {
      return {
        result: getSingleFetchRedirect(
          result.status,
          result.headers,
          build.basename
        ),
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    let context = result;
    let headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
      return {
        result: getSingleFetchRedirect(
          context.statusCode,
          headers,
          build.basename
        ),
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    if (context.errors) {
      Object.values(context.errors).forEach((err) => {
        if (!isRouteErrorResponse(err) || err.error) {
          handleError(err);
        }
      });
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let singleFetchResult;
    if (context.errors) {
      singleFetchResult = { error: Object.values(context.errors)[0] };
    } else {
      singleFetchResult = { data: Object.values(context.actionData || {})[0] };
    }
    return {
      result: singleFetchResult,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    handleError(error);
    return {
      result: { error },
      headers: new Headers(),
      status: 500
    };
  }
}
async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let handlerRequest = new Request(handlerUrl, {
      headers: request.headers,
      signal: request.signal
    });
    let loadRouteIds = new URL(request.url).searchParams.get("_routes")?.split(",") || void 0;
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: true,
      dataStrategy: getSingleFetchDataStrategy2({
        loadRouteIds
      })
    });
    if (isResponse(result)) {
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
            result.status,
            result.headers,
            build.basename
          )
        },
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    let context = result;
    let headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
            context.statusCode,
            headers,
            build.basename
          )
        },
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    if (context.errors) {
      Object.values(context.errors).forEach((err) => {
        if (!isRouteErrorResponse(err) || err.error) {
          handleError(err);
        }
      });
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let results = {};
    let loadedMatches = loadRouteIds ? context.matches.filter(
      (m) => m.route.loader && loadRouteIds.includes(m.route.id)
    ) : context.matches;
    loadedMatches.forEach((m) => {
      let { id } = m.route;
      if (context.errors && context.errors.hasOwnProperty(id)) {
        results[id] = { error: context.errors[id] };
      } else if (context.loaderData.hasOwnProperty(id)) {
        results[id] = { data: context.loaderData[id] };
      }
    });
    return {
      result: results,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    handleError(error);
    return {
      result: { root: { error } },
      headers: new Headers(),
      status: 500
    };
  }
}
function getSingleFetchRedirect(status, headers, basename) {
  let redirect2 = headers.get("Location");
  if (basename) {
    redirect2 = stripBasename(redirect2, basename) || redirect2;
  }
  return {
    redirect: redirect2,
    status,
    revalidate: (
      // Technically X-Remix-Revalidate isn't needed here - that was an implementation
      // detail of ?_data requests as our way to tell the front end to revalidate when
      // we didn't have a response body to include that information in.
      // With single fetch, we tell the front end via this revalidate boolean field.
      // However, we're respecting it for now because it may be something folks have
      // used in their own responses
      // TODO(v3): Consider removing or making this official public API
      headers.has("X-Remix-Revalidate") || headers.has("Set-Cookie")
    ),
    reload: headers.has("X-Remix-Reload-Document"),
    replace: headers.has("X-Remix-Replace")
  };
}
function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {
  let controller = new AbortController();
  let timeoutId = setTimeout(
    () => controller.abort(new Error("Server Timeout")),
    typeof streamTimeout === "number" ? streamTimeout : 4950
  );
  requestSignal.addEventListener("abort", () => clearTimeout(timeoutId));
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.encode)(data2, {
    signal: controller.signal,
    plugins: [
      (value) => {
        if (value instanceof Error) {
          let { name, message, stack } = serverMode === "production" /* Production */ ? sanitizeError(value, serverMode) : value;
          return ["SanitizedError", name, message, stack];
        }
        if (value instanceof ErrorResponseImpl) {
          let { data: data3, status, statusText } = value;
          return ["ErrorResponse", data3, status, statusText];
        }
        if (value && typeof value === "object" && SingleFetchRedirectSymbol in value) {
          return ["SingleFetchRedirect", value[SingleFetchRedirectSymbol]];
        }
      }
    ],
    postPlugins: [
      (value) => {
        if (!value) return;
        if (typeof value !== "object") return;
        return [
          "SingleFetchClassInstance",
          Object.fromEntries(Object.entries(value))
        ];
      },
      () => ["SingleFetchFallback"]
    ]
  });
}

// lib/server-runtime/server.ts
var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205, 304]);
function derive(build, mode) {
  let routes = createRoutes(build.routes);
  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);
  let serverMode = isServerMode(mode) ? mode : "production" /* Production */;
  let staticHandler = createStaticHandler(dataRoutes, {
    basename: build.basename
  });
  let errorHandler = build.entry.module.handleError || ((error, { request }) => {
    if (serverMode !== "test" /* Test */ && !request.signal.aborted) {
      console.error(
        // @ts-expect-error This is "private" from users but intended for internal use
        isRouteErrorResponse(error) && error.error ? error.error : error
      );
    }
  });
  return {
    routes,
    dataRoutes,
    serverMode,
    staticHandler,
    errorHandler
  };
}
var createRequestHandler = (build, mode) => {
  let _build;
  let routes;
  let serverMode;
  let staticHandler;
  let errorHandler;
  return async function requestHandler(request, loadContext = {}) {
    _build = typeof build === "function" ? await build() : build;
    if (typeof build === "function") {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    }
    let url = new URL(request.url);
    let normalizedPath = url.pathname.replace(/\.data$/, "").replace(/^\/_root$/, "/");
    if (normalizedPath !== "/" && normalizedPath.endsWith("/")) {
      normalizedPath = normalizedPath.slice(0, -1);
    }
    let params = {};
    let handleError = (error) => {
      if (mode === "development" /* Development */) {
        getDevServerHooks()?.processRequestError?.(error);
      }
      errorHandler(error, {
        context: loadContext,
        params,
        request
      });
    };
    if (!_build.ssr) {
      if (_build.prerender.length === 0) {
        request.headers.set("X-React-Router-SPA-Mode", "yes");
      } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + "/")) {
        if (url.pathname.endsWith(".data")) {
          errorHandler(
            new ErrorResponseImpl(
              404,
              "Not Found",
              `Refusing to SSR the path \`${normalizedPath}\` because \`ssr:false\` is set and the path is not included in the \`prerender\` config, so in production the path will be a 404.`
            ),
            {
              context: loadContext,
              params,
              request
            }
          );
          return new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        } else {
          request.headers.set("X-React-Router-SPA-Mode", "yes");
        }
      }
    }
    let manifestUrl = `${_build.basename ?? "/"}/__manifest`.replace(
      /\/+/g,
      "/"
    );
    if (url.pathname === manifestUrl) {
      try {
        let res = await handleManifestRequest(_build, routes, url);
        return res;
      } catch (e) {
        handleError(e);
        return new Response("Unknown Server Error", { status: 500 });
      }
    }
    let matches = matchServerRoutes(routes, url.pathname, _build.basename);
    if (matches && matches.length > 0) {
      Object.assign(params, matches[0].params);
    }
    let response;
    if (url.pathname.endsWith(".data")) {
      let handlerUrl = new URL(request.url);
      handlerUrl.pathname = normalizedPath;
      let singleFetchMatches = matchServerRoutes(
        routes,
        handlerUrl.pathname,
        _build.basename
      );
      response = await handleSingleFetchRequest(
        serverMode,
        _build,
        staticHandler,
        request,
        handlerUrl,
        loadContext,
        handleError
      );
      if (_build.entry.module.handleDataRequest) {
        response = await _build.entry.module.handleDataRequest(response, {
          context: loadContext,
          params: singleFetchMatches ? singleFetchMatches[0].params : {},
          request
        });
        if (isRedirectResponse(response)) {
          let result = getSingleFetchRedirect(
            response.status,
            response.headers,
            _build.basename
          );
          if (request.method === "GET") {
            result = {
              [SingleFetchRedirectSymbol]: result
            };
          }
          let headers = new Headers(response.headers);
          headers.set("Content-Type", "text/x-script");
          return new Response(
            encodeViaTurboStream(
              result,
              request.signal,
              _build.entry.module.streamTimeout,
              serverMode
            ),
            {
              status: SINGLE_FETCH_REDIRECT_STATUS,
              headers
            }
          );
        }
      }
    } else if (matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {
      response = await handleResourceRequest(
        serverMode,
        staticHandler,
        matches.slice(-1)[0].route.id,
        request,
        loadContext,
        handleError
      );
    } else {
      let criticalCss = mode === "development" /* Development */ ? await getDevServerHooks()?.getCriticalCss?.(_build, url.pathname) : void 0;
      response = await handleDocumentRequest(
        serverMode,
        _build,
        staticHandler,
        request,
        loadContext,
        handleError,
        criticalCss
      );
    }
    if (request.method === "HEAD") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
};
async function handleManifestRequest(build, routes, url) {
  let patches = {};
  if (url.searchParams.has("p")) {
    for (let path of url.searchParams.getAll("p")) {
      let matches = matchServerRoutes(routes, path, build.basename);
      if (matches) {
        for (let match of matches) {
          let routeId = match.route.id;
          let route = build.assets.routes[routeId];
          if (route) {
            patches[routeId] = route;
          }
        }
      }
    }
    return Response.json(patches, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", { status: 400 });
}
async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {
  let { result, headers, status } = request.method !== "GET" ? await singleFetchAction(
    build,
    serverMode,
    staticHandler,
    request,
    handlerUrl,
    loadContext,
    handleError
  ) : await singleFetchLoaders(
    build,
    serverMode,
    staticHandler,
    request,
    handlerUrl,
    loadContext,
    handleError
  );
  let resultHeaders = new Headers(headers);
  resultHeaders.set("X-Remix-Response", "yes");
  if (NO_BODY_STATUS_CODES.has(status)) {
    return new Response(null, { status, headers: resultHeaders });
  }
  resultHeaders.set("Content-Type", "text/x-script");
  return new Response(
    encodeViaTurboStream(
      result,
      request.signal,
      build.entry.module.streamTimeout,
      serverMode
    ),
    {
      status: status || 200,
      headers: resultHeaders
    }
  );
}
async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, criticalCss) {
  let isSpaMode = request.headers.has("X-React-Router-SPA-Mode");
  let context;
  try {
    context = await staticHandler.query(request, {
      requestContext: loadContext
    });
  } catch (error) {
    handleError(error);
    return new Response(null, { status: 500 });
  }
  if (isResponse(context)) {
    return context;
  }
  let headers = getDocumentHeaders(build, context);
  if (NO_BODY_STATUS_CODES.has(context.statusCode)) {
    return new Response(null, { status: context.statusCode, headers });
  }
  if (context.errors) {
    Object.values(context.errors).forEach((err) => {
      if (!isRouteErrorResponse(err) || err.error) {
        handleError(err);
      }
    });
    context.errors = sanitizeErrors(context.errors, serverMode);
  }
  let state = {
    loaderData: context.loaderData,
    actionData: context.actionData,
    errors: serializeErrors2(context.errors, serverMode)
  };
  let entryContext = {
    manifest: build.assets,
    routeModules: createEntryRouteModules(build.routes),
    staticHandlerContext: context,
    criticalCss,
    serverHandoffString: createServerHandoffString({
      basename: build.basename,
      criticalCss,
      future: build.future,
      ssr: build.ssr,
      isSpaMode
    }),
    serverHandoffStream: encodeViaTurboStream(
      state,
      request.signal,
      build.entry.module.streamTimeout,
      serverMode
    ),
    renderMeta: {},
    future: build.future,
    ssr: build.ssr,
    isSpaMode,
    serializeError: (err) => serializeError(err, serverMode)
  };
  let handleDocumentRequestFunction = build.entry.module.default;
  try {
    return await handleDocumentRequestFunction(
      request,
      context.statusCode,
      headers,
      entryContext,
      loadContext
    );
  } catch (error) {
    handleError(error);
    let errorForSecondRender = error;
    if (isResponse(error)) {
      try {
        let data2 = await unwrapResponse(error);
        errorForSecondRender = new ErrorResponseImpl(
          error.status,
          error.statusText,
          data2
        );
      } catch (e) {
      }
    }
    context = getStaticContextFromError(
      staticHandler.dataRoutes,
      context,
      errorForSecondRender
    );
    if (context.errors) {
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let state2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors2(context.errors, serverMode)
    };
    entryContext = {
      ...entryContext,
      staticHandlerContext: context,
      serverHandoffString: createServerHandoffString({
        basename: build.basename,
        future: build.future,
        ssr: build.ssr,
        isSpaMode
      }),
      serverHandoffStream: encodeViaTurboStream(
        state2,
        request.signal,
        build.entry.module.streamTimeout,
        serverMode
      ),
      renderMeta: {}
    };
    try {
      return await handleDocumentRequestFunction(
        request,
        context.statusCode,
        headers,
        entryContext,
        loadContext
      );
    } catch (error2) {
      handleError(error2);
      return returnLastResortErrorResponse(error2, serverMode);
    }
  }
}
async function handleResourceRequest(serverMode, staticHandler, routeId, request, loadContext, handleError) {
  try {
    let response = await staticHandler.queryRoute(request, {
      routeId,
      requestContext: loadContext
    });
    if (isResponse(response)) {
      return response;
    }
    if (typeof response === "string") {
      return new Response(response);
    }
    return Response.json(response);
  } catch (error) {
    if (isResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
      return error;
    }
    if (isRouteErrorResponse(error)) {
      if (error) {
        handleError(error);
      }
      return errorResponseToJson(error, serverMode);
    }
    handleError(error);
    return returnLastResortErrorResponse(error, serverMode);
  }
}
function errorResponseToJson(errorResponse, serverMode) {
  return Response.json(
    serializeError(
      // @ts-expect-error This is "private" from users but intended for internal use
      errorResponse.error || new Error("Unexpected Server Error"),
      serverMode
    ),
    {
      status: errorResponse.status,
      statusText: errorResponse.statusText,
      headers: {
        "X-Remix-Error": "yes"
      }
    }
  );
}
function returnLastResortErrorResponse(error, serverMode) {
  let message = "Unexpected Server Error";
  if (serverMode !== "production" /* Production */) {
    message += `

${String(error)}`;
  }
  return new Response(message, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function unwrapResponse(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();
}

// lib/server-runtime/sessions.ts
function flash(name) {
  return `__flash_${name}__`;
}
var createSession = (initialData = {}, id = "") => {
  let map = new Map(Object.entries(initialData));
  return {
    get id() {
      return id;
    },
    get data() {
      return Object.fromEntries(map);
    },
    has(name) {
      return map.has(name) || map.has(flash(name));
    },
    get(name) {
      if (map.has(name)) return map.get(name);
      let flashName = flash(name);
      if (map.has(flashName)) {
        let value = map.get(flashName);
        map.delete(flashName);
        return value;
      }
      return void 0;
    },
    set(name, value) {
      map.set(name, value);
    },
    flash(name, value) {
      map.set(flash(name), value);
    },
    unset(name) {
      map.delete(name);
    }
  };
};
var isSession = (object) => {
  return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
};
function createSessionStorage({
  cookie: cookieArg,
  createData,
  readData,
  updateData,
  deleteData
}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      let id = cookieHeader && await cookie.parse(cookieHeader, options);
      let data2 = id && await readData(id);
      return createSession(data2 || {}, id || "");
    },
    async commitSession(session, options) {
      let { id, data: data2 } = session;
      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;
      if (id) {
        await updateData(id, data2, expires);
      } else {
        id = await createData(data2, expires);
      }
      return cookie.serialize(id, options);
    },
    async destroySession(session, options) {
      await deleteData(session.id);
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(
    cookie.isSigned,
    `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`
  );
}

// lib/server-runtime/sessions/cookieStorage.ts
function createCookieSessionStorage({ cookie: cookieArg } = {}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      return createSession(
        cookieHeader && await cookie.parse(cookieHeader, options) || {}
      );
    },
    async commitSession(session, options) {
      let serializedCookie = await cookie.serialize(session.data, options);
      if (serializedCookie.length > 4096) {
        throw new Error(
          "Cookie length will exceed browser maximum. Length: " + serializedCookie.length
        );
      }
      return serializedCookie;
    },
    async destroySession(_session, options) {
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}

// lib/server-runtime/sessions/memoryStorage.ts
function createMemorySessionStorage({ cookie } = {}) {
  let map = /* @__PURE__ */ new Map();
  return createSessionStorage({
    cookie,
    async createData(data2, expires) {
      let id = Math.random().toString(36).substring(2, 10);
      map.set(id, { data: data2, expires });
      return id;
    },
    async readData(id) {
      if (map.has(id)) {
        let { data: data2, expires } = map.get(id);
        if (!expires || expires > /* @__PURE__ */ new Date()) {
          return data2;
        }
        if (expires) map.delete(id);
      }
      return null;
    },
    async updateData(id, data2, expires) {
      map.set(id, { data: data2, expires });
    },
    async deleteData(id) {
      map.delete(id);
    }
  });
}

// lib/href.ts
function href(path, ...args) {
  let params = args[0];
  return path.split("/").map((segment) => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return segment;
    const param = match[1];
    const value = params ? params[param] : void 0;
    const isRequired = match[2] === void 0;
    if (isRequired && value === void 0) {
      throw Error(
        `Path '${path}' requires param '${param}' but it was not provided`
      );
    }
    return value;
  }).filter((segment) => segment !== void 0).join("/");
}

// lib/dom/ssr/errors.ts
function deserializeErrors2(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(
        val.status,
        val.statusText,
        val.data,
        val.internal === true
      );
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = val.stack;
            serialized[key] = error;
          } catch (e) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = val.stack;
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}




/***/ }),

/***/ "./node_modules/react-router/node_modules/cookie/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-router/node_modules/cookie/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */
const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */
const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */
const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (() => {
    const C = function () { };
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */
function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2)
        return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
            break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    } while (index < len);
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index;
    } while (++index < max);
    return max;
}
function endIndex(str, index, min) {
    while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */
function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
        return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) ||
            !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string"
            ? options.priority.toLowerCase()
            : undefined;
        switch (priority) {
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string"
            ? options.sameSite.toLowerCase()
            : options.sameSite;
        switch (sameSite) {
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */
function decode(str) {
    if (str.indexOf("%") === -1)
        return str;
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */
function isDate(val) {
    return __toString.call(val) === "[object Date]";
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn(
            "%s(...) is deprecated in plain JavaScript React classes. %s",
            info[0],
            info[1]
          );
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance =
        ((publicInstance = publicInstance.constructor) &&
          (publicInstance.displayName || publicInstance.name)) ||
        "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] ||
        (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ),
        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE$2
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function isValidElementType(type) {
      return "string" === typeof type ||
        "function" === typeof type ||
        type === REACT_FRAGMENT_TYPE ||
        type === REACT_PROFILER_TYPE ||
        type === REACT_STRICT_MODE_TYPE ||
        type === REACT_SUSPENSE_TYPE ||
        type === REACT_SUSPENSE_LIST_TYPE ||
        type === REACT_OFFSCREEN_TYPE ||
        ("object" === typeof type &&
          null !== type &&
          (type.$$typeof === REACT_LAZY_TYPE ||
            type.$$typeof === REACT_MEMO_TYPE ||
            type.$$typeof === REACT_CONTEXT_TYPE ||
            type.$$typeof === REACT_CONSUMER_TYPE ||
            type.$$typeof === REACT_FORWARD_REF_TYPE ||
            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||
            void 0 !== type.getModuleId))
        ? !0
        : !1;
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
      if (null == type) return "";
      if ("function" === typeof type) {
        var prototype = type.prototype;
        return describeNativeComponentFrame(
          type,
          !(!prototype || !prototype.isReactComponent)
        );
      }
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return (type = describeNativeComponentFrame(type.render, !1)), type;
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type);
          case REACT_LAZY_TYPE:
            prototype = type._payload;
            type = type._init;
            try {
              return describeUnknownElementTypeFrameInDEV(type(prototype));
            } catch (x) {}
        }
      return "";
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        oldElement._owner,
        oldElement.props
      );
      newKey._store.validated = oldElement._store.validated;
      return newKey;
    }
    function validateChildKeys(node, parentType) {
      if (
        "object" === typeof node &&
        node &&
        node.$$typeof !== REACT_CLIENT_REFERENCE
      )
        if (isArrayImpl(node))
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            isValidElement(child) && validateExplicitKey(child, parentType);
          }
        else if (isValidElement(node))
          node._store && (node._store.validated = 1);
        else if (
          ((i = getIteratorFn(node)),
          "function" === typeof i &&
            i !== node.entries &&
            ((i = i.call(node)), i !== node))
        )
          for (; !(node = i.next()).done; )
            isValidElement(node.value) &&
              validateExplicitKey(node.value, parentType);
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function validateExplicitKey(element, parentType) {
      if (
        element._store &&
        !element._store.validated &&
        null == element.key &&
        ((element._store.validated = 1),
        (parentType = getCurrentComponentErrorInfo(parentType)),
        !ownerHasKeyUseWarning[parentType])
      ) {
        ownerHasKeyUseWarning[parentType] = !0;
        var childOwner = "";
        element &&
          null != element._owner &&
          element._owner !== getOwner() &&
          ((childOwner = null),
          "number" === typeof element._owner.tag
            ? (childOwner = getComponentNameFromType(element._owner.type))
            : "string" === typeof element._owner.name &&
              (childOwner = element._owner.name),
          (childOwner = " It was passed a child from " + childOwner + "."));
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
        ReactSharedInternals.getCurrentStack = function () {
          var stack = describeUnknownElementTypeFrameInDEV(element.type);
          prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
          return stack;
        };
        console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          parentType,
          childOwner
        );
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function getCurrentComponentErrorInfo(parentType) {
      var info = "",
        owner = getOwner();
      owner &&
        (owner = getComponentNameFromType(owner.type)) &&
        (info = "\n\nCheck the render method of `" + owner + "`.");
      info ||
        ((parentType = getComponentNameFromType(parentType)) &&
          (info =
            "\n\nCheck the top-level render call using <" + parentType + ">."));
      return info;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return (
        "$" +
        key.replace(/[=:]/g, function (match) {
          return escaperLookup[match];
        })
      );
    }
    function getElementKey(element, index) {
      return "object" === typeof element &&
        null !== element &&
        null != element.key
        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
        : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (
            ("string" === typeof thenable.status
              ? thenable.then(noop$1, noop$1)
              : ((thenable.status = "pending"),
                thenable.then(
                  function (fulfilledValue) {
                    "pending" === thenable.status &&
                      ((thenable.status = "fulfilled"),
                      (thenable.value = fulfilledValue));
                  },
                  function (error) {
                    "pending" === thenable.status &&
                      ((thenable.status = "rejected"),
                      (thenable.reason = error));
                  }
                )),
            thenable.status)
          ) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = !0;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = !0;
                break;
              case REACT_LAZY_TYPE:
                return (
                  (invokeCallback = children._init),
                  mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  )
                );
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey =
          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback)
          ? ((escapedPrefix = ""),
            null != childKey &&
              (escapedPrefix =
                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
              return c;
            }))
          : null != callback &&
            (isValidElement(callback) &&
              (null != callback.key &&
                ((invokeCallback && invokeCallback.key === callback.key) ||
                  checkKeyStringCoercion(callback.key)),
              (escapedPrefix = cloneAndReplaceKey(
                callback,
                escapedPrefix +
                  (null == callback.key ||
                  (invokeCallback && invokeCallback.key === callback.key)
                    ? ""
                    : ("" + callback.key).replace(
                        userProvidedKeyEscapeRegex,
                        "$&/"
                      ) + "/") +
                  childKey
              )),
              "" !== nameSoFar &&
                null != invokeCallback &&
                isValidElement(invokeCallback) &&
                null == invokeCallback.key &&
                invokeCallback._store &&
                !invokeCallback._store.validated &&
                (escapedPrefix._store.validated = 2),
              (callback = escapedPrefix)),
            array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          (nameSoFar = children[i]),
            (type = childKey + getElementKey(nameSoFar, i)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if (((i = getIteratorFn(children)), "function" === typeof i))
        for (
          i === children.entries &&
            (didWarnAboutMaps ||
              console.warn(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ),
            (didWarnAboutMaps = !0)),
            children = i.call(children),
            i = 0;
          !(nameSoFar = children.next()).done;

        )
          (nameSoFar = nameSoFar.value),
            (type = childKey + getElementKey(nameSoFar, i++)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " +
            ("[object Object]" === array
              ? "object with keys {" + Object.keys(children).join(", ") + "}"
              : array) +
            "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function (moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 1), (payload._result = moduleObject);
          },
          function (error) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 2), (payload._result = error);
          }
        );
        -1 === payload._status &&
          ((payload._status = 0), (payload._result = ctor));
      }
      if (1 === payload._status)
        return (
          (ctor = payload._result),
          void 0 === ctor &&
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ),
          "default" in ctor ||
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ),
          ctor.default
        );
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (null === enqueueTaskImpl)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(
            module,
            "timers"
          ).setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function (callback) {
            !1 === didWarnAboutMessageChannel &&
              ((didWarnAboutMessageChannel = !0),
              "undefined" === typeof MessageChannel &&
                console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
            var channel = new MessageChannel();
            channel.port1.onmessage = callback;
            channel.port2.postMessage(void 0);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError
        ? new AggregateError(errors)
        : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 &&
        console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue)
        if (0 !== queue.length)
          try {
            flushActQueue(queue);
            enqueueTask(function () {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length
        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          reject(queue))
        : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if (
        "object" !== typeof partialState &&
        "function" !== typeof partialState &&
        null != partialState
      )
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      },
      fnName;
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) &&
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      specialPropKeyWarningShown,
      didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var ownerHasKeyUseWarning = {},
      didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks =
        "function" === typeof queueMicrotask
          ? function (callback) {
              queueMicrotask(function () {
                return queueMicrotask(callback);
              });
            }
          : enqueueTask;
    exports.Children = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function () {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return (
          mapChildren(children, function (child) {
            return child;
          }) || []
        );
      },
      only: function (children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      ReactSharedInternals;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = (ReactSharedInternals.actQueue =
          null !== prevActQueue ? prevActQueue : []),
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          (popActScope(prevActQueue, prevActScopeDepth),
          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      if (
        null !== result &&
        "object" === typeof result &&
        "function" === typeof result.then
      ) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall ||
            didWarnNoAwaitAct ||
            ((didWarnNoAwaitAct = !0),
            console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(
              function (returnValue) {
                popActScope(prevActQueue, prevActScopeDepth);
                if (0 === prevActScopeDepth) {
                  try {
                    flushActQueue(queue),
                      enqueueTask(function () {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                  } catch (error$2) {
                    ReactSharedInternals.thrownErrors.push(error$2);
                  }
                  if (0 < ReactSharedInternals.thrownErrors.length) {
                    var _thrownError = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    );
                    ReactSharedInternals.thrownErrors.length = 0;
                    reject(_thrownError);
                  }
                } else resolve(returnValue);
              },
              function (error) {
                popActScope(prevActQueue, prevActScopeDepth);
                0 < ReactSharedInternals.thrownErrors.length
                  ? ((error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    )),
                    (ReactSharedInternals.thrownErrors.length = 0),
                    reject(error))
                  : reject(error);
              }
            );
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth &&
        (flushActQueue(queue),
        0 !== queue.length &&
          queueSeveralMicrotasks(function () {
            didAwaitActCall ||
              didWarnNoAwaitAct ||
              ((didWarnNoAwaitAct = !0),
              console.error(
                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
              ));
          }),
        (ReactSharedInternals.actQueue = null));
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth
            ? ((ReactSharedInternals.actQueue = queue),
              enqueueTask(function () {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              }))
            : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " +
            element +
            "."
        );
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (
            hasOwnProperty.call(config, "ref") &&
            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) &&
            JSCompiler_inline_result.isReactWarning
          ) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (key = "" + config.key));
        for (propName in config)
          !hasOwnProperty.call(config, propName) ||
            "key" === propName ||
            "__self" === propName ||
            "__source" === propName ||
            ("ref" === propName && void 0 === config.ref) ||
            (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, void 0, void 0, owner, props);
      for (key = 2; key < arguments.length; key++)
        validateChildKeys(arguments[key], props.type);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      if (isValidElementType(type))
        for (var i = 2; i < arguments.length; i++)
          validateChildKeys(arguments[i], type);
      else {
        i = "";
        if (
          void 0 === type ||
          ("object" === typeof type &&
            null !== type &&
            0 === Object.keys(type).length)
        )
          i +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        if (null === type) var typeString = "null";
        else
          isArrayImpl(type)
            ? (typeString = "array")
            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
              ? ((typeString =
                  "<" +
                  (getComponentNameFromType(type.type) || "Unknown") +
                  " />"),
                (i =
                  " Did you accidentally export a JSX literal instead of a component?"))
              : (typeString = typeof type);
        console.error(
          "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          typeString,
          i
        );
      }
      var propName;
      i = {};
      typeString = null;
      if (null != config)
        for (propName in (didWarnAboutOldJSXRuntime ||
          !("__self" in config) ||
          "key" in config ||
          ((didWarnAboutOldJSXRuntime = !0),
          console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )),
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (typeString = "" + config.key)),
        config))
          hasOwnProperty.call(config, propName) &&
            "key" !== propName &&
            "__self" !== propName &&
            "__source" !== propName &&
            (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;
      else if (1 < childrenLength) {
        for (
          var childArray = Array(childrenLength), _i = 0;
          _i < childrenLength;
          _i++
        )
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in ((childrenLength = type.defaultProps), childrenLength))
          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      typeString &&
        defineKeyPropWarningGetter(
          i,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
    };
    exports.createRef = function () {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE
        ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          )
        : "function" !== typeof render
          ? console.error(
              "forwardRef requires a render function but was given %s.",
              null === render ? "null" : typeof render
            )
          : 0 !== render.length &&
            2 !== render.length &&
            console.error(
              "forwardRef render functions accept exactly two parameters: props and ref. %s",
              1 === render.length
                ? "Did you forget to use the ref parameter?"
                : "Any additional parameter will be undefined."
            );
      null != render &&
        null != render.defaultProps &&
        console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name ||
            render.displayName ||
            (Object.defineProperty(render, "name", { value: name }),
            (render.displayName = name));
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function (type, compare) {
      isValidElementType(type) ||
        console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name ||
            type.displayName ||
            (Object.defineProperty(type, "name", { value: name }),
            (type.displayName = name));
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue &&
          null !== returnValue &&
          "function" === typeof returnValue.then &&
          returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition &&
          currentTransition._updatedFibers &&
          ((scope = currentTransition._updatedFibers.size),
          currentTransition._updatedFibers.clear(),
          10 < scope &&
            console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )),
          (ReactSharedInternals.T = prevTransition);
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(
        action,
        initialState,
        permalink
      );
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE &&
        console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, deps) {
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      return resolveDispatcher().useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ ((module) => {



var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false,
};

function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}

function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);

  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name = parsed.name;
  var value = parsed.value;

  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  try {
    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
  } catch (e) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" +
        value +
        "'. Set options.decodeValues to false to disable this feature.",
      e
    );
  }

  var cookie = {
    name: name,
    value: value,
  };

  parts.forEach(function (part) {
    var sides = part.split("=");
    var key = sides.shift().trimLeft().toLowerCase();
    var value = sides.join("=");
    if (key === "expires") {
      cookie.expires = new Date(value);
    } else if (key === "max-age") {
      cookie.maxAge = parseInt(value, 10);
    } else if (key === "secure") {
      cookie.secure = true;
    } else if (key === "httponly") {
      cookie.httpOnly = true;
    } else if (key === "samesite") {
      cookie.sameSite = value;
    } else if (key === "partitioned") {
      cookie.partitioned = true;
    } else {
      cookie[key] = value;
    }
  });

  return cookie;
}

function parseNameValuePair(nameValuePairStr) {
  // Parses name-value-pair according to rfc6265bis draft

  var name = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
  } else {
    value = nameValuePairStr;
  }

  return { name: name, value: value };
}

function parse(input, options) {
  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }

  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      // for fetch responses - they combine headers of the same type in the headers array,
      // but getSetCookie returns an uncombined array
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      // fast-path for node.js (which automatically normalizes header names to lower-case
      input = input.headers["set-cookie"];
    } else {
      // slow-path for other environments - see #25
      var sch =
        input.headers[
          Object.keys(input.headers).find(function (key) {
            return key.toLowerCase() === "set-cookie";
          })
        ];
      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
      if (!sch && input.headers.cookie && !options.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }

  if (!options.map) {
    return input.filter(isNonEmptyString).map(function (str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
      var cookie = parseString(str, options);
      cookies[cookie.name] = cookie;
      return cookies;
    }, cookies);
  }
}

/*
  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
  that are within a single set-cookie field-value, such as in the Expires portion.

  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
  React Native's fetch does this for *every* header, including set-cookie.

  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
*/
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }

  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;

  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }

  function notSpecialChar() {
    ch = cookiesString.charAt(pos);

    return ch !== "=" && ch !== ";" && ch !== ",";
  }

  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;

    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        // ',' is a cookie separator if we have later first '=', not ';' or ','
        lastComma = pos;
        pos += 1;

        skipWhitespace();
        nextStart = pos;

        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }

        // currently special character
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          // we found cookies separator
          cookiesSeparatorFound = true;
          // pos is inside the next cookie, so back up and return it.
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          // in param ',' or param separator ';',
          // we continue from that comma
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }

    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }

  return cookiesStrings;
}

module.exports = parse;
module.exports.parse = parse;
module.exports.parseString = parseString;
module.exports.splitCookiesString = splitCookiesString;


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/turbo-stream/dist/turbo-stream.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/turbo-stream/dist/turbo-stream.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
// src/utils.ts
var HOLE = -1;
var NAN = -2;
var NEGATIVE_INFINITY = -3;
var NEGATIVE_ZERO = -4;
var NULL = -5;
var POSITIVE_INFINITY = -6;
var UNDEFINED = -7;
var TYPE_BIGINT = "B";
var TYPE_DATE = "D";
var TYPE_ERROR = "E";
var TYPE_MAP = "M";
var TYPE_NULL_OBJECT = "N";
var TYPE_PROMISE = "P";
var TYPE_REGEXP = "R";
var TYPE_SET = "S";
var TYPE_SYMBOL = "Y";
var TYPE_URL = "U";
var TYPE_PREVIOUS_RESOLVED = "Z";
var Deferred = class {
  promise;
  resolve;
  reject;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function createLineSplittingTransform() {
  const decoder = new TextDecoder();
  let leftover = "";
  return new TransformStream({
    transform(chunk, controller) {
      const str = decoder.decode(chunk, { stream: true });
      const parts = (leftover + str).split("\n");
      leftover = parts.pop() || "";
      for (const part of parts) {
        controller.enqueue(part);
      }
    },
    flush(controller) {
      if (leftover) {
        controller.enqueue(leftover);
      }
    }
  });
}

// src/flatten.ts
function flatten(input) {
  const { indices } = this;
  const existing = indices.get(input);
  if (existing)
    return [existing];
  if (input === void 0)
    return UNDEFINED;
  if (input === null)
    return NULL;
  if (Number.isNaN(input))
    return NAN;
  if (input === Number.POSITIVE_INFINITY)
    return POSITIVE_INFINITY;
  if (input === Number.NEGATIVE_INFINITY)
    return NEGATIVE_INFINITY;
  if (input === 0 && 1 / input < 0)
    return NEGATIVE_ZERO;
  const index = this.index++;
  indices.set(input, index);
  stringify.call(this, input, index);
  return index;
}
function stringify(input, index) {
  const { deferred, plugins, postPlugins } = this;
  const str = this.stringified;
  const stack = [[input, index]];
  while (stack.length > 0) {
    const [input2, index2] = stack.pop();
    const partsForObj = (obj) => Object.keys(obj).map((k) => `"_${flatten.call(this, k)}":${flatten.call(this, obj[k])}`).join(",");
    let error = null;
    switch (typeof input2) {
      case "boolean":
      case "number":
      case "string":
        str[index2] = JSON.stringify(input2);
        break;
      case "bigint":
        str[index2] = `["${TYPE_BIGINT}","${input2}"]`;
        break;
      case "symbol": {
        const keyFor = Symbol.keyFor(input2);
        if (!keyFor) {
          error = new Error(
            "Cannot encode symbol unless created with Symbol.for()"
          );
        } else {
          str[index2] = `["${TYPE_SYMBOL}",${JSON.stringify(keyFor)}]`;
        }
        break;
      }
      case "object": {
        if (!input2) {
          str[index2] = `${NULL}`;
          break;
        }
        const isArray = Array.isArray(input2);
        let pluginHandled = false;
        if (!isArray && plugins) {
          for (const plugin of plugins) {
            const pluginResult = plugin(input2);
            if (Array.isArray(pluginResult)) {
              pluginHandled = true;
              const [pluginIdentifier, ...rest] = pluginResult;
              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
              if (rest.length > 0) {
                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
              }
              str[index2] += "]";
              break;
            }
          }
        }
        if (!pluginHandled) {
          let result = isArray ? "[" : "{";
          if (isArray) {
            for (let i = 0; i < input2.length; i++)
              result += (i ? "," : "") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);
            str[index2] = `${result}]`;
          } else if (input2 instanceof Date) {
            str[index2] = `["${TYPE_DATE}",${input2.getTime()}]`;
          } else if (input2 instanceof URL) {
            str[index2] = `["${TYPE_URL}",${JSON.stringify(input2.href)}]`;
          } else if (input2 instanceof RegExp) {
            str[index2] = `["${TYPE_REGEXP}",${JSON.stringify(
              input2.source
            )},${JSON.stringify(input2.flags)}]`;
          } else if (input2 instanceof Set) {
            if (input2.size > 0) {
              str[index2] = `["${TYPE_SET}",${[...input2].map((val) => flatten.call(this, val)).join(",")}]`;
            } else {
              str[index2] = `["${TYPE_SET}"]`;
            }
          } else if (input2 instanceof Map) {
            if (input2.size > 0) {
              str[index2] = `["${TYPE_MAP}",${[...input2].flatMap(([k, v]) => [
                flatten.call(this, k),
                flatten.call(this, v)
              ]).join(",")}]`;
            } else {
              str[index2] = `["${TYPE_MAP}"]`;
            }
          } else if (input2 instanceof Promise) {
            str[index2] = `["${TYPE_PROMISE}",${index2}]`;
            deferred[index2] = input2;
          } else if (input2 instanceof Error) {
            str[index2] = `["${TYPE_ERROR}",${JSON.stringify(input2.message)}`;
            if (input2.name !== "Error") {
              str[index2] += `,${JSON.stringify(input2.name)}`;
            }
            str[index2] += "]";
          } else if (Object.getPrototypeOf(input2) === null) {
            str[index2] = `["${TYPE_NULL_OBJECT}",{${partsForObj(input2)}}]`;
          } else if (isPlainObject(input2)) {
            str[index2] = `{${partsForObj(input2)}}`;
          } else {
            error = new Error("Cannot encode object with prototype");
          }
        }
        break;
      }
      default: {
        const isArray = Array.isArray(input2);
        let pluginHandled = false;
        if (!isArray && plugins) {
          for (const plugin of plugins) {
            const pluginResult = plugin(input2);
            if (Array.isArray(pluginResult)) {
              pluginHandled = true;
              const [pluginIdentifier, ...rest] = pluginResult;
              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
              if (rest.length > 0) {
                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
              }
              str[index2] += "]";
              break;
            }
          }
        }
        if (!pluginHandled) {
          error = new Error("Cannot encode function or unexpected type");
        }
      }
    }
    if (error) {
      let pluginHandled = false;
      if (postPlugins) {
        for (const plugin of postPlugins) {
          const pluginResult = plugin(input2);
          if (Array.isArray(pluginResult)) {
            pluginHandled = true;
            const [pluginIdentifier, ...rest] = pluginResult;
            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
            if (rest.length > 0) {
              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
            }
            str[index2] += "]";
            break;
          }
        }
      }
      if (!pluginHandled) {
        throw error;
      }
    }
  }
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function isPlainObject(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames;
}

// src/unflatten.ts
var globalObj = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : void 0;
function unflatten(parsed) {
  const { hydrated, values } = this;
  if (typeof parsed === "number")
    return hydrate.call(this, parsed);
  if (!Array.isArray(parsed) || !parsed.length)
    throw new SyntaxError();
  const startIndex = values.length;
  for (const value of parsed) {
    values.push(value);
  }
  hydrated.length = values.length;
  return hydrate.call(this, startIndex);
}
function hydrate(index) {
  const { hydrated, values, deferred, plugins } = this;
  let result;
  const stack = [
    [
      index,
      (v) => {
        result = v;
      }
    ]
  ];
  let postRun = [];
  while (stack.length > 0) {
    const [index2, set] = stack.pop();
    switch (index2) {
      case UNDEFINED:
        set(void 0);
        continue;
      case NULL:
        set(null);
        continue;
      case NAN:
        set(NaN);
        continue;
      case POSITIVE_INFINITY:
        set(Infinity);
        continue;
      case NEGATIVE_INFINITY:
        set(-Infinity);
        continue;
      case NEGATIVE_ZERO:
        set(-0);
        continue;
    }
    if (hydrated[index2]) {
      set(hydrated[index2]);
      continue;
    }
    const value = values[index2];
    if (!value || typeof value !== "object") {
      hydrated[index2] = value;
      set(value);
      continue;
    }
    if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const [type, b, c] = value;
        switch (type) {
          case TYPE_DATE:
            set(hydrated[index2] = new Date(b));
            continue;
          case TYPE_URL:
            set(hydrated[index2] = new URL(b));
            continue;
          case TYPE_BIGINT:
            set(hydrated[index2] = BigInt(b));
            continue;
          case TYPE_REGEXP:
            set(hydrated[index2] = new RegExp(b, c));
            continue;
          case TYPE_SYMBOL:
            set(hydrated[index2] = Symbol.for(b));
            continue;
          case TYPE_SET:
            const newSet = /* @__PURE__ */ new Set();
            hydrated[index2] = newSet;
            for (let i = 1; i < value.length; i++)
              stack.push([
                value[i],
                (v) => {
                  newSet.add(v);
                }
              ]);
            set(newSet);
            continue;
          case TYPE_MAP:
            const map = /* @__PURE__ */ new Map();
            hydrated[index2] = map;
            for (let i = 1; i < value.length; i += 2) {
              const r = [];
              stack.push([
                value[i + 1],
                (v) => {
                  r[1] = v;
                }
              ]);
              stack.push([
                value[i],
                (k) => {
                  r[0] = k;
                }
              ]);
              postRun.push(() => {
                map.set(r[0], r[1]);
              });
            }
            set(map);
            continue;
          case TYPE_NULL_OBJECT:
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index2] = obj;
            for (const key of Object.keys(b).reverse()) {
              const r = [];
              stack.push([
                b[key],
                (v) => {
                  r[1] = v;
                }
              ]);
              stack.push([
                Number(key.slice(1)),
                (k) => {
                  r[0] = k;
                }
              ]);
              postRun.push(() => {
                obj[r[0]] = r[1];
              });
            }
            set(obj);
            continue;
          case TYPE_PROMISE:
            if (hydrated[b]) {
              set(hydrated[index2] = hydrated[b]);
            } else {
              const d = new Deferred();
              deferred[b] = d;
              set(hydrated[index2] = d.promise);
            }
            continue;
          case TYPE_ERROR:
            const [, message, errorType] = value;
            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);
            hydrated[index2] = error;
            set(error);
            continue;
          case TYPE_PREVIOUS_RESOLVED:
            set(hydrated[index2] = hydrated[b]);
            continue;
          default:
            if (Array.isArray(plugins)) {
              const r = [];
              const vals = value.slice(1);
              for (let i = 0; i < vals.length; i++) {
                const v = vals[i];
                stack.push([
                  v,
                  (v2) => {
                    r[i] = v2;
                  }
                ]);
              }
              postRun.push(() => {
                for (const plugin of plugins) {
                  const result2 = plugin(value[0], ...r);
                  if (result2) {
                    set(hydrated[index2] = result2.value);
                    return;
                  }
                }
                throw new SyntaxError();
              });
              continue;
            }
            throw new SyntaxError();
        }
      } else {
        const array = [];
        hydrated[index2] = array;
        for (let i = 0; i < value.length; i++) {
          const n = value[i];
          if (n !== HOLE) {
            stack.push([
              n,
              (v) => {
                array[i] = v;
              }
            ]);
          }
        }
        set(array);
        continue;
      }
    } else {
      const object = {};
      hydrated[index2] = object;
      for (const key of Object.keys(value).reverse()) {
        const r = [];
        stack.push([
          value[key],
          (v) => {
            r[1] = v;
          }
        ]);
        stack.push([
          Number(key.slice(1)),
          (k) => {
            r[0] = k;
          }
        ]);
        postRun.push(() => {
          object[r[0]] = r[1];
        });
      }
      set(object);
      continue;
    }
  }
  while (postRun.length > 0) {
    postRun.pop()();
  }
  return result;
}

// src/turbo-stream.ts
async function decode(readable, options) {
  const { plugins } = options ?? {};
  const done = new Deferred();
  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();
  const decoder = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins
  };
  const decoded = await decodeInitial.call(decoder, reader);
  let donePromise = done.promise;
  if (decoded.done) {
    done.resolve();
  } else {
    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {
      for (const deferred of Object.values(decoder.deferred)) {
        deferred.reject(reason);
      }
      done.reject(reason);
    });
  }
  return {
    done: donePromise.then(() => reader.closed),
    value: decoded.value
  };
}
async function decodeInitial(reader) {
  const read = await reader.read();
  if (!read.value) {
    throw new SyntaxError();
  }
  let line;
  try {
    line = JSON.parse(read.value);
  } catch (reason) {
    throw new SyntaxError();
  }
  return {
    done: read.done,
    value: unflatten.call(this, line)
  };
}
async function decodeDeferred(reader) {
  let read = await reader.read();
  while (!read.done) {
    if (!read.value)
      continue;
    const line = read.value;
    switch (line[0]) {
      case TYPE_PROMISE: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.resolve(value);
        break;
      }
      case TYPE_ERROR: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.reject(value);
        break;
      }
      default:
        throw new SyntaxError();
    }
    read = await reader.read();
  }
}
function encode(input, options) {
  const { plugins, postPlugins, signal } = options ?? {};
  const encoder = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */ new Map(),
    stringified: [],
    plugins,
    postPlugins,
    signal
  };
  const textEncoder = new TextEncoder();
  let lastSentIndex = 0;
  const readable = new ReadableStream({
    async start(controller) {
      const id = flatten.call(encoder, input);
      if (Array.isArray(id)) {
        throw new Error("This should never happen");
      }
      if (id < 0) {
        controller.enqueue(textEncoder.encode(`${id}
`));
      } else {
        controller.enqueue(
          textEncoder.encode(`[${encoder.stringified.join(",")}]
`)
        );
        lastSentIndex = encoder.stringified.length - 1;
      }
      const seenPromises = /* @__PURE__ */ new WeakSet();
      while (Object.keys(encoder.deferred).length > 0) {
        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {
          if (seenPromises.has(deferred))
            continue;
          seenPromises.add(
            encoder.deferred[Number(deferredId)] = raceSignal(
              deferred,
              encoder.signal
            ).then(
              (resolved) => {
                const id2 = flatten.call(encoder, resolved);
                if (Array.isArray(id2)) {
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_PROMISE}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                    )
                  );
                  encoder.index++;
                  lastSentIndex++;
                } else if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_PROMISE}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              },
              (reason) => {
                if (!reason || typeof reason !== "object" || !(reason instanceof Error)) {
                  reason = new Error("An unknown error occurred");
                }
                const id2 = flatten.call(encoder, reason);
                if (Array.isArray(id2)) {
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_ERROR}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                    )
                  );
                  encoder.index++;
                  lastSentIndex++;
                } else if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_ERROR}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              }
            ).finally(() => {
              delete encoder.deferred[Number(deferredId)];
            })
          );
        }
        await Promise.race(Object.values(encoder.deferred));
      }
      await Promise.all(Object.values(encoder.deferred));
      controller.close();
    }
  });
  return readable;
}
function raceSignal(promise, signal) {
  if (!signal)
    return promise;
  if (signal.aborted)
    return Promise.reject(signal.reason || new Error("Signal was aborted."));
  const abort = new Promise((resolve, reject) => {
    signal.addEventListener("abort", (event) => {
      reject(signal.reason || new Error("Signal was aborted."));
    });
    promise.then(resolve).catch(reject);
  });
  abort.catch(() => {
  });
  return Promise.race([abort, promise]);
}



/***/ }),

/***/ "./src/assets/icon-01.png":
/*!********************************!*\
  !*** ./src/assets/icon-01.png ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "f5ba05ec185b19f4a8b98c340f83fbe3.png");

/***/ }),

/***/ "./src/assets/icon-02.png":
/*!********************************!*\
  !*** ./src/assets/icon-02.png ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "12191b47c66a47fdc7cf7a41b059e9de.png");

/***/ }),

/***/ "./src/assets/icon-03.png":
/*!********************************!*\
  !*** ./src/assets/icon-03.png ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "45636e10ece273fe2390a359b74752ef.png");

/***/ }),

/***/ "./src/assets/icon-04.png":
/*!********************************!*\
  !*** ./src/assets/icon-04.png ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "57d171bc76fce3d92eaf0b034c8d6f15.png");

/***/ }),

/***/ "./src/assets/icon-05.png":
/*!********************************!*\
  !*** ./src/assets/icon-05.png ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "a65432f7d3e9ea24231e62f2059deb90.png");

/***/ }),

/***/ "./src/assets/icon-twitter.png":
/*!*************************************!*\
  !*** ./src/assets/icon-twitter.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "307314caf8e0f3570fe27e02cb947acf.png");

/***/ }),

/***/ "./src/assets/icon-warning.png":
/*!*************************************!*\
  !*** ./src/assets/icon-warning.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "6a61110140c5958d011a10831ba42f8a.png");

/***/ }),

/***/ "./src/assets/icon-youtube.png":
/*!*************************************!*\
  !*** ./src/assets/icon-youtube.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "2ad649e45a019a9e49021a45c425adae.png");

/***/ }),

/***/ "./src/assets/logo-hubgets-footer.png":
/*!********************************************!*\
  !*** ./src/assets/logo-hubgets-footer.png ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "a69df6cd2f6a659081507ec003228234.png");

/***/ }),

/***/ "./src/assets/logo-hubgets.png":
/*!*************************************!*\
  !*** ./src/assets/logo-hubgets.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "6488a0708a68a63ce91d1d9e3b309b53.png");

/***/ }),

/***/ "./src/components/FacilitiesUser.js":
/*!******************************************!*\
  !*** ./src/components/FacilitiesUser.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs");
/* harmony import */ var _assets_icon_02_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/icon-02.png */ "./src/assets/icon-02.png");
/* harmony import */ var _assets_icon_03_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assets/icon-03.png */ "./src/assets/icon-03.png");
/* harmony import */ var _assets_icon_04_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/icon-04.png */ "./src/assets/icon-04.png");
/* harmony import */ var _assets_icon_05_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/icon-05.png */ "./src/assets/icon-05.png");






var FacilityUser = function FacilityUser() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "content__article"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("article", {
    className: "content__article--features"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_02_png__WEBPACK_IMPORTED_MODULE_1__["default"],
    alt: "Centralize"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Centralizes communication channels and reduces overhead.")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("article", {
    className: "content__article--features"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_03_png__WEBPACK_IMPORTED_MODULE_2__["default"],
    alt: "Communication Tools"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Brings together instant messaging, voice and video communication in the browser.")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("article", {
    className: "content__article--features"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_04_png__WEBPACK_IMPORTED_MODULE_3__["default"],
    alt: "Information Manager"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Captures information across the organization, retains the knowledge, anlizes and improves it.")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("article", {
    className: "help"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_05_png__WEBPACK_IMPORTED_MODULE_4__["default"],
    alt: "Help"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "+1 845 894 123"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
    to: "/company/contact"
  }, " help@hubgets.com")))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FacilityUser);

/***/ }),

/***/ "./src/components/Footer.js":
/*!**********************************!*\
  !*** ./src/components/Footer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs");
/* harmony import */ var _assets_logo_hubgets_footer_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/logo-hubgets-footer.png */ "./src/assets/logo-hubgets-footer.png");
/* harmony import */ var _assets_icon_twitter_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assets/icon-twitter.png */ "./src/assets/icon-twitter.png");
/* harmony import */ var _assets_icon_youtube_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/icon-youtube.png */ "./src/assets/icon-youtube.png");





var Footer = function Footer() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("footer", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "content-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "footer__nav"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "logo-footer"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_logo_hubgets_footer_png__WEBPACK_IMPORTED_MODULE_1__["default"],
    alt: "hubgets"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "footer__nav--links"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h4", null, "Our company"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/about",
    className: "link"
  }, "About Us"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/blog",
    className: "link"
  }, "Blog"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/hiring",
    className: "link"
  }, "We are hiring"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/terms",
    c: true,
    className: "link"
  }, "Terms of Service"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/contact",
    className: "link"
  }, "Contact us")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "footer__nav--links"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h4", null, "Hubgets"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/program",
    className: "link"
  }, "Join the program"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/features",
    className: "link"
  }, "Features"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.NavLink, {
    to: "/status",
    className: "link"
  }, "Current Status")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "footer__nav--links"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h4", null, "Social"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "social-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_twitter_png__WEBPACK_IMPORTED_MODULE_2__["default"]
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("a", {
    href: "https://twitter.com/hubgets",
    target: "_blank"
  }, "Twitter")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "social-link"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_icon_youtube_png__WEBPACK_IMPORTED_MODULE_3__["default"]
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("a", {
    href: "https://www.youtube.com/channel/UCq3OM4g1oYSbR0GWQYCEuBQ",
    target: "_blank"
  }, "Youtube")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    id: "copy"
  }, "\xA9 Copyrights 2015 Hubgets, Inc")));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Footer);

/***/ }),

/***/ "./src/components/Header.js":
/*!**********************************!*\
  !*** ./src/components/Header.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs");
/* harmony import */ var _assets_logo_hubgets_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/logo-hubgets.png */ "./src/assets/logo-hubgets.png");



var Header = function Header() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("header", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "content-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "logo"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__.Link, {
    to: "/"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
    src: _assets_logo_hubgets_png__WEBPACK_IMPORTED_MODULE_1__["default"],
    alt: "hubgets",
    placeholder: "hubgets"
  })))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);

/***/ }),

/***/ "./src/components/HomePage.js":
/*!************************************!*\
  !*** ./src/components/HomePage.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RegisterUser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RegisterUser */ "./src/components/RegisterUser.js");
/* harmony import */ var _FacilitiesUser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FacilitiesUser */ "./src/components/FacilitiesUser.js");
/* harmony import */ var _MainHeader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MainHeader */ "./src/components/MainHeader.js");




var HomePage = function HomePage() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MainHeader__WEBPACK_IMPORTED_MODULE_3__["default"], null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("section", {
    className: "flex__section"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "content-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "flex__section--content"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_RegisterUser__WEBPACK_IMPORTED_MODULE_1__["default"], null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_FacilitiesUser__WEBPACK_IMPORTED_MODULE_2__["default"], null)))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HomePage);

/***/ }),

/***/ "./src/components/MainHeader.js":
/*!**************************************!*\
  !*** ./src/components/MainHeader.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var MainHeader = function MainHeader() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("article", {
    className: "article__content"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "content-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "article__text"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h1", null, "Create organization"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Small or large, any team will increase productivity with Hubgets."), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "It allows teams to filter noise and focus on results.")))));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainHeader);

/***/ }),

/***/ "./src/components/NotFoundPage.js":
/*!****************************************!*\
  !*** ./src/components/NotFoundPage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs");


var NotFoundPage = function NotFoundPage() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, "404! - ", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__.Link, {
    to: "/"
  }, "Go home"));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NotFoundPage);

/***/ }),

/***/ "./src/components/RegisterUser.js":
/*!****************************************!*\
  !*** ./src/components/RegisterUser.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RegisterUser)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _assets_icon_01_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/icon-01.png */ "./src/assets/icon-01.png");
/* harmony import */ var _assets_icon_warning_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assets/icon-warning.png */ "./src/assets/icon-warning.png");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var RegisterUser = /*#__PURE__*/function (_React$Component) {
  function RegisterUser() {
    var _this;
    _classCallCheck(this, RegisterUser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, RegisterUser, [].concat(args));
    _defineProperty(_this, "state", {
      fields: {},
      errors: {}
    });
    _defineProperty(_this, "handleValidation", function () {
      var fields = _this.state.fields;
      var errors = {};
      var formIsValid = true;
      if ((_typeof(fields["name"]) || _typeof(fields["lastName"])) !== "undefined") {
        if (!fields["name"].match(/^[a-zA-Z]+$/)) {
          formIsValid = false;
          errors["name"] = "Only letters";
        }
      }
      if (!fields["email"] || !fields["lastName"] || !fields["email"] || !fields["company"]) {
        formIsValid = false;
        errors["email"] = "Cannot be empty";
      }
      if (typeof fields["email"] !== "undefined") {
        var lastAtPos = fields["email"].lastIndexOf('@');
        var lastDotPos = fields["email"].lastIndexOf('.');
        if (!(lastAtPos < lastDotPos && lastAtPos > 0 && fields["email"].indexOf('@@') == -1 && lastDotPos > 2 && fields["email"].length - lastDotPos > 2)) {
          formIsValid = false;
          errors["email"] = "Invalid e-mail adress";
        }
      }
      _this.setState({
        errors: errors
      });
      return formIsValid;
    });
    _defineProperty(_this, "contactSubmit", function (e) {
      e.preventDefault();
      if (_this.handleValidation()) {
        //alert("Form submitted");
      } else {
        //alert("Form has errors")
      }
    });
    _defineProperty(_this, "handleChange", function (field, e) {
      var fields = _this.state.fields;
      fields[field] = e.target.value;
      _this.setState({
        fields: fields
      });
    });
    return _this;
  }
  _inherits(RegisterUser, _React$Component);
  return _createClass(RegisterUser, [{
    key: "render",
    value: function render() {
      var classes = "";
      classes += this.state.errors["name"] || this.state.errors["lastName"] || this.state.errors["email"] || this.state.errors["company"] ? "error" : "ok";
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "center-span"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", {
        id: "register-img"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", {
        src: _assets_icon_01_png__WEBPACK_IMPORTED_MODULE_1__["default"]
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "register-form"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("form", {
        className: "wrapper",
        onSubmit: this.contactSubmit.bind(this)
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__row"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-5"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("label", {
        htmlFor: "name"
      }, "First name"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", {
        ref: "name",
        type: "text",
        size: "30",
        onChange: this.handleChange.bind(this, "name"),
        value: this.state.fields["name"],
        className: classes
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-5"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("label", {
        htmlFor: "lastName"
      }, "Last name"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", {
        refs: "lastName",
        type: "text",
        sise: "30",
        onChange: this.handleChange.bind(this, "lastName"),
        value: this.state.fields["lastName"],
        className: classes
      }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__row"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-12"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("label", {
        htmlFor: "company"
      }, "Company"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", {
        refs: "company",
        type: "text",
        size: "30",
        onChange: this.handleChange.bind(this, "company"),
        value: this.state.fields["company"],
        className: classes
      }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__row"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-12"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("label", {
        htmlFor: "email"
      }, "E-mail address"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", {
        refs: "email",
        type: "text",
        size: "30",
        onChange: this.handleChange.bind(this, "email"),
        value: this.state.fields["email"],
        className: classes,
        src: _assets_icon_warning_png__WEBPACK_IMPORTED_MODULE_2__["default"]
      }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__row"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-5"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("button", {
        id: "submit",
        value: "Submit"
      }, "Register")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "wrapper__col-5"
      }, this.state.errors["email"] && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", {
        id: "error",
        className: classes
      }, this.state.errors["email"]))))));
    }
  }]);
}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));

;

/***/ }),

/***/ "./src/routers/AppRouter.js":
/*!**********************************!*\
  !*** ./src/routers/AppRouter.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-HA7DTUK3.mjs");
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Header */ "./src/components/Header.js");
/* harmony import */ var _components_HomePage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/HomePage */ "./src/components/HomePage.js");
/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Footer */ "./src/components/Footer.js");
/* harmony import */ var _components_NotFoundPage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/NotFoundPage */ "./src/components/NotFoundPage.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






var AppRouter = function AppRouter() {
  var stylePages = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
    maxWidth: '60rem',
    margin: '0 auto',
    padding: '3rem 0 0 0'
  }, "padding", '0 $m-size'), "height", '50rem'), "fontSize", '2em'), "textAlign", 'center'), "fontWeight", 500);

  //pages Our Company
  var AboutUs = function AboutUs() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, " This is from my component About Us Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var BlogPage = function BlogPage() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Blog Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var Contact = function Contact() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Contact Us Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var HiringPage = function HiringPage() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "We are Hiring Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var TermsOfService = function TermsOfService() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Terms of Service Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };

  //Pages Our hubgets
  var CurrentStatus = function CurrentStatus() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "This is from my component Current Status Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var Features = function Features() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Features Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  var ProgramHubgets = function ProgramHubgets() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      style: stylePages
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("p", null, "Join The Program Page"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Link, {
      to: "/"
    }, "Go home"));
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.BrowserRouter, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_Header__WEBPACK_IMPORTED_MODULE_1__["default"], null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Routes, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/",
    component: _components_HomePage__WEBPACK_IMPORTED_MODULE_2__["default"],
    exact: true
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/about",
    component: AboutUs
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/blog",
    component: BlogPage
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/hiring",
    component: HiringPage
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/terms",
    component: TermsOfService
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/contact",
    component: Contact
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/program",
    component: ProgramHubgets
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/features",
    component: Features
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    path: "/status",
    component: CurrentStatus
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
    component: _components_NotFoundPage__WEBPACK_IMPORTED_MODULE_4__["default"]
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_Footer__WEBPACK_IMPORTED_MODULE_3__["default"], null)));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppRouter);

/***/ }),

/***/ "./src/sass/styles.scss":
/*!******************************!*\
  !*** ./src/sass/styles.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./styles.scss */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/styles.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _routers_AppRouter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./routers/AppRouter */ "./src/routers/AppRouter.js");
/* harmony import */ var normalize_css_normalize_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! normalize.css/normalize.css */ "./node_modules/normalize.css/normalize.css");
/* harmony import */ var _sass_styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sass/styles.scss */ "./src/sass/styles.scss");
// install -> import -> use






// var React = require('react');
// var ReactDOM = require('react-dom');

var MyComponent = react__WEBPACK_IMPORTED_MODULE_0___default().createClass({
  displayName: "MyComponent",
  render: function render() {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, "Hello World");
  }
});
react_dom__WEBPACK_IMPORTED_MODULE_1__.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MyComponent, null), node);

// ReactDOM.render(<AppRouter />, document.getElementById('app'));
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixVQUFVO0FBQ1Y7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7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eEQsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixhQUFhO0FBQ3ZDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNs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O0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNz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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGNBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLG9CQUFvQixJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsU0FBUyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLLG9CQUFvQixNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbUhFOzs7Ozs7Ozs7OztBQzFsVFc7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUssa0NBQWtDLEtBQUs7QUFDaEc7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGVBQWU7QUFDNUU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGVBQWU7QUFDNUU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0I7QUFDbkQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELG1DQUFtQyxXQUFXLDJCQUEyQjtBQUN6RSw2QkFBNkIsV0FBVyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0JBQWdC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7V0FDQTs7Ozs7V0NsQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDMEI7QUFDTztBQUNVO0FBQ1A7QUFDUjs7QUFHNUI7QUFDQTs7QUFFQSxJQUFJbUIsV0FBVyxHQUFHbEcsd0RBQWlCLENBQUM7RUFBQW9HLFdBQUE7RUFDbEN2QyxNQUFNLEVBQUUsU0FBUkEsTUFBTUEsQ0FBQSxFQUFhO0lBQ2pCLG9CQUFPN0QsMERBQUEsY0FBSyxhQUFnQixDQUFDO0VBQy9CO0FBQ0YsQ0FBQyxDQUFDO0FBRUZpRyxzQ0FBUSxDQUFDcEMsTUFBTSxjQUFDN0QsMERBQUEsQ0FBQ2tHLFdBQVcsTUFBRSxDQUFDLEVBQUVHLElBQUksQ0FBQzs7QUFHdEMsa0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vc3JjL3Nhc3Mvc3R5bGVzLnNjc3MiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL2h1YmdldHMvLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzP2U5MDEiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2NodW5rLUhBN0RUVUszLm1qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvY29va2llL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3NldC1jb29raWUtcGFyc2VyL2xpYi9zZXQtY29va2llLmpzIiwid2VicGFjazovL2h1YmdldHMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2h1YmdldHMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL25vZGVfbW9kdWxlcy90dXJiby1zdHJlYW0vZGlzdC90dXJiby1zdHJlYW0ubWpzIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tMDEucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tMDIucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tMDMucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tMDQucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tMDUucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2ljb24tdHdpdHRlci5wbmciLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9hc3NldHMvaWNvbi13YXJuaW5nLnBuZyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vc3JjL2Fzc2V0cy9pY29uLXlvdXR1YmUucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2xvZ28taHViZ2V0cy1mb290ZXIucG5nIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXNzZXRzL2xvZ28taHViZ2V0cy5wbmciLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9jb21wb25lbnRzL0ZhY2lsaXRpZXNVc2VyLmpzIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvY29tcG9uZW50cy9Gb290ZXIuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9jb21wb25lbnRzL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vc3JjL2NvbXBvbmVudHMvSG9tZVBhZ2UuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9jb21wb25lbnRzL01haW5IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9jb21wb25lbnRzL05vdEZvdW5kUGFnZS5qcyIsIndlYnBhY2s6Ly9odWJnZXRzLy4vc3JjL2NvbXBvbmVudHMvUmVnaXN0ZXJVc2VyLmpzIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvcm91dGVycy9BcHBSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vaHViZ2V0cy8uL3NyYy9zYXNzL3N0eWxlcy5zY3NzPzE4ZmUiLCJ3ZWJwYWNrOi8vaHViZ2V0cy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9odWJnZXRzL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2h1YmdldHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2h1YmdldHMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9odWJnZXRzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaHViZ2V0cy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2h1YmdldHMvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9odWJnZXRzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2h1YmdldHMvd2VicGFjay9ydW50aW1lL25vbmNlIiwid2VicGFjazovL2h1YmdldHMvLi9zcmMvYXBwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyohIG5vcm1hbGl6ZS5jc3MgdjguMC4xIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xuLyogRG9jdW1lbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxuICovXG5odG1sIHtcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XG4gIC8qIDEgKi9cbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xuICAvKiAyICovIH1cblxuLyogU2VjdGlvbnNcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cbiAqL1xuYm9keSB7XG4gIG1hcmdpbjogMDsgfVxuXG4vKipcbiAqIFJlbmRlciB0aGUgXFxgbWFpblxcYCBlbGVtZW50IGNvbnNpc3RlbnRseSBpbiBJRS5cbiAqL1xubWFpbiB7XG4gIGRpc3BsYXk6IGJsb2NrOyB9XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgZm9udCBzaXplIGFuZCBtYXJnaW4gb24gXFxgaDFcXGAgZWxlbWVudHMgd2l0aGluIFxcYHNlY3Rpb25cXGAgYW5kXG4gKiBcXGBhcnRpY2xlXFxgIGNvbnRleHRzIGluIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaS5cbiAqL1xuaDEge1xuICBmb250LXNpemU6IDJlbTtcbiAgbWFyZ2luOiAwLjY3ZW0gMDsgfVxuXG4vKiBHcm91cGluZyBjb250ZW50XG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBGaXJlZm94LlxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXG4gKi9cbmhyIHtcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XG4gIC8qIDEgKi9cbiAgaGVpZ2h0OiAwO1xuICAvKiAxICovXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxuICogMi4gQ29ycmVjdCB0aGUgb2RkIFxcYGVtXFxgIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cbiAqL1xucHJlIHtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlO1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMWVtO1xuICAvKiAyICovIH1cblxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgZ3JheSBiYWNrZ3JvdW5kIG9uIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cbiAqL1xuYSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XG5cbi8qKlxuICogMS4gUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1Ny1cbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXG4gKi9cbmFiYnJbdGl0bGVdIHtcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTtcbiAgLyogMSAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgLyogMiAqL1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXG4gKi9cbmIsXG5zdHJvbmcge1xuICBmb250LXdlaWdodDogYm9sZGVyOyB9XG5cbi8qKlxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBcXGBlbVxcYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXG4gKi9cbmNvZGUsXG5rYmQsXG5zYW1wIHtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlO1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMWVtO1xuICAvKiAyICovIH1cblxuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiAqL1xuc21hbGwge1xuICBmb250LXNpemU6IDgwJTsgfVxuXG4vKipcbiAqIFByZXZlbnQgXFxgc3ViXFxgIGFuZCBcXGBzdXBcXGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluXG4gKiBhbGwgYnJvd3NlcnMuXG4gKi9cbnN1YixcbnN1cCB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cblxuc3ViIHtcbiAgYm90dG9tOiAtMC4yNWVtOyB9XG5cbnN1cCB7XG4gIHRvcDogLTAuNWVtOyB9XG5cbi8qIEVtYmVkZGVkIGNvbnRlbnRcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXG4gKi9cbmltZyB7XG4gIGJvcmRlci1zdHlsZTogbm9uZTsgfVxuXG4vKiBGb3Jtc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXG4gKi9cbmJ1dHRvbixcbmlucHV0LFxub3B0Z3JvdXAsXG5zZWxlY3QsXG50ZXh0YXJlYSB7XG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuICAvKiAxICovXG4gIGZvbnQtc2l6ZTogMTAwJTtcbiAgLyogMSAqL1xuICBsaW5lLWhlaWdodDogMS4xNTtcbiAgLyogMSAqL1xuICBtYXJnaW46IDA7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cbiAqL1xuYnV0dG9uLFxuaW5wdXQge1xuICAvKiAxICovXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXG4gKiAxLiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEZpcmVmb3guXG4gKi9cbmJ1dHRvbixcbnNlbGVjdCB7XG4gIC8qIDEgKi9cbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7IH1cblxuLyoqXG4gKiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuICovXG5idXR0b24sXG5bdHlwZT1cImJ1dHRvblwiXSxcblt0eXBlPVwicmVzZXRcIl0sXG5bdHlwZT1cInN1Ym1pdFwiXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cbiAqL1xuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJidXR0b25cIl06Oi1tb3otZm9jdXMtaW5uZXIsXG5bdHlwZT1cInJlc2V0XCJdOjotbW96LWZvY3VzLWlubmVyLFxuW3R5cGU9XCJzdWJtaXRcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xuICBib3JkZXItc3R5bGU6IG5vbmU7XG4gIHBhZGRpbmc6IDA7IH1cblxuLyoqXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXG4gKi9cbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcblt0eXBlPVwiYnV0dG9uXCJdOi1tb3otZm9jdXNyaW5nLFxuW3R5cGU9XCJyZXNldFwiXTotbW96LWZvY3VzcmluZyxcblt0eXBlPVwic3VibWl0XCJdOi1tb3otZm9jdXNyaW5nIHtcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0OyB9XG5cbi8qKlxuICogQ29ycmVjdCB0aGUgcGFkZGluZyBpbiBGaXJlZm94LlxuICovXG5maWVsZHNldCB7XG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTsgfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIHRleHQgd3JhcHBpbmcgaW4gRWRnZSBhbmQgSUUuXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIFxcYGZpZWxkc2V0XFxgIGVsZW1lbnRzIGluIElFLlxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxuICogICAgXFxgZmllbGRzZXRcXGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxuICovXG5sZWdlbmQge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAvKiAxICovXG4gIGNvbG9yOiBpbmhlcml0O1xuICAvKiAyICovXG4gIGRpc3BsYXk6IHRhYmxlO1xuICAvKiAxICovXG4gIG1heC13aWR0aDogMTAwJTtcbiAgLyogMSAqL1xuICBwYWRkaW5nOiAwO1xuICAvKiAzICovXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gIC8qIDEgKi8gfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXG4gKi9cbnByb2dyZXNzIHtcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSAxMCsuXG4gKi9cbnRleHRhcmVhIHtcbiAgb3ZlcmZsb3c6IGF1dG87IH1cblxuLyoqXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBJRSAxMC5cbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC5cbiAqL1xuW3R5cGU9XCJjaGVja2JveFwiXSxcblt0eXBlPVwicmFkaW9cIl0ge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAvKiAxICovXG4gIHBhZGRpbmc6IDA7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cbiAqL1xuW3R5cGU9XCJudW1iZXJcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXG5bdHlwZT1cIm51bWJlclwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gIGhlaWdodDogYXV0bzsgfVxuXG4vKipcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXG4gKi9cblt0eXBlPVwic2VhcmNoXCJdIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG4gIC8qIDEgKi9cbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XG4gIC8qIDIgKi8gfVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cbiAqL1xuW3R5cGU9XCJzZWFyY2hcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7IH1cblxuLyoqXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuICogMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBcXGBpbmhlcml0XFxgIGluIFNhZmFyaS5cbiAqL1xuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xuICAvKiAxICovXG4gIGZvbnQ6IGluaGVyaXQ7XG4gIC8qIDIgKi8gfVxuXG4vKiBJbnRlcmFjdGl2ZVxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxuICovXG5kZXRhaWxzIHtcbiAgZGlzcGxheTogYmxvY2s7IH1cblxuLypcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIGFsbCBicm93c2Vycy5cbiAqL1xuc3VtbWFyeSB7XG4gIGRpc3BsYXk6IGxpc3QtaXRlbTsgfVxuXG4vKiBNaXNjXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLyoqXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXG4gKi9cbnRlbXBsYXRlIHtcbiAgZGlzcGxheTogbm9uZTsgfVxuXG4vKipcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwLlxuICovXG5baGlkZGVuXSB7XG4gIGRpc3BsYXk6IG5vbmU7IH1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSwyRUFBQTtBQUVBOytFQUErRTtBQUcvRTs7O0VBQ0U7QUFJRjtFQUNFLGlCQUFpQjtFQUFFLE1BQUE7RUFDbkIsOEJBQThCO0VBQUUsTUFBQSxFQUFPOztBQUd6QzsrRUFEK0U7QUFJL0U7O0VBREU7QUFLRjtFQUNFLFNBQVMsRUFBQTs7QUFHWDs7RUFIRTtBQU9GO0VBQ0UsY0FBYyxFQUFBOztBQUdoQjs7O0VBSkU7QUFTRjtFQUNFLGNBQWM7RUFDZCxnQkFBZ0IsRUFBQTs7QUFHbEI7K0VBUitFO0FBVy9FOzs7RUFQRTtBQVlGO0VBQ0UsdUJBQXVCO0VBQUUsTUFBQTtFQUN6QixTQUFTO0VBQUUsTUFBQTtFQUNYLGlCQUFpQjtFQUFFLE1BQUEsRUFBTzs7QUFHNUI7OztFQU5FO0FBV0Y7RUFDRSxpQ0FBaUM7RUFBRSxNQUFBO0VBQ25DLGNBQWM7RUFBRSxNQUFBLEVBQU87O0FBR3pCOytFQVIrRTtBQVcvRTs7RUFSRTtBQVlGO0VBQ0UsNkJBQTZCLEVBQUE7O0FBRy9COzs7RUFURTtBQWNGO0VBQ0UsbUJBQW1CO0VBQUUsTUFBQTtFQUNyQiwwQkFBMEI7RUFBRSxNQUFBO0VBQzVCLGlDQUFpQztFQUFFLE1BQUEsRUFBTzs7QUFHNUM7O0VBVEU7QUFhRjs7RUFFRSxtQkFBbUIsRUFBQTs7QUFHckI7OztFQVZFO0FBZUY7OztFQUdFLGlDQUFpQztFQUFFLE1BQUE7RUFDbkMsY0FBYztFQUFFLE1BQUEsRUFBTzs7QUFHekI7O0VBWEU7QUFlRjtFQUNFLGNBQWMsRUFBQTs7QUFHaEI7OztFQVpFO0FBaUJGOztFQUVFLGNBQWM7RUFDZCxjQUFjO0VBQ2Qsa0JBQWtCO0VBQ2xCLHdCQUF3QixFQUFBOztBQUcxQjtFQUNFLGVBQWUsRUFBQTs7QUFHakI7RUFDRSxXQUFXLEVBQUE7O0FBR2I7K0VBbEIrRTtBQXFCL0U7O0VBbEJFO0FBc0JGO0VBQ0Usa0JBQWtCLEVBQUE7O0FBR3BCOytFQXJCK0U7QUF3Qi9FOzs7RUFwQkU7QUF5QkY7Ozs7O0VBS0Usb0JBQW9CO0VBQUUsTUFBQTtFQUN0QixlQUFlO0VBQUUsTUFBQTtFQUNqQixpQkFBaUI7RUFBRSxNQUFBO0VBQ25CLFNBQVM7RUFBRSxNQUFBLEVBQU87O0FBR3BCOzs7RUFsQkU7QUF1QkY7O0VBQ1EsTUFBQTtFQUNOLGlCQUFpQixFQUFBOztBQUduQjs7O0VBbkJFO0FBd0JGOztFQUNTLE1BQUE7RUFDUCxvQkFBb0IsRUFBQTs7QUFHdEI7O0VBckJFO0FBeUJGOzs7O0VBSUUsMEJBQTBCLEVBQUE7O0FBRzVCOztFQXZCRTtBQTJCRjs7OztFQUlFLGtCQUFrQjtFQUNsQixVQUFVLEVBQUE7O0FBR1o7O0VBekJFO0FBNkJGOzs7O0VBSUUsOEJBQThCLEVBQUE7O0FBR2hDOztFQTNCRTtBQStCRjtFQUNFLDhCQUE4QixFQUFBOztBQUdoQzs7Ozs7RUExQkU7QUFpQ0Y7RUFDRSxzQkFBc0I7RUFBRSxNQUFBO0VBQ3hCLGNBQWM7RUFBRSxNQUFBO0VBQ2hCLGNBQWM7RUFBRSxNQUFBO0VBQ2hCLGVBQWU7RUFBRSxNQUFBO0VBQ2pCLFVBQVU7RUFBRSxNQUFBO0VBQ1osbUJBQW1CO0VBQUUsTUFBQSxFQUFPOztBQUc5Qjs7RUF6QkU7QUE2QkY7RUFDRSx3QkFBd0IsRUFBQTs7QUFHMUI7O0VBM0JFO0FBK0JGO0VBQ0UsY0FBYyxFQUFBOztBQUdoQjs7O0VBNUJFO0FBQ0Y7O0VBa0NFLHNCQUFzQjtFQUFFLE1BQUE7RUFDeEIsVUFBVTtFQUFFLE1BQUEsRUFBTzs7QUFHckI7O0VBN0JFO0FBQ0Y7O0VBa0NFLFlBQVksRUFBQTs7QUFHZDs7O0VBOUJFO0FBQ0Y7RUFtQ0UsNkJBQTZCO0VBQUUsTUFBQTtFQUMvQixvQkFBb0I7RUFBRSxNQUFBLEVBQU87O0FBRy9COztFQS9CRTtBQUNGO0VBbUNFLHdCQUF3QixFQUFBOztBQUcxQjs7O0VBaENFO0FBcUNGO0VBQ0UsMEJBQTBCO0VBQUUsTUFBQTtFQUM1QixhQUFhO0VBQUUsTUFBQSxFQUFPOztBQUd4QjsrRUFsQytFO0FBcUMvRTs7RUFsQ0U7QUFzQ0Y7RUFDRSxjQUFjLEVBQUE7O0FBR2hCOztFQXBDRTtBQXdDRjtFQUNFLGtCQUFrQixFQUFBOztBQUdwQjsrRUF2QytFO0FBMEMvRTs7RUF2Q0U7QUEyQ0Y7RUFDRSxhQUFhLEVBQUE7O0FBR2Y7O0VBekNFO0FBQ0Y7RUE2Q0UsYUFBYSxFQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qISBub3JtYWxpemUuY3NzIHY4LjAuMSB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG5cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbiAqL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbn1cXG5cXG4vKiBTZWN0aW9uc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZW5kZXIgdGhlIGBtYWluYCBlbGVtZW50IGNvbnNpc3RlbnRseSBpbiBJRS5cXG4gKi9cXG5cXG5tYWluIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXFxuICogYGFydGljbGVgIGNvbnRleHRzIGluIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMC42N2VtIDA7XFxufVxcblxcbi8qIEdyb3VwaW5nIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3guXFxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXFxuICovXFxuXFxuaHIge1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIDEgKi9cXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxucHJlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cXG59XFxuXFxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgZ3JheSBiYWNrZ3JvdW5kIG9uIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cXG4gKi9cXG5cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4vKipcXG4gKiAxLiBSZW1vdmUgdGhlIGJvdHRvbSBib3JkZXIgaW4gQ2hyb21lIDU3LVxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTsgLyogMSAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IC8qIDIgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmNvZGUsXFxua2JkLFxcbnNhbXAge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLyoqXFxuICogUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluXFxuICogYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKiBFbWJlZGRlZCBjb250ZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGJvcmRlciBvbiBpbWFnZXMgaW5zaWRlIGxpbmtzIGluIElFIDEwLlxcbiAqL1xcblxcbmltZyB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxufVxcblxcbi8qIEZvcm1zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0IHsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxcbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHsgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLyoqXFxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxcbiAqL1xcblxcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgcGFkZGluZyBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmZpZWxkc2V0IHtcXG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUuXFxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxcbiAqICAgIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmxlZ2VuZCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgZGlzcGxheTogdGFibGU7IC8qIDEgKi9cXG4gIG1heC13aWR0aDogMTAwJTsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDsgLyogMSAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAqL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSAxMCsuXFxuICovXFxuXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC5cXG4gKi9cXG5cXG5bdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG5bdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKiBJbnRlcmFjdGl2ZVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxcbiAqL1xcblxcbmRldGFpbHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKiBNaXNjXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXFxuICovXFxuXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAuXFxuICovXFxuXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAqIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxuXG5odG1sIHtcbiAgZm9udC1zaXplOiA2Mi41JTsgfVxuXG5ib2R5IHtcbiAgZm9udC1mYW1pbHk6IFJhbGV3YXksIExhdG8sIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gIGZvbnQtc2l6ZTogMS42cmVtO1xuICBiYWNrZ3JvdW5kOiAjY2VlM2YxOyB9XG5cbmJ1dHRvbiB7XG4gIGN1cnNvcjogcG9pbnRlcjsgfVxuXG5idXR0b246ZGlzYWJsZWQge1xuICBjdXJzb3I6IGRlZmF1bHQ7IH1cblxuLmNvbnRlbnQtY29udGFpbmVyIHtcbiAgbWFyZ2luOiAwIGF1dG87XG4gIG1heC13aWR0aDogMTE1cmVtOyB9XG5cbmhlYWRlciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgYmFja2dyb3VuZDogd2hpdGU7XG4gIHBhZGRpbmc6IDEuNnJlbSAwIDEuMnJlbSAwO1xuICBib3gtc2hhZG93OiAwIDFweCA1cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTsgfVxuICBoZWFkZXIgLmxvZ28ge1xuICAgIHBhZGRpbmctbGVmdDogNC44cmVtOyB9XG5cbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDVyZW0pIHtcbiAgaGVhZGVyIHtcbiAgICBwYWRkaW5nOiAxLjZyZW0gMDsgfVxuICAgIGhlYWRlciAubG9nbyB7XG4gICAgICBtYXgtaGVpZ2h0OiAyMCU7XG4gICAgICBwYWRkaW5nOiAwO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyOyB9IH1cblxuLmFydGljbGVfX2NvbnRlbnQge1xuICBiYWNrZ3JvdW5kOiAjMEVBNURDO1xuICBoZWlnaHQ6IDMycmVtO1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gIC5hcnRpY2xlX19jb250ZW50IC5hcnRpY2xlX190ZXh0IHtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XG4gICAgLmFydGljbGVfX2NvbnRlbnQgLmFydGljbGVfX3RleHQgaDEge1xuICAgICAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIHBhZGRpbmc6IDAgMCAxLjJyZW0gMDsgfVxuICAgIC5hcnRpY2xlX19jb250ZW50IC5hcnRpY2xlX190ZXh0IHAge1xuICAgICAgbWFyZ2luOiAwO1xuICAgICAgY29sb3I6ICNhOWRmZjc7XG4gICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgcGFkZGluZy1ib3R0b206IDAuNnJlbTsgfVxuXG4uY29udGVudF9fYXJ0aWNsZSB7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICB3aWR0aDogNDZyZW07XG4gIHBhZGRpbmc6IDEwcmVtIDEuNnJlbSAwIDEuMnJlbTsgfVxuICAuY29udGVudF9fYXJ0aWNsZSBoNCB7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBjb2xvcjogI2ZmZjsgfVxuICAuY29udGVudF9fYXJ0aWNsZSBhcnRpY2xlIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgbWFyZ2luLWJvdHRvbTogMS4ycmVtOyB9XG4gIC5jb250ZW50X19hcnRpY2xlLS1mZWF0dXJlcyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gICAgLmNvbnRlbnRfX2FydGljbGUtLWZlYXR1cmVzIGltZyB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDEuNnJlbTsgfVxuICAgIC5jb250ZW50X19hcnRpY2xlLS1mZWF0dXJlcyBhIHtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgIGNvbG9yOiAjMEVBNURDO1xuICAgICAgbWFyZ2luOiAxLjJyZW0gMDsgfVxuXG4uaGVscCB7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjZmN2Y4O1xuICBwYWRkaW5nOiAzZW0gMDtcbiAgZm9udC1zaXplOiAxLjZyZW07IH1cbiAgLmhlbHAgaW1nIHtcbiAgICB3aWR0aDogMTUlOyB9XG4gIC5oZWxwIGRpdiB7XG4gICAgbWFyZ2luLWxlZnQ6IDEuNnJlbTsgfVxuICAuaGVscCBhIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMwRUE1REM7IH1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0NXJlbSkge1xuICAuY29udGVudF9fYXJ0aWNsZSB7XG4gICAgcGFkZGluZzogMXJlbSAwIDAgMDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9XG4gICAgLmNvbnRlbnRfX2FydGljbGUtLWZlYXR1cmVzIHtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XG4gICAgICAuY29udGVudF9fYXJ0aWNsZS0tZmVhdHVyZXMgaW1nIHtcbiAgICAgICAgd2lkdGg6IDEwNXB4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgfVxuICAuaGVscCB7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IH0gfVxuXG4uZmxleF9fc2VjdGlvbiB7XG4gIGJhY2tncm91bmQ6ICNmNmY3Zjg7XG4gIHBhZGRpbmctYm90dG9tOiAyNXJlbTtcbiAgYm94LXNoYWRvdzogMCAxcHggNXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMik7IH1cbiAgLmZsZXhfX3NlY3Rpb24tLWNvbnRlbnQge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDsgfVxuICAuZmxleF9fc2VjdGlvbiAucmVnaXN0ZXItZm9ybSB7XG4gICAgcGFkZGluZzogMTByZW0gNnJlbSA3cmVtIDZyZW07XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgYm94LXNoYWRvdzogMCAxcHggM3B4IDAuNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTsgfVxuICAuZmxleF9fc2VjdGlvbiAud3JhcHBlciB7XG4gICAgbWF4LXdpZHRoOiA5NjBweDsgfVxuICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyIGxhYmVsIHtcbiAgICAgIGNvbG9yOiAjNzA3MDcwO1xuICAgICAgZm9udC13ZWlnaHQ6IDUwMDsgfVxuICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyX19yb3cge1xuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgd2lkdGg6IDEwMCU7IH1cbiAgICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyX19yb3cgW2NsYXNzKj0nY29sLTUnXSBpbnB1dCB7XG4gICAgICAgIHdpZHRoOiAxMDAlOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXJfX2NvbC0xIHtcbiAgICAgIHdpZHRoOiA4LjMzMzMzJTsgfVxuICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyX19jb2wtMiB7XG4gICAgICB3aWR0aDogMTYuNjY2NjclOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXJfX2NvbC0zIHtcbiAgICAgIHdpZHRoOiAyNSU7IH1cbiAgICAuZmxleF9fc2VjdGlvbiAud3JhcHBlcl9fY29sLTQge1xuICAgICAgd2lkdGg6IDMzLjMzMzMzJTsgfVxuICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyX19jb2wtNSB7XG4gICAgICB3aWR0aDogNDEuNjY2NjclOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXJfX2NvbC02IHtcbiAgICAgIHdpZHRoOiA1MCU7IH1cbiAgICAuZmxleF9fc2VjdGlvbiAud3JhcHBlcl9fY29sLTcge1xuICAgICAgd2lkdGg6IDU4LjMzMzMzJTsgfVxuICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyX19jb2wtOCB7XG4gICAgICB3aWR0aDogNjYuNjY2NjclOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXJfX2NvbC05IHtcbiAgICAgIHdpZHRoOiA3NSU7IH1cbiAgICAuZmxleF9fc2VjdGlvbiAud3JhcHBlcl9fY29sLTEwIHtcbiAgICAgIHdpZHRoOiA4My4zMzMzMyU7IH1cbiAgICAuZmxleF9fc2VjdGlvbiAud3JhcHBlcl9fY29sLTExIHtcbiAgICAgIHdpZHRoOiA5MS42NjY2NyU7IH1cbiAgICAuZmxleF9fc2VjdGlvbiAud3JhcHBlcl9fY29sLTEyIHtcbiAgICAgIHdpZHRoOiAxMDAlOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXIgW2NsYXNzKj0nY29sLSddIHtcbiAgICAgIHBhZGRpbmctdG9wOiAxLjJyZW07XG4gICAgICBwYWRkaW5nLWJvdHRvbTogMC44cmVtOyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXIgaW5wdXQge1xuICAgICAgaGVpZ2h0OiAzLjJyZW07XG4gICAgICBwYWRkaW5nOiAwLjhyZW07XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGJvcmRlcjogMC41cHggc29saWQgI2NjYztcbiAgICAgIG1hcmdpbjogNHB4IDFweDtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4OyB9XG4gICAgLmZsZXhfX3NlY3Rpb24gLndyYXBwZXIgYnV0dG9uIHtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzBFQTVEQztcbiAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgICBmb250LXNpemU6IDEuNnJlbTtcbiAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICBwYWRkaW5nOiAxLjJyZW0gMy4ycmVtO1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgY29sb3I6ICNmZmY7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7IH1cbiAgICAgIC5mbGV4X19zZWN0aW9uIC53cmFwcGVyIGJ1dHRvbjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBjb2xvcjogIzBFQTVEQztcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzBFQTVEQzsgfVxuXG4uY2VudGVyLXNwYW4ge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cbiAgLmNlbnRlci1zcGFuIHNwYW4jcmVnaXN0ZXItaW1nIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDg4cHg7XG4gICAgaGVpZ2h0OiA4OHB4O1xuICAgIHRvcDogLTQwcHg7XG4gICAgbGVmdDogY2FsYyg1MCUgLSA0MHB4KTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYm94LXNoYWRvdzogMCAxcHggM3B4IDJweCByZ2JhKDAsIDAsIDAsIDAuMik7IH1cbiAgICAuY2VudGVyLXNwYW4gc3BhbiNyZWdpc3Rlci1pbWcgaW1nIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHdpZHRoOiA1NyU7XG4gICAgICB0b3A6IDE4cHg7XG4gICAgICBsZWZ0OiAxOHB4OyB9XG5cbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDVyZW0pIHtcbiAgLmZsZXhfX3NlY3Rpb24ge1xuICAgIHBhZGRpbmctYm90dG9tOiAxMHJlbTsgfVxuICAtLWNvbnRlbnQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgfVxuICAucmVnaXN0ZXItZm9ybSB7XG4gICAgbWF4LXdpZHRoOiA3MDBweDtcbiAgICBtYXJnaW46IDAgMCAzMHB4IDA7IH0gfVxuXG5pbnB1dC5lcnJvciB7XG4gIGJvcmRlcjogMC41cHggc29saWQgI2RiN2Y3ZiAhaW1wb3J0YW50O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjFkM2QzO1xuICBjb2xvcjogIzgzMjkyOTsgfVxuXG4ud3JhcHBlcl9fcm93IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XG4gIC53cmFwcGVyX19yb3cgc3BhbiNlcnJvciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJhY2tncm91bmQ6ICNkYjdmN2Y7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB0b3A6IC00cHg7XG4gICAgcmlnaHQ6IDA7XG4gICAgd2lkdGg6IDE1cmVtO1xuICAgIGhlaWdodDogMzBweDtcbiAgICBmb250LXNpemU6IDEuMXJlbTtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBwYWRkaW5nOiAwLjdyZW07IH1cbiAgLndyYXBwZXJfX3JvdyBzcGFuI2Vycm9yOmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAzMHB4O1xuICAgIHRvcDogLTRweDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogOHB4O1xuICAgIGhlaWdodDogOHB4O1xuICAgIGJvcmRlci1yaWdodDogbm9uZTtcbiAgICBib3JkZXItYm90dG9tOiBub25lO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2RiN2Y3ZjtcbiAgICBjb250ZW50OiAnJzsgfVxuXG5mb290ZXIge1xuICBiYWNrZ3JvdW5kOiAjMDg3M2EwOyB9XG4gIGZvb3RlciAuZm9vdGVyX19uYXYge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgZm9udC1zaXplOiAxLjZyZW07IH1cbiAgICBmb290ZXIgLmZvb3Rlcl9fbmF2IC5sb2dvLWZvb3RlciB7XG4gICAgICBtYXJnaW4tdG9wOiAzLjJyZW07IH1cbiAgZm9vdGVyIC5mb290ZXJfX25hdi0tbGlua3Mge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtYXJnaW46IDMuMnJlbSAwIDAgMDsgfVxuICAgIGZvb3RlciAuZm9vdGVyX19uYXYtLWxpbmtzIGg0IHtcbiAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICBjb2xvcjogd2hpdGU7IH1cbiAgICBmb290ZXIgLmZvb3Rlcl9fbmF2LS1saW5rcyBhIHtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgIGNvbG9yOiAjYTlkZmY3O1xuICAgICAgbWFyZ2luLWJvdHRvbTogMS4ycmVtOyB9XG4gICAgICBmb290ZXIgLmZvb3Rlcl9fbmF2LS1saW5rcyBhOmhvdmVyIHtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXdlaWdodDogNTAwOyB9XG4gICAgICBmb290ZXIgLmZvb3Rlcl9fbmF2LS1saW5rcyBhOmFjdGl2ZSB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XG4gICAgZm9vdGVyIC5mb290ZXJfX25hdi0tbGlua3MgLnNvY2lhbC1saW5rIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gICAgICBmb290ZXIgLmZvb3Rlcl9fbmF2LS1saW5rcyAuc29jaWFsLWxpbmsgaW1nIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwLjhyZW07IH1cbiAgICAgIGZvb3RlciAuZm9vdGVyX19uYXYtLWxpbmtzIC5zb2NpYWwtbGluayBhIHtcbiAgICAgICAgbWFyZ2luOiAxLjJyZW0gMDsgfVxuICBmb290ZXIgI2NvcHkge1xuICAgIHBhZGRpbmc6IDMuMnJlbSAwIDMuMnJlbSAzLjJyZW07XG4gICAgY29sb3I6ICNhOWRmZjc7XG4gICAgZm9udC1zaXplOiAxLjZyZW07IH1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0NXJlbSkge1xuICAuZm9vdGVyX19uYXYge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbjogMDsgfVxuICAgIC5mb290ZXJfX25hdiAubG9nby1mb290ZXIge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxuICAgIC5mb290ZXJfX25hdi0tbGlua3Mge1xuICAgICAgcGFkZGluZzogMS4ycmVtO1xuICAgICAgbWFyZ2luOiAxLjZyZW07IH0gfVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9iYXNlL19iYXNlLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2Jhc2UvX3NldHRpbmdzLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2NvbXBvbmVudHMvX2hlYWRlci5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9jb21wb25lbnRzL19ob21lcGFnZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9jb21wb25lbnRzL19yZWdpc3RlclVzZXIuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvY29tcG9uZW50cy9fZm9vdGVyLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQ0E7RUFDSSxzQkFBc0IsRUFBQTs7QUFFMUI7RUFDSSxnQkFBZ0IsRUFBQTs7QUFJcEI7RUFDSSx3REFBd0Q7RUFDeEQsaUJDQ1c7RURBWCxtQkFBbUIsRUFBQTs7QUFHdkI7RUFDSSxlQUFlLEVBQUE7O0FBR25CO0VBQ0ksZUFBZSxFQUFBOztBQUduQjtFQUNJLGNBQWM7RUFDZCxpQkFBaUIsRUFBQTs7QUV6QnJCO0VBQ0ksa0JBQWtCO0VBQ2xCLGlCQUFpQjtFQUNqQiwwQkFBNEI7RUFDNUIsNENBQTRDLEVBQUE7RUFKaEQ7SUFNUSxvQkRRUSxFQUFBOztBQ0hoQjtFQUNJO0lBQ0ksaUJBQWtCLEVBQUE7SUFEdEI7TUFHUSxlQUFlO01BQ2YsVUFBVTtNQUNWLGtCQUFrQixFQUFBLEVBQ3JCOztBQ2pCVDtFQUNJLG1CRkFVO0VFQ1YsYUFBYTtFQUNiLGFBQWE7RUFDYixtQkFBbUIsRUFBQTtFQUp2QjtJQU1RLFlBQVc7SUFDWCxrQkFBa0IsRUFBQTtJQVAxQjtNQVNZLGdCQUFnQjtNQUNoQixTQUFTO01BQ1QscUJBQXNCLEVBQUE7SUFYbEM7TUFjWSxTQUFTO01BQ1QsY0ZmUTtNRWdCUixnQkFBZ0I7TUFDaEIsc0JBQXNCLEVBQUE7O0FBTWpDO0VBQ0csb0JBQW9C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Ym94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuaHRtbCB7XFxuICAgIGZvbnQtc2l6ZTogNjIuNSU7XFxuICAgIFxcbn1cXG5cXG5ib2R5IHtcXG4gICAgZm9udC1mYW1pbHk6IFJhbGV3YXksIExhdG8sIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogJG0tc2l6ZTtcXG4gICAgYmFja2dyb3VuZDogI2NlZTNmMTtcXG59XFxuXFxuYnV0dG9uIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5idXR0b246ZGlzYWJsZWQge1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi5jb250ZW50LWNvbnRhaW5lciB7XFxuICAgIG1hcmdpbjogMCBhdXRvO1xcbiAgICBtYXgtd2lkdGg6IDExNXJlbTsgICAgXFxuXFxufVxcblwiLFwiLy9jb2xvcnNcXG4kbGlnaHQtQmx1ZTogI2E5ZGZmNztcXG4kYmx1ZTogIzBFQTVEQztcXG4kZGFyay1ibHVlOiAjMDg3M2EwO1xcbiRyZWQtZXJyb3I6ICNlYmMwYzA7XFxuJHJlZERhcmstZXJyb3I6ICNkYjdmN2Y7XFxuXFxuLy9mb250XFxuXFxuLy9zcGFjaW5nXFxuJHhzLXNpemU6IDAuOHJlbTtcXG4kcy1zaXplOiAxLjJyZW07XFxuJG0tc2l6ZTogMS42cmVtO1xcbiRsLXNpemU6IDMuMnJlbTtcXG4keGwtc2l6ZTogNC44cmVtO1xcbiRkZXNrdG9wLWJyZWFrcG9pbnQ6IDQ1cmVtO1xcblxcblxcbi8vZ3JpZFxcbiRncmlkX19jb2xzOiAxMjtcXG5cXG5cIixcImhlYWRlciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIHBhZGRpbmc6ICRtLXNpemUgMCAkcy1zaXplIDA7XFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDVweCAycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgICAubG9nbyB7XFxuICAgICAgICBwYWRkaW5nLWxlZnQ6ICR4bC1zaXplIDtcXG4gICAgfVxcbn1cXG5cXG5cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICRkZXNrdG9wLWJyZWFrcG9pbnQpIHtcXG4gICAgaGVhZGVye1xcbiAgICAgICAgcGFkZGluZzogJG0tc2l6ZSAwOyAgICAgICAgXFxuICAgICAgICAubG9nbyB7XFxuICAgICAgICAgICAgbWF4LWhlaWdodDogMjAlO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVwiLFwiLy8gQXJ0aWNsZSBjb250ZW50XFxuLmFydGljbGVfX2NvbnRlbnQge1xcbiAgICBiYWNrZ3JvdW5kOiAkYmx1ZTtcXG4gICAgaGVpZ2h0OiAzMnJlbTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgLmFydGljbGVfX3RleHQge1xcbiAgICAgICAgY29sb3I6d2hpdGU7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBoMSB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgcGFkZGluZzogMCAwICRzLXNpemUgMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGNvbG9yOiAkbGlnaHQtQmx1ZTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAwLjZyZW07XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXFxuLy9GZWF0dXJlcyBmYWNpbGl0aWVzIEh1YmdldHNcXG4gLmNvbnRlbnRfX2FydGljbGUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDQ2cmVtO1xcbiAgICBwYWRkaW5nOiAxMHJlbSAkbS1zaXplIDAgJHMtc2l6ZTtcXG4gICAgaDQge1xcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgIGNvbG9yOiAjZmZmOyAgICAgICBcXG4gICAgfVxcbiAgICBhcnRpY2xlIHtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206ICRzLXNpemU7XFxuICAgIH1cXG4gICAgJi0tZmVhdHVyZXMge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBpbWd7XFxuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAkbS1zaXplO1xcbiAgICAgICAgfVxcbiAgICAgICAgYSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lIDtcXG4gICAgICAgICAgICBjb2xvcjogJGJsdWU7XFxuICAgICAgICAgICAgbWFyZ2luOiAkcy1zaXplIDA7XFxuICAgICAgICB9ICAgICAgICBcXG5cXG4gICAgfVxcbiAgICBcXG59XFxuXFxuLmhlbHAge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y2ZjdmODtcXG4gICAgcGFkZGluZzogM2VtIDA7XFxuICAgIGZvbnQtc2l6ZTogJG0tc2l6ZTtcXG4gICAgaW1nIHtcXG4gICAgICB3aWR0aDogMTUlO1xcbiAgICB9XFxuICAgIGRpdiB7XFxuICAgIG1hcmdpbi1sZWZ0OiRtLXNpemUgIFxcbiAgICB9XFxuICAgIGEge1xcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgY29sb3I6ICRibHVlO1xcbiAgICB9XFxufVxcblxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogJGRlc2t0b3AtYnJlYWtwb2ludCkge1xcbiAgICAuY29udGVudF9fYXJ0aWNsZSB7XFxuICAgICAgICBwYWRkaW5nOiAxcmVtIDAgMCAwO1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDpjZW50ZXIgO1xcbiAgICAgICAgJi0tZmVhdHVyZXMge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICBpbWcge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTA1cHg7XFxuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAuaGVscHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICB9XFxufVwiLFwiLy9SZWdpc3RlciBzZWN0aW9uIGNvbnRlbnRcXG4uZmxleF9fc2VjdGlvbiB7XFxuICAgIGJhY2tncm91bmQ6ICNmNmY3Zjg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAyNXJlbTtcXG4gICAgYm94LXNoYWRvdzogMCAxcHggNXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAgICYtLWNvbnRlbnR7XFxuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0OyAgICAgICAgICAgXFxuICAgIH0gXFxuICAgIC5yZWdpc3Rlci1mb3JtIHtcXG4gICAgICAgIHBhZGRpbmc6IDEwcmVtIDZyZW0gN3JlbSA2cmVtO1xcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgICAgICBib3gtc2hhZG93OiAwIDFweCAzcHggMC41cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgICB9XFxuICAgIFxcbiAgICAvL2dyaWQtZm9ybVxcbiAgICAud3JhcHBlciB7XFxuICAgICAgICBtYXgtd2lkdGg6IDk2MHB4OztcXG4gICAgICAgIGxhYmVsIHtcXG4gICAgICAgIGNvbG9yOiM3MDcwNzA7XFxuICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgJl9fcm93IHtcXG4gICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlOyAgXFxuICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgICAgZmxleC13cmFwOiB3cmFwO1xcbiAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgW2NsYXNzKj0nY29sLTUnXSBpbnB1dCB7XFxuICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSAgICBcXG4gICAgICAgIEBmb3IgJGkgZnJvbSAxIHRocm91Z2ggJGdyaWRfX2NvbHMge1xcbiAgICAgICAgICAgJl9fY29sLSN7JGl9IHtcXG4gICAgICAgICAgIHdpZHRoOiAxMDAlIC8gJGdyaWRfX2NvbHMgKiRpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIFtjbGFzcyo9J2NvbC0nXSB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRzLXNpemU7XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICR4cy1zaXplO1xcbiAgICAgICAgfSAgICAgICAgXFxuICAgICAgICBpbnB1dCB7XFxuICAgICAgICAgICAgaGVpZ2h0OiAkbC1zaXplIDsgIFxcbiAgICAgICAgICAgIHBhZGRpbmc6ICR4cy1zaXplO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlOyBcXG4gICAgICAgICAgICBib3JkZXI6IDAuNXB4IHNvbGlkICNjY2M7ICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBtYXJnaW46IDRweCAxcHg7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7ICAgICAgICAgXFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgYnV0dG9uIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYmx1ZTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogJG0tc2l6ZTtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICAgICAgICAgIHBhZGRpbmc6ICRzLXNpemUgJGwtc2l6ZTtcXG4gICAgICAgICAgICBib3JkZXI6bm9uZTtcXG4gICAgICAgICAgICBjb2xvcjogI2ZmZjtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgICAgICAgICAgICAgY29sb3I6ICRibHVlO1xcbiAgICAgICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAkYmx1ZTsgXFxuICAgICAgICAgICAgfSAgICBcXG4gICAgICAgIH1cXG4gICAgfSAgXFxuICAgIFxcbn1cXG5cXG4vL2ltZyBjb250ZW50XFxuLmNlbnRlci1zcGFue1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHNwYW4jcmVnaXN0ZXItaW1nIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHdpZHRoOiA4OHB4O1xcbiAgICAgICAgaGVpZ2h0OiA4OHB4O1xcbiAgICAgICAgdG9wOiAtNDBweDtcXG4gICAgICAgIGxlZnQ6IGNhbGMoNTAlIC0gNDBweCk7XFxuICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggM3B4IDJweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAgICAgICBpbWd7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIHdpZHRoOiA1NyU7XFxuICAgICAgICAgICAgdG9wOjE4cHg7XFxuICAgICAgICAgICAgbGVmdDogMThweDtcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5cXG5cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICRkZXNrdG9wLWJyZWFrcG9pbnQpIHtcXG4gICAgICAgIC5mbGV4X19zZWN0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTByZW07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICYtLWNvbnRlbnR7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgLnJlZ2lzdGVyLWZvcm0ge1xcbiAgICAgICAgICAgIG1heC13aWR0aDogNzAwcHg7XFxuICAgICAgICAgICAgbWFyZ2luOiAwIDAgMzBweCAwO1xcbiAgICB9ICAgICAgIFxcbn1cXG5cXG4vLy9pbnB1dCB2YWxpZGF0aW9uXFxuaW5wdXQuZXJyb3Ige1xcbiAgICBib3JkZXI6IDAuNXB4IHNvbGlkICRyZWREYXJrLWVycm9yICFpbXBvcnRhbnQgO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGVuKCRyZWQtZXJyb3IsIDUlKTtcXG4gICAgY29sb3I6IGRhcmtlbigkcmVkLWVycm9yLCA1MCUpOyBcXG59XFxuLndyYXBwZXJfX3Jvd3tcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBzcGFuI2Vycm9ye1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgYmFja2dyb3VuZDokcmVkRGFyay1lcnJvcjtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgIHRvcDogLTRweDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgd2lkdGg6IDE1cmVtO1xcbiAgICAgICAgaGVpZ2h0OiAzMHB4O1xcbiAgICAgICAgZm9udC1zaXplOiAxLjFyZW07XFxuICAgICAgICBjb2xvcjogd2hpdGU7XFxuICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgcGFkZGluZzogMC43cmVtOyAgICAgICAgXFxuICAgIH1cXG4gICAgc3BhbiNlcnJvcjpiZWZvcmV7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICByaWdodDogMzBweDtcXG4gICAgICAgIHRvcDogLTRweDtcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgd2lkdGg6IDhweDtcXG4gICAgICAgIGhlaWdodDogOHB4O1xcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogbm9uZTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRyZWREYXJrLWVycm9yO1xcbiAgICAgICAgY29udGVudDogJyc7XFxuICAgIH1cXG59XFxuXCIsXCJmb290ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAkZGFyay1ibHVlO1xcbiAgICAuZm9vdGVyX19uYXYge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgIGZvbnQtc2l6ZTogJG0tc2l6ZTtcXG4gICAgICAgIC5sb2dvLWZvb3RlciB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogJGwtc2l6ZTsgICBcXG4gICAgICAgIH0gICAgICAgICAgICAgICAgIFxcbiAgICB9XFxuICAgIC5mb290ZXJfX25hdi0tbGlua3Mge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICBtYXJnaW46ICRsLXNpemUgMCAwIDA7XFxuICAgICAgICBoNCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgICAgICBjb2xvcjogd2hpdGU7ICAgICAgIFxcbiAgICAgICAgfVxcbiAgICAgICAgYSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICAgIGNvbG9yOiAkbGlnaHQtQmx1ZTtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAkcy1zaXplO1xcbiAgICAgICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICAgICAgICBjb2xvcjogd2hpdGU7XFxuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgJjphY3RpdmUge1xcbiAgICAgICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICB9ICAgICAgICAgXFxuICAgICAgICB9XFxuICAgICAgICAuc29jaWFsLWxpbmsge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgICBpbWd7XFxuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogJHhzLXNpemU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGEge1xcbiAgICAgICAgICAgICAgICBtYXJnaW46ICRzLXNpemUgMDtcXG4gICAgICAgICAgICB9ICAgICAgICAgIFxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgICNjb3B5IHtcXG4gICAgICAgIHBhZGRpbmc6ICRsLXNpemUgMCAkbC1zaXplICRsLXNpemUgO1xcbiAgICAgICAgY29sb3I6ICRsaWdodC1CbHVlO1xcbiAgICAgICAgZm9udC1zaXplOiAkbS1zaXplO1xcbiAgICB9XFxuXFxufVxcblxcblxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogJGRlc2t0b3AtYnJlYWtwb2ludCkge1xcbiAgICAuZm9vdGVyX19uYXYge1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBtYXJnaW46MDtcXG4gICAgICAgIC5sb2dvLWZvb3RlcntcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0byA7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgfVxcbiAgICAgICAgJi0tbGlua3Mge1xcbiAgICAgICAgICAgIHBhZGRpbmc6ICRzLXNpemU7XFxuICAgICAgICAgICAgbWFyZ2luOiAkbS1zaXplOyBcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5cXG5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vcm1hbGl6ZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbm9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vcm1hbGl6ZS5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbywgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICBrZXlbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICAgIGtleS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgICBcIk9iamVjdFwiXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICAgICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgaW5wdXQpIHtcbiAgICAgIGlmIChcImZvbnRcIiA9PT0gYXMpIHJldHVybiBcIlwiO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dClcbiAgICAgICAgcmV0dXJuIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0ID8gaW5wdXQgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKHRoaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gdGhpbmdcbiAgICAgICAgPyBcImBudWxsYFwiXG4gICAgICAgIDogdm9pZCAwID09PSB0aGluZ1xuICAgICAgICAgID8gXCJgdW5kZWZpbmVkYFwiXG4gICAgICAgICAgOiBcIlwiID09PSB0aGluZ1xuICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiB0aGluZyArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHRoaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gdGhpbmdcbiAgICAgICAgPyBcImBudWxsYFwiXG4gICAgICAgIDogdm9pZCAwID09PSB0aGluZ1xuICAgICAgICAgID8gXCJgdW5kZWZpbmVkYFwiXG4gICAgICAgICAgOiBcIlwiID09PSB0aGluZ1xuICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGluZ1xuICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHRoaW5nKVxuICAgICAgICAgICAgICA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiB0aGluZ1xuICAgICAgICAgICAgICAgID8gXCJgXCIgKyB0aGluZyArIFwiYFwiXG4gICAgICAgICAgICAgICAgOiAnc29tZXRoaW5nIHdpdGggdHlwZSBcIicgKyB0eXBlb2YgdGhpbmcgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIG51bGwgPT09IGRpc3BhdGNoZXIgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgSW50ZXJuYWxzID0ge1xuICAgICAgICBkOiB7XG4gICAgICAgICAgZjogbm9vcCxcbiAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGZvcm0gZWxlbWVudC4gcmVxdWVzdEZvcm1SZXNldCBtdXN0IGJlIHBhc3NlZCBhIGZvcm0gdGhhdCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBEOiBub29wLFxuICAgICAgICAgIEM6IG5vb3AsXG4gICAgICAgICAgTDogbm9vcCxcbiAgICAgICAgICBtOiBub29wLFxuICAgICAgICAgIFg6IG5vb3AsXG4gICAgICAgICAgUzogbm9vcCxcbiAgICAgICAgICBNOiBub29wXG4gICAgICAgIH0sXG4gICAgICAgIHA6IDAsXG4gICAgICAgIGZpbmRET01Ob2RlOiBudWxsXG4gICAgICB9LFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREU7XG4gICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE1hcCAmJlxuICAgICAgbnVsbCAhPSBNYXAucHJvdG90eXBlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldCAmJlxuICAgICAgbnVsbCAhPSBTZXQucHJvdG90eXBlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2gpIHx8XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlJlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIlxuICAgICAgKTtcbiAgICBleHBvcnRzLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSA9XG4gICAgICBJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIGlmIChcbiAgICAgICAgIWNvbnRhaW5lciB8fFxuICAgICAgICAoMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAgICAgOSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAgICAgMTEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSlcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiKTtcbiAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xuICAgIH07XG4gICAgZXhwb3J0cy5mbHVzaFN5bmMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBwcmV2aW91c1RyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoKChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIChJbnRlcm5hbHMucCA9IDIpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZpb3VzVHJhbnNpdGlvbiksXG4gICAgICAgICAgKEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVQcmlvcml0eSksXG4gICAgICAgICAgSW50ZXJuYWxzLmQuZigpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gUmVhY3QgY2Fubm90IGZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gYSBzY2hlZHVsZXIgdGFzayBvciBtaWNybyB0YXNrLlwiXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5wcmVjb25uZWN0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWZcbiAgICAgICAgPyBudWxsICE9IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGJlIGFuIG9iamVjdCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVGhlIG9ubHkgc3VwcG9ydGVkIG9wdGlvbiBhdCB0aGlzIHRpbWUgaXMgYGNyb3NzT3JpZ2luYCB3aGljaCBhY2NlcHRzIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbnVsbCAhPSBvcHRpb25zICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVjb25uZWN0KCk6IEV4cGVjdGVkIHRoZSBgY3Jvc3NPcmlnaW5gIG9wdGlvbiAoc2Vjb25kIGFyZ3VtZW50KSB0byBiZSBhIHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVHJ5IHJlbW92aW5nIHRoaXMgb3B0aW9uIG9yIHBhc3NpbmcgYSBzdHJpbmcgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmNyb3NzT3JpZ2luKVxuICAgICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZilcbiAgICAgICAgICApO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgKG9wdGlvbnNcbiAgICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAgICAgKG9wdGlvbnMgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zXG4gICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCkpXG4gICAgICAgICAgOiAob3B0aW9ucyA9IG51bGwpLFxuICAgICAgICBJbnRlcm5hbHMuZC5DKGhyZWYsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlZmV0Y2hETlMgPSBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBocmVmIHx8ICFocmVmKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00ucHJlZmV0Y2hETlMoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNyb3NzT3JpZ2luXCIpXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIEl0IGxvb2tzIGxpa2UgdGhlIHlvdSBhcmUgYXR0ZW1wdGluZyB0byBzZXQgYSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBmb3IgdGhpcyBETlMgbG9va3VwIGhpbnQuIEJyb3dzZXJzIGRvIG5vdCBwZXJmb3JtIEROUyBxdWVyaWVzIHVzaW5nIENPUlMgYW5kIHNldHRpbmcgdGhpcyBhdHRyaWJ1dGUgb24gdGhlIHJlc291cmNlIGhpbnQgaGFzIG5vIGVmZmVjdC4gVHJ5IGNhbGxpbmcgUmVhY3RET00ucHJlZmV0Y2hETlMoKSB3aXRoIGp1c3QgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50LCBgaHJlZmAuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIEludGVybmFscy5kLkQoaHJlZik7XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWluaXQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZlxuICAgICAgICA/IG51bGwgPT0gb3B0aW9ucyB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0KCk6IEV4cGVjdGVkIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgKHNlY29uZCkgdG8gYmUgYW4gb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHJlc291cmNlIHRvIGJlIHByZWluaXRpYWxpemVkIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJzdHlsZVwiICE9PSBvcHRpb25zLmFzICYmXG4gICAgICAgICAgICBcInNjcmlwdFwiICE9PSBvcHRpb25zLmFzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYGFzYCBwcm9wZXJ0eSBpbiB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGNvbnRhaW4gYSB2YWxpZCB2YWx1ZSBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHJlc291cmNlIHRvIGJlIHByZWluaXRpYWxpemVkIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBWYWxpZCB2YWx1ZXMgZm9yIGBhc2AgYXJlIFwic3R5bGVcIiBhbmQgXCJzY3JpcHRcIi4nLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zLmFzKVxuICAgICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZilcbiAgICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICBvcHRpb25zICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzXG4gICAgICApIHtcbiAgICAgICAgdmFyIGFzID0gb3B0aW9ucy5hcyxcbiAgICAgICAgICBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAgIGludGVncml0eSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5ID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgIFwic3R5bGVcIiA9PT0gYXNcbiAgICAgICAgICA/IEludGVybmFscy5kLlMoXG4gICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMucHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJzY3JpcHRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgIEludGVybmFscy5kLlgoaHJlZiwge1xuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlaW5pdE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogb3B0aW9ucyAmJlxuICAgICAgICAgIFwiYXNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBhc2Agb3B0aW9uIGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBpZiAoZW5jb3VudGVyZWQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0TW9kdWxlKCk6IEV4cGVjdGVkIHVwIHRvIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kLCBvcHRpb25hbGx5LCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYSB2YWxpZCBgYXNgIHByb3BlcnR5LiVzXCIsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoKGVuY291bnRlcmVkID1cbiAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIiksXG4gICAgICAgICAgZW5jb3VudGVyZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAoZW5jb3VudGVyZWQgPVxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhlbmNvdW50ZXJlZCkpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdSZWFjdERPTS5wcmVpbml0TW9kdWxlKCk6IEN1cnJlbnRseSB0aGUgb25seSBzdXBwb3J0ZWQgXCJhc1wiIHR5cGUgZm9yIHRoaXMgZnVuY3Rpb24gaXMgXCJzY3JpcHRcIiBidXQgcmVjZWl2ZWQgXCIlc1wiIGluc3RlYWQuIFRoaXMgd2FybmluZyB3YXMgZ2VuZXJhdGVkIGZvciBgaHJlZmAgXCIlc1wiLiBJbiB0aGUgZnV0dXJlIG90aGVyIG1vZHVsZSB0eXBlcyB3aWxsIGJlIHN1cHBvcnRlZCwgYWxpZ25pbmcgd2l0aCB0aGUgaW1wb3J0LWF0dHJpYnV0ZXMgcHJvcG9zYWwuIExlYXJuIG1vcmUgaGVyZTogKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWltcG9ydC1hdHRyaWJ1dGVzKScsXG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWQsXG4gICAgICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBudWxsICE9PSBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT0gb3B0aW9ucy5hcyB8fCBcInNjcmlwdFwiID09PSBvcHRpb25zLmFzKVxuICAgICAgICAgICAgKGVuY291bnRlcmVkID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIEludGVybmFscy5kLk0oaHJlZiwge1xuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBlbmNvdW50ZXJlZCxcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBub25jZTpcbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIG51bGwgPT0gb3B0aW9ucyAmJiBJbnRlcm5hbHMuZC5NKGhyZWYpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlbmNvdW50ZXJlZCA9IFwiXCI7XG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikgfHxcbiAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgXCIgVGhlIGBocmVmYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgK1xuICAgICAgICAgIFwiLlwiKTtcbiAgICAgIG51bGwgPT0gb3B0aW9ucyB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICA/IChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zKSArXG4gICAgICAgICAgICBcIi5cIilcbiAgICAgICAgOiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgb3B0aW9ucy5hcykgfHxcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBlbmNvdW50ZXJlZCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdSZWFjdERPTS5wcmVsb2FkKCk6IEV4cGVjdGVkIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IHZhbGlkIGZvciBhIGA8bGluayByZWw9XCJwcmVsb2FkXCIgYXM9XCIuLi5cIiAvPmAgdGFnLiVzJyxcbiAgICAgICAgICBlbmNvdW50ZXJlZFxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJlxuICAgICAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzXG4gICAgICApIHtcbiAgICAgICAgZW5jb3VudGVyZWQgPSBvcHRpb25zLmFzO1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgIGVuY291bnRlcmVkLFxuICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgKTtcbiAgICAgICAgSW50ZXJuYWxzLmQuTChocmVmLCBlbmNvdW50ZXJlZCwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUgOiB2b2lkIDAsXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICA/IG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgaW1hZ2VTcmNTZXQ6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgICA/IG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgaW1hZ2VTaXplczpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU2l6ZXNcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmltYWdlU2l6ZXNcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgbWVkaWE6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm1lZGlhID8gb3B0aW9ucy5tZWRpYSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlbG9hZE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogb3B0aW9ucyAmJlxuICAgICAgICAgIFwiYXNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBlbmNvdW50ZXJlZCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdSZWFjdERPTS5wcmVsb2FkTW9kdWxlKCk6IEV4cGVjdGVkIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kLCBvcHRpb25hbGx5LCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwibW9kdWxlcHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIChvcHRpb25zXG4gICAgICAgICAgPyAoKGVuY291bnRlcmVkID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBJbnRlcm5hbHMuZC5tKGhyZWYsIHtcbiAgICAgICAgICAgICAgYXM6XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hc1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmFzXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGVuY291bnRlcmVkLFxuICAgICAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBJbnRlcm5hbHMuZC5tKGhyZWYpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucmVxdWVzdEZvcm1SZXNldCA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICBJbnRlcm5hbHMuZC5yKGZvcm0pO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VGb3JtU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMC4wXCI7XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjIuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbi8vIGxpYi9yb3V0ZXIvaGlzdG9yeS50c1xudmFyIEFjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEFjdGlvbjIpID0+IHtcbiAgQWN0aW9uMltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIEFjdGlvbjJbXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIEFjdGlvbjJbXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG4gIHJldHVybiBBY3Rpb24yO1xufSkoQWN0aW9uIHx8IHt9KTtcbnZhciBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllcztcbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChcbiAgICAoZW50cnksIGluZGV4MikgPT4gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgICBlbnRyeSxcbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSxcbiAgICAgIGluZGV4MiA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdm9pZCAwXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYyKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmMixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYyKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cyLmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93MiwgdG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cyLmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzIsIHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cyLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmMiA9IFwiXCI7XG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93Mi5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYyID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZjIgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbiwgdG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGN1cnJlbnQsIHRvLCBzdGF0ZSA9IG51bGwsIGtleSkge1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4udHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvLFxuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aCh7XG4gIHBhdGhuYW1lID0gXCIvXCIsXG4gIHNlYXJjaCA9IFwiXCIsXG4gIGhhc2ggPSBcIlwiXG59KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHt9O1xuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5mdW5jdGlvbiBnZXRVcmxCYXNlZEhpc3RvcnkoZ2V0TG9jYXRpb24sIGNyZWF0ZUhyZWYyLCB2YWxpZGF0ZUxvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgd2luZG93OiB3aW5kb3cyID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Mi5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHsgaWR4OiBudWxsIH07XG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB3aW5kb3cyLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2UyKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cyLmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCIgPyB3aW5kb3cyLmxvY2F0aW9uLm9yaWdpbiA6IHdpbmRvdzIubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZjIgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIGhyZWYyID0gaHJlZjIucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBiYXNlLFxuICAgICAgYE5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiAke2hyZWYyfWBcbiAgICApO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYyLCBiYXNlKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cyLnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZjIod2luZG93MiwgdG8pO1xuICAgIH0sXG4gICAgY3JlYXRlVVJMLFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgdXJsID0gY3JlYXRlVVJMKHRvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICAgICAgaGFzaDogdXJsLmhhc2hcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgIGdvKG4pIHtcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbi8vIGxpYi9yb3V0ZXIvdXRpbHMudHNcbnZhciBpbW11dGFibGVSb3V0ZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCJcbl0pO1xuZnVuY3Rpb24gaXNJbmRleFJvdXRlKHJvdXRlKSB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBwYXJlbnRQYXRoID0gW10sIG1hbmlmZXN0ID0ge30pIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBTdHJpbmcoaW5kZXgpXTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFtYW5pZmVzdFtpZF0sXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzYFxuICAgICk7XG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gaW5kZXhSb3V0ZTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGUgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlKSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICB0cmVlUGF0aCxcbiAgICAgICAgICBtYW5pZmVzdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSA9IFwiL1wiKSB7XG4gIHJldHVybiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSwgYWxsb3dQYXJ0aWFsKSB7XG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGRlY29kZWQgPSBkZWNvZGVQYXRoKHBhdGhuYW1lKTtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgZGVjb2RlZCxcbiAgICAgIGFsbG93UGFydGlhbFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtYXRjaCwgbG9hZGVyRGF0YSkge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSxcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZVxuICB9O1xufVxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzID0gW10sIHBhcmVudHNNZXRhID0gW10sIHBhcmVudFBhdGggPSBcIlwiKSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAocm91dGUsIGluZGV4LCByZWxhdGl2ZVBhdGgpID0+IHtcbiAgICBsZXQgbWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoID09PSB2b2lkIDAgPyByb3V0ZS5wYXRoIHx8IFwiXCIgOiByZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksXG4gICAgICAgIGBBYnNvbHV0ZSByb3V0ZSBwYXRoIFwiJHttZXRhLnJlbGF0aXZlUGF0aH1cIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICFyb3V0ZS5wYXRoPy5pbmNsdWRlcyhcIj9cIikpIHtcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBleHBsb2RlZCBvZiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyb3V0ZS5wYXRoKSkge1xuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcbiAgbGV0IHJlcXVpcmVkID0gZmlyc3QucmVwbGFjZSgvXFw/JC8sIFwiXCIpO1xuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXN1bHQucHVzaChcbiAgICAuLi5yZXN0RXhwbG9kZWQubWFwKFxuICAgICAgKHN1YnBhdGgpID0+IHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lm1hcChcbiAgICAoZXhwbG9kZWQpID0+IHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KFxuICAgIChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgIGEucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgKVxuICApO1xufVxudmFyIHBhcmFtUmUgPSAvXjpbXFx3LV0rJC87XG52YXIgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG52YXIgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbnZhciBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG52YXIgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG52YXIgc3BsYXRQZW5hbHR5ID0gLTI7XG52YXIgaXNTcGxhdCA9IChzKSA9PiBzID09PSBcIipcIjtcbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcigocykgPT4gIWlzU3BsYXQocykpLnJlZHVjZShcbiAgICAoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgIGluaXRpYWxTY29yZVxuICApO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgPyAoXG4gICAgLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgKSA6IChcbiAgICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSkge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuICAgIGlmICghbWF0Y2ggJiYgZW5kICYmIGFsbG93UGFydGlhbCAmJiAhcm91dGVzTWV0YVtyb3V0ZXNNZXRhLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4KSB7XG4gICAgICBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLFxuICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGVcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChvcmlnaW5hbFBhdGgsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG4gIGNvbnN0IHN0cmluZ2lmeSA9IChwKSA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbXNbc3Rhcl0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zID0gY29tcGlsZWRQYXJhbXMucmVkdWNlKFxuICAgIChtZW1vMiwgeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWwgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aCkucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICAgIGlmIChpc09wdGlvbmFsICYmICF2YWx1ZSkge1xuICAgICAgICBtZW1vMltwYXJhbU5hbWVdID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9ICh2YWx1ZSB8fCBcIlwiKS5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW8yO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLCBlbmQgPSB0cnVlKSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKS5yZXBsYWNlKC9bXFxcXC4qK14ke318KClbXFxdXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKFxuICAgIC9cXC86KFtcXHctXSspKFxcPyk/L2csXG4gICAgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgcGFyYW1zLnB1c2goeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbCB9KTtcbiAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICB9XG4gICk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lOiBcIipcIiB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjtcbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCJcXFxcLyokXCI7XG4gIH0gZWxzZSBpZiAocGF0aCAhPT0gXCJcIiAmJiBwYXRoICE9PSBcIi9cIikge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICB9XG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB2b2lkIDAgOiBcImlcIik7XG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBhdGgodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCIvXCIpLm1hcCgodikgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL1xcLy9nLCBcIiUyRlwiKSkuam9pbihcIi9cIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSBVUkwgcGF0aCBcIiR7dmFsdWV9XCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpID8gYmFzZW5hbWUubGVuZ3RoIC0gMSA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICBwYXRoXG4gICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmA7XG59XG5mdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PiBpbmRleCA9PT0gMCB8fCBtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKFxuICAgIChtYXRjaCwgaWR4KSA9PiBpZHggPT09IHBhdGhNYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID0gKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG52YXIgam9pblBhdGhzID0gKHBhdGhzKSA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcbnZhciBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZSkgPT4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbnZhciBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoKSA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG52YXIgbm9ybWFsaXplSGFzaCA9IChoYXNoKSA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbnZhciBEYXRhV2l0aFJlc3BvbnNlSW5pdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGF0YTIsIGluaXQpIHtcbiAgICB0aGlzLnR5cGUgPSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTI7XG4gICAgdGhpcy5pbml0ID0gaW5pdCB8fCBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gZGF0YShkYXRhMiwgaW5pdCkge1xuICByZXR1cm4gbmV3IERhdGFXaXRoUmVzcG9uc2VJbml0KFxuICAgIGRhdGEyLFxuICAgIHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXRcbiAgKTtcbn1cbnZhciByZWRpcmVjdCA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LCBoZWFkZXJzIH0pO1xufTtcbnZhciByZWRpcmVjdERvY3VtZW50ID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciByZXBsYWNlID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVwbGFjZVwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgRXJyb3JSZXNwb25zZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIsIGludGVybmFsID0gZmFsc2UpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMi50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGEyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikge1xuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XG59XG5cbi8vIGxpYi9yb3V0ZXIvcm91dGVyLnRzXG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXG4gIFwiUE9TVFwiLFxuICBcIlBVVFwiLFxuICBcIlBBVENIXCIsXG4gIFwiREVMRVRFXCJcbl07XG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1xuICBcIkdFVFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuXTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbnZhciByZWRpcmVjdFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG52YXIgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwNywgMzA4XSk7XG52YXIgSURMRV9OQVZJR0FUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdm9pZCAwLFxuICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgZm9ybURhdGE6IHZvaWQgMCxcbiAganNvbjogdm9pZCAwLFxuICB0ZXh0OiB2b2lkIDBcbn07XG52YXIgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdm9pZCAwLFxuICByZXNldDogdm9pZCAwLFxuICBsb2NhdGlvbjogdm9pZCAwXG59O1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gKHJvdXRlKSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpXG59KTtcbnZhciBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG52YXIgUmVzZXRMb2FkZXJEYXRhU3ltYm9sID0gU3ltYm9sKFwiUmVzZXRMb2FkZXJEYXRhXCIpO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGNvbnN0IGlzQnJvd3NlcjIgPSB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICBpbml0LnJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVN0cmF0ZWd5SW1wbCA9IGluaXQuZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3k7XG4gIGxldCBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbkltcGwgPSBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uO1xuICBsZXQgZnV0dXJlID0ge1xuICAgIC4uLmluaXQuZnV0dXJlXG4gIH07XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICBsZXQgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gbnVsbDtcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiA9IG51bGw7XG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsTWF0Y2hlc0lzRk9XID0gZmFsc2U7XG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwgJiYgIXBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCkge1xuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH1cbiAgaWYgKGluaXRpYWxNYXRjaGVzICYmICFpbml0Lmh5ZHJhdGlvbkRhdGEpIHtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgaW5pdGlhbE1hdGNoZXMsXG4gICAgICBkYXRhUm91dGVzLFxuICAgICAgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlKSB7XG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGxldCBpbml0aWFsaXplZDtcbiAgaWYgKCFpbml0aWFsTWF0Y2hlcykge1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBbXTtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgbnVsbCxcbiAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICApO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgaW5pdGlhbE1hdGNoZXNJc0ZPVyA9IHRydWU7XG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubGF6eSkpIHtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxvYWRlcikpIHtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIGxldCBpZHggPSBpbml0aWFsTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAgIChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuc2xpY2UoMCwgaWR4ICsgMSkuZXZlcnkoKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBsZXQgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICBsZXQgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gdm9pZCAwO1xuICBsZXQgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgaWYgKHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSgpO1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCxcbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciB2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIHJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIGNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZS50aGVuKCgpID0+IGluaXQuaGlzdG9yeS5nbyhkZWx0YSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihcIlBPUFwiIC8qIFBvcCAqLywgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcbiAgICBsZXQgdW5tb3VudGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbW91bnRlZEZldGNoZXJzID0gW107XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmZldGNoZXJzLmhhcyhrZXkpICYmICFmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIHVubW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goXG4gICAgICAoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihzdGF0ZSwge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnM6IHVubW91bnRlZEZldGNoZXJzLFxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gICAgdW5tb3VudGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIG1vdW50ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlLCB7IGZsdXNoU3luYyB9ID0ge30pIHtcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcbiAgICBsZXQgYWN0aW9uRGF0YTtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YSA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICBuZXdTdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgIG5ld1N0YXRlLmVycm9yc1xuICAgICkgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIGxldCBibG9ja2VycyA9IHN0YXRlLmJsb2NrZXJzO1xuICAgIGlmIChibG9ja2Vycy5zaXplID4gMCkge1xuICAgICAgYmxvY2tlcnMgPSBuZXcgTWFwKGJsb2NrZXJzKTtcbiAgICAgIGJsb2NrZXJzLmZvckVhY2goKF8sIGspID0+IGJsb2NrZXJzLnNldChrLCBJRExFX0JMT0NLRVIpKTtcbiAgICB9XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHwgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcbiAgICBpZiAoaW5GbGlnaHREYXRhUm91dGVzKSB7XG4gICAgICBkYXRhUm91dGVzID0gaW5GbGlnaHREYXRhUm91dGVzO1xuICAgICAgaW5GbGlnaHREYXRhUm91dGVzID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBPUFwiIC8qIFBvcCAqLykge1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQVVNIXCIgLyogUHVzaCAqLykge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi8pIHtcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfVxuICAgIGxldCB2aWV3VHJhbnNpdGlvbk9wdHM7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUE9QXCIgLyogUG9wICovKSB7XG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkKSB7XG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbG9jYXRpb24ucGF0aG5hbWVdKTtcbiAgICAgICAgYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5zZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUsIHRvUGF0aHMpO1xuICAgICAgfVxuICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIC8vIG1hdGNoZXMsIGVycm9ycywgZmV0Y2hlcnMgZ28gdGhyb3VnaCBhcy1pc1xuICAgICAgICBhY3Rpb25EYXRhLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlc1xuICAgICAgICApLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGJsb2NrZXJzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIGZsdXNoU3luYzogZmx1c2hTeW5jID09PSB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICBwZW5kaW5nQWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZD8ucmVzb2x2ZSgpO1xuICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKHRvLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaW5pdC5oaXN0b3J5LmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHRvLFxuICAgICAgb3B0cz8uZnJvbVJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuICAgIG5leHRMb2NhdGlvbiA9IHtcbiAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgIC4uLmluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pXG4gICAgfTtcbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdm9pZCAwO1xuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgIH0gZWxzZSBpZiAodXNlclJlcGxhY2UgPT09IGZhbHNlKSB7XG4gICAgfSBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHZvaWQgMDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIG5leHRMb2NhdGlvbiwge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIC8vIFNlbmQgdGhyb3VnaCB0aGUgZm9ybURhdGEgc2VyaWFsaXphdGlvbiBlcnJvciBpZiB3ZSBoYXZlIG9uZSBzbyB3ZSBjYW5cbiAgICAgIC8vIHJlbmRlciBhdCB0aGUgcmlnaHQgZXJyb3IgYm91bmRhcnkgYWZ0ZXIgd2UgbWF0Y2ggcm91dGVzXG4gICAgICBwZW5kaW5nRXJyb3I6IGVycm9yLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVwbGFjZTogb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogb3B0cyAmJiBvcHRzLnZpZXdUcmFuc2l0aW9uLFxuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXBlbmRpbmdSZXZhbGlkYXRpb25EZmQpIHtcbiAgICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuICAgIH1cbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcbiAgICBsZXQgcHJvbWlzZSA9IHBlbmRpbmdSZXZhbGlkYXRpb25EZmQucHJvbWlzZTtcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbixcbiAgICAgICAgLy8gUHJveHkgdGhyb3VnaCBhbnkgcmVuZGluZyB2aWV3IHRyYW5zaXRpb25cbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPT09IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgb3B0cykge1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlVmlld1RyYW5zaXRpb24pID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBvcHRzPy5pbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLm1hdGNoZXMgJiYgc3RhdGUubWF0Y2hlcy5sZW5ndGggPiAwICYmICFpbml0aWFsTWF0Y2hlc0lzRk9XID8gKFxuICAgICAgLy8gYG1hdGNoUm91dGVzKClgIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIGlmIHdlJ3JlIGluIGhlcmUgdmlhIGByb3V0ZXIuaW5pdGlhbGl6ZSgpYFxuICAgICAgc3RhdGUubWF0Y2hlc1xuICAgICkgOiBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGlmIChtYXRjaGVzICYmIHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCB7IGVycm9yLCBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICApO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCA9IFtcbiAgICAgICAgZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZCxcbiAgICAgICAgeyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBvcHRzLnBlbmRpbmdFcnJvciB9XG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UsIGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgaWYgKGFjdGlvblJlc3VsdC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgbGV0IFtyb3V0ZUlkLCByZXN1bHRdID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkgJiYgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSAmJiByZXN1bHQuZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICAgICAgbWF0Y2hlczogYWN0aW9uUmVzdWx0Lm1hdGNoZXMsXG4gICAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICBbcm91dGVJZF06IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF0Y2hlcyA9IGFjdGlvblJlc3VsdC5tYXRjaGVzIHx8IG1hdGNoZXM7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24pO1xuICAgICAgZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICBmb2dPZldhci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgICByZXF1ZXN0LnVybCxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzOiB1cGRhdGVkTWF0Y2hlcyB8fCBtYXRjaGVzLFxuICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIG9wdHMgPSB7fSkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0sIHsgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZSB9KTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICBib3VuZGFyeUlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHsgbm90Rm91bmRNYXRjaGVzLCBlcnJvciwgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVwbGFjZTI7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlMiA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvbjIgPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgICAgIHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpLFxuICAgICAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJlcGxhY2UyID0gbG9jYXRpb24yID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYWN0aW9uTWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIG92ZXJyaWRlTmF2aWdhdGlvbiwgc3VibWlzc2lvbiwgZmV0Y2hlclN1Ym1pc3Npb24sIHJlcGxhY2UyLCBpbml0aWFsSHlkcmF0aW9uLCBmbHVzaFN5bmMsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvdmVycmlkZU5hdmlnYXRpb24gfHwgZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbiB8fCBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xuICAgIGxldCBzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUgPSAhaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uICYmICFpbml0aWFsSHlkcmF0aW9uO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgLi4uYWN0aW9uRGF0YSAhPT0gdm9pZCAwID8geyBhY3Rpb25EYXRhIH0gOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmx1c2hTeW5jXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtib3VuZGFyeUlkXTogZGlzY292ZXJSZXN1bHQuZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIGxldCB7IGVycm9yLCBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCAmJiByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMyID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8geyBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgfSA6IG51bGwsXG4gICAgICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgICAgICAuLi51cGRhdGVkRmV0Y2hlcnMyID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICBsZXQgdXBkYXRlcyA9IHt9O1xuICAgICAgaWYgKCFpc0ZvZ09mV2FyKSB7XG4gICAgICAgIHVwZGF0ZXMubmF2aWdhdGlvbiA9IGxvYWRpbmdOYXZpZ2F0aW9uO1xuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgICAgICBpZiAoYWN0aW9uRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcy5hY3Rpb25EYXRhID0gYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlcy5mZXRjaGVycyA9IGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycyk7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdGF0ZSh1cGRhdGVzLCB7IGZsdXNoU3luYyB9KTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGFib3J0RmV0Y2hlcihyZi5rZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgoZikgPT4gYWJvcnRGZXRjaGVyKGYua2V5KSk7XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJlcXVlc3RcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChmZXRjaGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQocmVkaXJlY3QyLmtleSk7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICApO1xuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLmVycm9ycykge1xuICAgICAgZXJyb3JzID0geyAuLi5zdGF0ZS5lcnJvcnMsIC4uLmVycm9ycyB9O1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID0gdXBkYXRlZEZldGNoZXJzIHx8IGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICAgIC4uLnNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgIWlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMocmV2YWxpZGF0aW5nRmV0Y2hlcnMpIHtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaDIoa2V5LCByb3V0ZUlkLCBocmVmMiwgb3B0cykge1xuICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGhyZWYyLFxuICAgICAgcm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbm9ybWFsaXplZFBhdGggfSksXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IGhhbmRsZUZldGNoZXJBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgZmx1c2hTeW5jLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGF3YWl0IGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAgICBrZXksXG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGZsdXNoU3luYyxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG0pIHtcbiAgICAgIGlmICghbS5yb3V0ZS5hY3Rpb24gJiYgIW0ucm91dGUubGF6eSkge1xuICAgICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICAgIHJvdXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNGb2dPZldhciAmJiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgICBwYXRoLFxuICAgICAgICBmZXRjaFJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGRpc2NvdmVyUmVzdWx0LmVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IHBhdGggfSksXG4gICAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0TWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gocmVxdWVzdE1hdGNoZXMsIHBhdGgpO1xuICAgICAgICBpZiAoZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobWF0Y2gpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIHN0YXRlLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgW21hdGNoXSxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCBhY3Rpb25SZXN1bHQsIGZhbHNlLCB7XG4gICAgICAgICAgICBmZXRjaGVyU3VibWlzc2lvbjogc3VibWlzc2lvbixcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBmYWxzZSxcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgW21hdGNoLnJvdXRlLmlkLCBhY3Rpb25SZXN1bHRdXG4gICAgKTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyMiA/IGV4aXN0aW5nRmV0Y2hlcjIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICApO1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHIpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgIHJlZGlyZWN0Mi5yZXN1bHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB7IHByZXZlbnRTY3JvbGxSZXNldCB9XG4gICAgICApO1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB2b2lkIDAsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICApLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShcbiAgICAgIGtleSxcbiAgICAgIGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKSxcbiAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICApO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHN0YXRlLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgW21hdGNoXSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBrZXlcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgcmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCByZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0MiwgaXNOYXZpZ2F0aW9uLCB7XG4gICAgc3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgfSA9IHt9KSB7XG4gICAgaWYgKHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSkge1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgIGludmFyaWFudChsb2NhdGlvbiwgXCJFeHBlY3RlZCBhIExvY2F0aW9uIGhlYWRlciBvbiB0aGUgcmVkaXJlY3QgUmVzcG9uc2VcIik7XG4gICAgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaXNCcm93c2VyMikge1xuICAgICAgbGV0IGlzRG9jdW1lbnRSZWxvYWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UyKSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5hc3NpZ24obG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSA9IHJlcGxhY2UyID09PSB0cnVlIHx8IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVwbGFjZVwiKSA/IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi8gOiBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiAhZmV0Y2hlclN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24pO1xuICAgIH1cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3QyLnJlc3BvbnNlLnN0YXR1cykgJiYgYWN0aXZlU3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKGFjdGl2ZVN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdE5hdmlnYXRpb25UeXBlLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAuLi5hY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgICAgIGZvcm1BY3Rpb246IGxvY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZXNlIGZsYWdzIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwcmV2ZW50U2Nyb2xsUmVzZXQgfHwgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb24sXG4gICAgICAgIC8vIFNlbmQgZmV0Y2hlciBzdWJtaXNzaW9ucyB0aHJvdWdoIGZvciBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneSh0eXBlLCBzdGF0ZTIsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXkpIHtcbiAgICBsZXQgcmVzdWx0cztcbiAgICBsZXQgZGF0YVJlc3VsdHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgICBkYXRhU3RyYXRlZ3lJbXBsLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdGF0ZTIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1hdGNoZXNUb0xvYWQuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICBkYXRhUmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICAgIH1cbiAgICBmb3IgKGxldCBbcm91dGVJZCwgcmVzdWx0XSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHRzKSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICBkYXRhUmVzdWx0c1tyb3V0ZUlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi8sXG4gICAgICAgICAgcmVzcG9uc2U6IG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KFxuICAgICAgICAgIHJlc3VsdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlMiwgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICBsZXQgbG9hZGVyUmVzdWx0c1Byb21pc2UgPSBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHN0YXRlMixcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0c1Byb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2ggJiYgZi5jb250cm9sbGVyKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgIHN0YXRlMixcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICAgIFtmLm1hdGNoXSxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIGYua2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tmLm1hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgICByZXR1cm4geyBbZi5rZXldOiByZXN1bHQgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIFtmLmtleV06IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogZi5wYXRoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IGF3YWl0IGxvYWRlclJlc3VsdHNQcm9taXNlO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IChhd2FpdCBmZXRjaGVyUmVzdWx0c1Byb21pc2UpLnJlZHVjZShcbiAgICAgIChhY2MsIHIpID0+IE9iamVjdC5hc3NpZ24oYWNjLCByKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0sXG4gICAgICB7IGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSkpIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5kZWxldGUoa2V5KTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcXVldWVGZXRjaGVyRm9yRGVsZXRpb24oa2V5KSB7XG4gICAgbGV0IGNvdW50ID0gKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApIC0gMTtcbiAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCBjb3VudCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHVwZGF0ZWRGZXRjaGVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoZG9uZUtleXMpO1xuICAgIHJldHVybiB1cGRhdGVkRmV0Y2hlcnM7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5LCBmbikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5KSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleSwgbmV3QmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGludmFyaWFudChcbiAgICAgIGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLFxuICAgICAgYEludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiAke2Jsb2NrZXIuc3RhdGV9IC0+ICR7bmV3QmxvY2tlci5zdGF0ZX1gXG4gICAgKTtcbiAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICBibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uXG4gIH0pIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xuICAgIGxldCBbYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KTtcbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQocGF0aG5hbWUpIHtcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZSB9KTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgcmV0dXJuIHsgbm90Rm91bmRNYXRjaGVzOiBtYXRjaGVzLCByb3V0ZSwgZXJyb3IgfTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihwb3NpdGlvbnMsIGdldFBvc2l0aW9uLCBnZXRLZXkpIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5Mikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ga2V5IHx8IGxvY2F0aW9uLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uLmtleTtcbiAgfVxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMltrZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9uczIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgcGF0aG5hbWUpIHtcbiAgICBpZiAocGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgbGV0IGZvZ01hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIG1hdGNoZXM6IGZvZ01hdGNoZXMgfHwgW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtYXRjaGVzWzBdLnBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7IGFjdGl2ZTogdHJ1ZSwgbWF0Y2hlczogcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhY3RpdmU6IGZhbHNlLCBtYXRjaGVzOiBudWxsIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgcGF0aG5hbWUsIHNpZ25hbCkge1xuICAgIGlmICghcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlcyB9O1xuICAgIH1cbiAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcbiAgICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgICAgbGV0IGxvY2FsTWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCh7XG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIHBhdGg6IHBhdGhuYW1lLFxuICAgICAgICAgIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIHBhdGNoOiAocm91dGVJZCwgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICAgIGxvY2FsTWFuaWZlc3QsXG4gICAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZSwgcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChpc05vbkhNUiAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBkYXRhUm91dGVzID0gWy4uLmRhdGFSb3V0ZXNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhYm9ydGVkXCIgfTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICBpZiAobmV3TWF0Y2hlcykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlczogbmV3TWF0Y2hlcyB9O1xuICAgICAgfVxuICAgICAgbGV0IG5ld1BhcnRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgaWYgKCFuZXdQYXJ0aWFsTWF0Y2hlcyB8fCBwYXJ0aWFsTWF0Y2hlcy5sZW5ndGggPT09IG5ld1BhcnRpYWxNYXRjaGVzLmxlbmd0aCAmJiBwYXJ0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgKG0sIGkpID0+IG0ucm91dGUuaWQgPT09IG5ld1BhcnRpYWxNYXRjaGVzW2ldLnJvdXRlLmlkXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzOiBudWxsIH07XG4gICAgICB9XG4gICAgICBwYXJ0aWFsTWF0Y2hlcyA9IG5ld1BhcnRpYWxNYXRjaGVzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgbmV3Um91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIHZvaWQgMCxcbiAgICAgIG1hbmlmZXN0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwYXRjaFJvdXRlcyhyb3V0ZUlkLCBjaGlsZHJlbikge1xuICAgIGxldCBpc05vbkhNUiA9IGluRmxpZ2h0RGF0YVJvdXRlcyA9PSBudWxsO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIHBhdGNoUm91dGVzSW1wbChcbiAgICAgIHJvdXRlSWQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgKTtcbiAgICBpZiAoaXNOb25ITVIpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XG4gICAgICB1cGRhdGVTdGF0ZSh7fSk7XG4gICAgfVxuICB9XG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgZnV0dXJlKCkge1xuICAgICAgcmV0dXJuIGZ1dHVyZTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gcm91dGVyV2luZG93O1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2g6IGZldGNoMixcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiAodG8pID0+IGluaXQuaGlzdG9yeS5jcmVhdGVIcmVmKHRvKSxcbiAgICBlbmNvZGVMb2NhdGlvbjogKHRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcjogcXVldWVGZXRjaGVyRm9yRGVsZXRpb24sXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgcGF0Y2hSb3V0ZXMsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIG9wdHMpIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICBsZXQgYmFzZW5hbWUgPSAob3B0cyA/IG9wdHMuYmFzZW5hbWUgOiBudWxsKSB8fCBcIi9cIjtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBvcHRzPy5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCB7XG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgZGF0YVN0cmF0ZWd5XG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgIHJvdXRlSWQsXG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgZGF0YVN0cmF0ZWd5XG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF0Y2hcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdm9pZCAwO1xuICAgIGlmIChlcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmxvYWRlckRhdGEpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgcm91dGVNYXRjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzRGF0YVN0cmF0ZWd5UmVzdWx0KGUpICYmIGlzUmVzcG9uc2UoZS5yZXN1bHQpKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgICAgICAgIHRocm93IGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgYWN0aW9uTWF0Y2gsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBpc1JvdXRlUmVxdWVzdCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIFthY3Rpb25NYXRjaF0sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogcmVzdWx0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIilcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgIC8vIE5vdGU6IHN0YXR1c0NvZGUgKyBoZWFkZXJzIGFyZSB1bnVzZWQgaGVyZSBzaW5jZSBxdWVyeVJvdXRlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyBhY3Rpb25NYXRjaCA6IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgbGV0IGNvbnRleHQyID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29udGV4dDIsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCA/IHJlc3VsdC5zdGF0dXNDb2RlIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH0sXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLnJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30sXG4gICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuICAgIGlmIChpc1JvdXRlUmVxdWVzdCAmJiAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5KSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaCA/IFtyb3V0ZU1hdGNoXSA6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIHBlbmRpbmdBY3Rpb25SZXN1bHRbMF0pIDogbWF0Y2hlcztcbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IHJlcXVlc3RNYXRjaGVzLmZpbHRlcihcbiAgICAgIChtKSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenlcbiAgICApO1xuICAgIGlmIChtYXRjaGVzVG9Mb2FkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgLy8gQWRkIGEgbnVsbCBmb3IgYWxsIG1hdGNoZWQgcm91dGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICAgICAgbG9hZGVyRGF0YTogbWF0Y2hlcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgbSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW20ucm91dGUuaWRdOiBudWxsIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvclxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3lcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICB0cnVlLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmdcbiAgICApO1xuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0KFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yb3V0ZS5pZClcbiAgICApO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtYXRjaGVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KHR5cGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5KSB7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5LFxuICAgICAgdHlwZSxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBudWxsLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgcmVxdWVzdENvbnRleHRcbiAgICApO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgdGhyb3cgbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSAmJiBpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgY29udGV4dCwgZXJyb3IpIHtcbiAgbGV0IG5ld0NvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvclxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5mdW5jdGlvbiB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZCB3aXRob3V0IGFuIFxcYEFib3J0U2lnbmFsLnJlYXNvblxcYDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICk7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCB0bywgZnJvbVJvdXRlSWQsIHJlbGF0aXZlKSB7XG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlcztcbiAgbGV0IGFjdGl2ZVJvdXRlTWF0Y2g7XG4gIGlmIChmcm9tUm91dGVJZCkge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzKSxcbiAgICBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoKSB7XG4gICAgbGV0IG5ha2VkSW5kZXggPSBoYXNOYWtlZEluZGV4UXVlcnkocGF0aC5zZWFyY2gpO1xuICAgIGlmIChhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmICFuYWtlZEluZGV4KSB7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gICAgfSBlbHNlIGlmICghYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiBuYWtlZEluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBsZXQgaW5kZXhWYWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8ICFpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCB9O1xuICB9XG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pXG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJpbnZhbGlkLWJvZHlcIiB9KVxuICB9KTtcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSByYXdGb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIGxldCBmb3JtQWN0aW9uID0gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCk7XG4gIGlmIChvcHRzLmJvZHkgIT09IHZvaWQgMCkge1xuICAgIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyAoXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKFxuICAgICAgICAgIChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IGAke2FjY30ke25hbWV9PSR7dmFsdWV9XG5gLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKVxuICAgICAgKSA6IFN0cmluZyhvcHRzLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBsZXQganNvbiA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0ZXh0OiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgRm9ybURhdGEgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiXG4gICk7XG4gIGxldCBzZWFyY2hQYXJhbXM7XG4gIGxldCBmb3JtRGF0YTtcbiAgaWYgKG9wdHMuZm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuZm9ybURhdGE7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5ib2R5O1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHNlYXJjaFBhcmFtcyA9IG9wdHMuYm9keTtcbiAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5ID09IG51bGwpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgfVxuICB9XG4gIGxldCBzdWJtaXNzaW9uID0ge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogb3B0cyAmJiBvcHRzLmZvcm1FbmNUeXBlIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgZm9ybURhdGEsXG4gICAganNvbjogdm9pZCAwLFxuICAgIHRleHQ6IHZvaWQgMFxuICB9O1xuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICB9XG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksIHN1Ym1pc3Npb24gfTtcbn1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQsIGluY2x1ZGVCb3VuZGFyeSA9IGZhbHNlKSB7XG4gIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBpbmNsdWRlQm91bmRhcnkgPyBpbmRleCArIDEgOiBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKGhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsb2NhdGlvbiwgaW5pdGlhbEh5ZHJhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YSA6IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICBtYXRjaGVzLFxuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKVswXSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRbMF1cbiAgICApO1xuICB9XG4gIGxldCBhY3Rpb25TdGF0dXMgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5zdGF0dXNDb2RlIDogdm9pZCAwO1xuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMgPj0gNDAwO1xuICBsZXQgbmF2aWdhdGlvbk1hdGNoZXMgPSBib3VuZGFyeU1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgeyByb3V0ZSB9ID0gbWF0Y2g7XG4gICAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocm91dGUubG9hZGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybiBzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihyb3V0ZSwgc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUuZXJyb3JzKTtcbiAgICB9XG4gICAgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFJvdXRlTWF0Y2ggPSBzdGF0ZS5tYXRjaGVzW2luZGV4XTtcbiAgICBsZXQgbmV4dFJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgYWN0aW9uU3RhdHVzLFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IChcbiAgICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHx8IGN1cnJlbnRVcmwucGF0aG5hbWUgKyBjdXJyZW50VXJsLnNlYXJjaCA9PT0gbmV4dFVybC5wYXRobmFtZSArIG5leHRVcmwuc2VhcmNoIHx8IC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgICAgKVxuICAgIH0pO1xuICB9KTtcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24gfHwgIW1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBmLnBhdGgsIGJhc2VuYW1lKTtcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaGFzKGtleSkpIHtcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwge1xuICAgICAgICBjdXJyZW50VXJsLFxuICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgIGFjdGlvblN0YXR1cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cbmZ1bmN0aW9uIHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKHJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpIHtcbiAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXJvdXRlLmxvYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgaGFzRGF0YSA9IGxvYWRlckRhdGEgIT0gbnVsbCAmJiBsb2FkZXJEYXRhW3JvdXRlLmlkXSAhPT0gdm9pZCAwO1xuICBsZXQgaGFzRXJyb3IgPSBlcnJvcnMgIT0gbnVsbCAmJiBlcnJvcnNbcm91dGUuaWRdICE9PSB2b2lkIDA7XG4gIGlmICghaGFzRGF0YSAmJiBoYXNFcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxvYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIHJvdXRlLmxvYWRlci5oeWRyYXRlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICFoYXNEYXRhICYmICFoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKGN1cnJlbnRMb2FkZXJEYXRhLCBjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBpc05ldyA9IChcbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fCAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZFxuICApO1xuICBsZXQgaXNNaXNzaW5nRGF0YSA9ICFjdXJyZW50TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCk7XG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlc0ltcGwocm91dGVJZCwgY2hpbGRyZW4sIHJvdXRlc1RvVXNlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMikge1xuICBsZXQgY2hpbGRyZW5Ub1BhdGNoO1xuICBpZiAocm91dGVJZCkge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLFxuICAgICAgYE5vIHJvdXRlIGZvdW5kIHRvIHBhdGNoIGNoaWxkcmVuIGludG86IHJvdXRlSWQgPSAke3JvdXRlSWR9YFxuICAgICk7XG4gICAgaWYgKCFyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGUuY2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGVzVG9Vc2U7XG4gIH1cbiAgbGV0IHVuaXF1ZUNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgIChuZXdSb3V0ZSkgPT4gIWNoaWxkcmVuVG9QYXRjaC5zb21lKFxuICAgICAgKGV4aXN0aW5nUm91dGUpID0+IGlzU2FtZVJvdXRlKG5ld1JvdXRlLCBleGlzdGluZ1JvdXRlKVxuICAgIClcbiAgKTtcbiAgbGV0IG5ld1JvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgdW5pcXVlQ2hpbGRyZW4sXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBbcm91dGVJZCB8fCBcIl9cIiwgXCJwYXRjaFwiLCBTdHJpbmcoY2hpbGRyZW5Ub1BhdGNoPy5sZW5ndGggfHwgXCIwXCIpXSxcbiAgICBtYW5pZmVzdFxuICApO1xuICBjaGlsZHJlblRvUGF0Y2gucHVzaCguLi5uZXdSb3V0ZXMpO1xufVxuZnVuY3Rpb24gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpIHtcbiAgaWYgKFwiaWRcIiBpbiBuZXdSb3V0ZSAmJiBcImlkXCIgaW4gZXhpc3RpbmdSb3V0ZSAmJiBuZXdSb3V0ZS5pZCA9PT0gZXhpc3RpbmdSb3V0ZS5pZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghKG5ld1JvdXRlLmluZGV4ID09PSBleGlzdGluZ1JvdXRlLmluZGV4ICYmIG5ld1JvdXRlLnBhdGggPT09IGV4aXN0aW5nUm91dGUucGF0aCAmJiBuZXdSb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSBleGlzdGluZ1JvdXRlLmNhc2VTZW5zaXRpdmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoIW5ld1JvdXRlLmNoaWxkcmVuIHx8IG5ld1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKCFleGlzdGluZ1JvdXRlLmNoaWxkcmVuIHx8IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBuZXdSb3V0ZS5jaGlsZHJlbi5ldmVyeShcbiAgICAoYUNoaWxkLCBpKSA9PiBleGlzdGluZ1JvdXRlLmNoaWxkcmVuPy5zb21lKChiQ2hpbGQpID0+IGlzU2FtZVJvdXRlKGFDaGlsZCwgYkNoaWxkKSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRMYXp5Um91dGVNb2R1bGUocm91dGUsIG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0KSB7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuICBsZXQgcm91dGVVcGRhdGVzID0ge307XG4gIGZvciAobGV0IGxhenlSb3V0ZVByb3BlcnR5IGluIGxhenlSb3V0ZSkge1xuICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgbGV0IGlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCA9IHN0YXRpY1JvdXRlVmFsdWUgIT09IHZvaWQgMCAmJiAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICB3YXJuaW5nKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiB3aWxsIGJlIGlnbm9yZWQuYFxuICAgICk7XG4gICAgaWYgKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiYgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkpKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHtcbiAgICAvLyBUbyBrZWVwIHRoaW5ncyBmcmFtZXdvcmsgYWdub3N0aWMsIHdlIHVzZSB0aGUgcHJvdmlkZWQgYG1hcFJvdXRlUHJvcGVydGllc2BcbiAgICAvLyBmdW5jdGlvbiB0byBzZXQgdGhlIGZyYW1ld29yay1hd2FyZSBwcm9wZXJ0aWVzIChgZWxlbWVudGAvYGhhc0Vycm9yQm91bmRhcnlgKVxuICAgIC8vIHNpbmNlIHRoZSBsb2dpYyB3aWxsIGRpZmZlciBiZXR3ZWVuIGZyYW1ld29ya3MuXG4gICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZVRvVXBkYXRlKSxcbiAgICBsYXp5OiB2b2lkIDBcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0RGF0YVN0cmF0ZWd5KHtcbiAgbWF0Y2hlc1xufSkge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IG1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnNob3VsZExvYWQpO1xuICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXNUb0xvYWQubWFwKChtKSA9PiBtLnJlc29sdmUoKSkpO1xuICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoXG4gICAgKGFjYywgcmVzdWx0LCBpKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZF06IHJlc3VsdCB9KSxcbiAgICB7fVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgdHlwZSwgc3RhdGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXksIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCByZXF1ZXN0Q29udGV4dCkge1xuICBsZXQgbG9hZFJvdXRlRGVmaW5pdGlvbnNQcm9taXNlcyA9IG1hdGNoZXMubWFwKFxuICAgIChtKSA9PiBtLnJvdXRlLmxhenkgPyBsb2FkTGF6eVJvdXRlTW9kdWxlKG0ucm91dGUsIG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0KSA6IHZvaWQgMFxuICApO1xuICBsZXQgZHNNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG1hdGNoLCBpKSA9PiB7XG4gICAgbGV0IGxvYWRSb3V0ZVByb21pc2UgPSBsb2FkUm91dGVEZWZpbml0aW9uc1Byb21pc2VzW2ldO1xuICAgIGxldCBzaG91bGRMb2FkID0gbWF0Y2hlc1RvTG9hZC5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IHJlc29sdmUgPSBhc3luYyAoaGFuZGxlck92ZXJyaWRlKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlck92ZXJyaWRlICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiICYmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG1hdGNoLnJvdXRlLmxvYWRlcikpIHtcbiAgICAgICAgc2hvdWxkTG9hZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTG9hZCA/IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRSb3V0ZVByb21pc2UsXG4gICAgICAgIGhhbmRsZXJPdmVycmlkZSxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICkgOiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tYXRjaCxcbiAgICAgIHNob3VsZExvYWQsXG4gICAgICByZXNvbHZlXG4gICAgfTtcbiAgfSk7XG4gIGxldCByZXN1bHRzID0gYXdhaXQgZGF0YVN0cmF0ZWd5SW1wbCh7XG4gICAgbWF0Y2hlczogZHNNYXRjaGVzLFxuICAgIHJlcXVlc3QsXG4gICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICBmZXRjaGVyS2V5LFxuICAgIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0XG4gIH0pO1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRSb3V0ZURlZmluaXRpb25zUHJvbWlzZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24odHlwZSwgcmVxdWVzdCwgbWF0Y2gsIGxvYWRSb3V0ZVByb21pc2UsIGhhbmRsZXJPdmVycmlkZSwgc3RhdGljQ29udGV4dCkge1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBydW5IYW5kbGVyID0gKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIGxldCBhY3R1YWxIYW5kbGVyID0gKGN0eCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2Fubm90IGNhbGwgdGhlIGhhbmRsZXIgZm9yIGEgcm91dGUgd2hpY2ggZGVmaW5lcyBhIGJvb2xlYW4gXCIke3R5cGV9XCIgW3JvdXRlSWQ6ICR7bWF0Y2gucm91dGUuaWR9XWBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlcihcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgY29udGV4dDogc3RhdGljQ29udGV4dFxuICAgICAgICB9LFxuICAgICAgICAuLi5jdHggIT09IHZvaWQgMCA/IFtjdHhdIDogW11cbiAgICAgICk7XG4gICAgfTtcbiAgICBsZXQgaGFuZGxlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHZhbCA9IGF3YWl0IChoYW5kbGVyT3ZlcnJpZGUgPyBoYW5kbGVyT3ZlcnJpZGUoKGN0eCkgPT4gYWN0dWFsSGFuZGxlcihjdHgpKSA6IGFjdHVhbEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQ6IHZhbCB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlclByb21pc2UsIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaWYgKGxvYWRSb3V0ZVByb21pc2UpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGxldCBoYW5kbGVyRXJyb3I7XG4gICAgICAgIGxldCBbdmFsdWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIHRocm93cywgZG9uJ3QgbGV0IGl0IGltbWVkaWF0ZWx5IGJ1YmJsZSBvdXQsXG4gICAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xuICAgICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGxvYWRSb3V0ZVByb21pc2VcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxvYWRSb3V0ZVByb21pc2U7XG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIHJlc3VsdDogZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQoZGF0YVN0cmF0ZWd5UmVzdWx0KSB7XG4gIGxldCB7IHJlc3VsdCwgdHlwZSB9ID0gZGF0YVN0cmF0ZWd5UmVzdWx0O1xuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IGRhdGEyO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICBkYXRhMiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YTIgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCBlcnJvcjogZSB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEyKSxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgICBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgcmVzdWx0LmluaXQ/LnN0YXR1cyB8fCA1MDAsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHJlc3VsdC5kYXRhXG4gICAgICAgICksXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdm9pZCAwLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgZXJyb3I6IHJlc3VsdCxcbiAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5pbml0Py5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCBkYXRhOiByZXN1bHQgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QsIHJvdXRlSWQsIG1hdGNoZXMsIGJhc2VuYW1lKSB7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGludmFyaWFudChcbiAgICBsb2NhdGlvbixcbiAgICBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCJcbiAgKTtcbiAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDFcbiAgICApO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIHRyaW1tZWRNYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgY3VycmVudFVybCwgYmFzZW5hbWUpIHtcbiAgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIGxldCBub3JtYWxpemVkTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbm9ybWFsaXplZExvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIG5vcm1hbGl6ZWRMb2NhdGlvbikgOiBuZXcgVVJMKG5vcm1hbGl6ZWRMb2NhdGlvbik7XG4gICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgIGlmICh1cmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBpc1NhbWVCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsIH07XG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogZm9ybUVuY1R5cGUgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJiBzdWJtaXNzaW9uLmZvcm1EYXRhKSB7XG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBpc1N0YXRpY0hhbmRsZXIgPSBmYWxzZSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPSBmYWxzZSkge1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdm9pZCAwO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaWRdO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICBpZiAocGVuZGluZ0Vycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgZXJyb3IgPSBwZW5kaW5nRXJyb3I7XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIGlmIChza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xuICAgICAgICBlcnJvcnNbaWRdID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1N0YXRpY0hhbmRsZXIpIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSBSZXNldExvYWRlckRhdGFTeW1ib2w7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBlcnJvcnMgPSB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0Vycm9yIH07XG4gICAgbG9hZGVyRGF0YVtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMpIHtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgIG1hdGNoZXMsXG4gICAgcmVzdWx0cyxcbiAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICk7XG4gIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgbGV0IHsga2V5LCBtYXRjaCwgY29udHJvbGxlciB9ID0gcmY7XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2tleV07XG4gICAgaW52YXJpYW50KHJlc3VsdCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaD8ucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgIC4uLmVycm9ycyxcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBsb2FkZXJEYXRhLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBPYmplY3QuZW50cmllcyhuZXdMb2FkZXJEYXRhKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBSZXNldExvYWRlckRhdGFTeW1ib2wpLnJlZHVjZSgobWVyZ2VkLCBbaywgdl0pID0+IHtcbiAgICBtZXJnZWRba10gPSB2O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmICghbmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICBpZiAoIXBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgLy8gQ2xlYXIgb3V0IHByaW9yIGFjdGlvbkRhdGEgb24gZXJyb3JzXG4gICAgYWN0aW9uRGF0YToge31cbiAgfSA6IHtcbiAgICBhY3Rpb25EYXRhOiB7XG4gICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgcm91dGVJZCkge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZCA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZCgocikgPT4gci5pbmRleCB8fCAhci5wYXRoIHx8IHIucGF0aCA9PT0gXCIvXCIpIHx8IHtcbiAgICBpZDogYF9fc2hpbS1lcnJvci1yb3V0ZV9fYFxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHBhdGhuYW1lQmFzZTogXCJcIixcbiAgICAgICAgcm91dGVcbiAgICAgIH1cbiAgICBdLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywge1xuICBwYXRobmFtZSxcbiAgcm91dGVJZCxcbiAgbWV0aG9kLFxuICB0eXBlLFxuICBtZXNzYWdlXG59ID0ge30pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBZb3UgbWFkZSBhICR7bWV0aG9kfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnZhbGlkLWJvZHlcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmFibGUgdG8gZW5jb2RlIHN1Ym1pc3Npb24gYm9keVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGFuIFxcYGFjdGlvblxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICBzdGF0dXMgfHwgNTAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhyZXN1bHRzKTtcbiAgZm9yIChsZXQgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgW2tleSwgcmVzdWx0XSA9IGVudHJpZXNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHsga2V5LCByZXN1bHQgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XG4gIHJldHVybiBjcmVhdGVQYXRoKHsgLi4ucGFyc2VkUGF0aCwgaGFzaDogXCJcIiB9KTtcbn1cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYSwgYikge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gcmVzdWx0ICYmIFwicmVzdWx0XCIgaW4gcmVzdWx0ICYmIChyZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIgLyogZGF0YSAqLyB8fCByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi87XG59XG5mdW5jdGlvbiBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCAmJiBcInR5cGVcIiBpbiB2YWx1ZSAmJiBcImRhdGFcIiBpbiB2YWx1ZSAmJiBcImluaXRcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0U3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXNDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuc3RhdHVzKSAmJiByZXN1bHQuaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBzZWFyY2ggPSB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIHRleHQsIGZvcm1EYXRhLCBqc29uIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhMikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IGRhdGEyXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVlcbiAgICApO1xuICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcbiAgICAgICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnNldChrLCBuZXcgU2V0KHYgfHwgW10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlICgke2Vycm9yfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9jb21wb25lbnRzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvY29udGV4dC50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgRGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbnZhciBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xudmFyIFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcblZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbnZhciBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4pO1xuRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xudmFyIEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Bd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbnZhciBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xudmFyIFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxuICBpc0RhdGFSb3V0ZTogZmFsc2Vcbn0pO1xuUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xudmFyIFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG5cbi8vIGxpYi9ob29rcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciBFTkFCTEVfREVWX1dBUk5JTkdTID0gdHJ1ZTtcbmZ1bmN0aW9uIHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvcjogbmF2aWdhdG9yMiB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvcjIuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBkZWNvZGVQYXRoKHBhdGhuYW1lKSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxudmFyIG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gO1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgUmVhY3QyLnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQgeyBpc0RhdGFSb3V0ZSB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlVW5zdGFibGUoKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvcjogbmF2aWdhdG9yMiB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yMi5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvcjIucmVwbGFjZSA6IG5hdmlnYXRvcjIucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcjIsXG4gICAgICByb3V0ZVBhdGhuYW1lc0pzb24sXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgZGF0YVJvdXRlckNvbnRleHRcbiAgICBdXG4gICk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbnZhciBPdXRsZXRDb250ZXh0ID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gcmVzb2x2ZVRvKFxuICAgICAgdG8sXG4gICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IG5hdmlnYXRvcjogbmF2aWdhdG9yMiwgc3RhdGljOiBpc1N0YXRpYyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqP1wiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBcIiR7cGFyZW50UGF0aG5hbWV9XCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPikgYnV0IHRoZSBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIHJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cblxuUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IGAke3BhcmVudFBhdGh9LypgfVwiPi5gXG4gICAgKTtcbiAgfVxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgdGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChwYXJlbnRQYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgbGV0IHBhcmVudFNlZ21lbnRzID0gcGFyZW50UGF0aG5hbWVCYXNlLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgbGV0IHNlZ21lbnRzID0gcGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IFwiL1wiICsgc2VnbWVudHMuc2xpY2UocGFyZW50U2VnbWVudHMubGVuZ3RoKS5qb2luKFwiL1wiKTtcbiAgfVxuICBsZXQgbWF0Y2hlcyA9ICFpc1N0YXRpYyAmJiBkYXRhUm91dGVyU3RhdGUgJiYgZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMgJiYgZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMubGVuZ3RoID4gMCA/IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzIDogbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdm9pZCAwIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHZvaWQgMCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubGF6eSAhPT0gdm9pZCAwLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudCBvciBDb21wb25lbnQuIFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChcbiAgICAgIChtYXRjaCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW1xuICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgIG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IyLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXG4gICAgICAgIF0pLFxuICAgICAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW1xuICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgIG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IyLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lQmFzZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgICAgICAgXSlcbiAgICAgIH0pXG4gICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzLFxuICAgIGRhdGFSb3V0ZXJTdGF0ZSxcbiAgICBmdXR1cmVcbiAgKTtcbiAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5sb2NhdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvblR5cGU6IFwiUE9QXCIgLyogUG9wICovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJlZE1hdGNoZXNcbiAgICApO1xuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBgJHtlcnJvci5zdGF0dXN9ICR7ZXJyb3Iuc3RhdHVzVGV4dH1gIDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHsgcGFkZGluZzogXCIwLjVyZW1cIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcbiAgbGV0IGNvZGVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMnB4IDRweFwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIGRldkluZm8gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn1cIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IGNvZGVTdHlsZXMgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBjb2RlU3R5bGVzIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDNcIiwgeyBzdHlsZTogeyBmb250U3R5bGU6IFwiaXRhbGljXCIgfSB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBzdHlsZTogcHJlU3R5bGVzIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xufVxudmFyIGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbnZhciBSZW5kZXJFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDIuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgIT09IHZvaWQgMCA/IHByb3BzLmVycm9yIDogc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICAgIH1cbiAgICApKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn07XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKHsgcm91dGVDb250ZXh0LCBtYXRjaCwgY2hpbGRyZW4gfSkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb3V0ZUNvbnRleHQgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcywgcGFyZW50TWF0Y2hlcyA9IFtdLCBkYXRhUm91dGVyU3RhdGUgPSBudWxsLCBmdXR1cmUgPSBudWxsKSB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICBpZiAoIWRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhUm91dGVyU3RhdGUuZXJyb3JzKSB7XG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRNYXRjaGVzLmxlbmd0aCA9PT0gMCAmJiAhZGF0YVJvdXRlclN0YXRlLmluaXRpYWxpemVkICYmIGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuICBsZXQgZXJyb3JzID0gZGF0YVJvdXRlclN0YXRlPy5lcnJvcnM7XG4gIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkICYmIGVycm9ycz8uW20ucm91dGUuaWRdICE9PSB2b2lkIDBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGVycm9ySW5kZXggPj0gMCxcbiAgICAgIGBDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiAke09iamVjdC5rZXlzKFxuICAgICAgICBlcnJvcnNcbiAgICAgICkuam9pbihcIixcIil9YFxuICAgICk7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKVxuICAgICk7XG4gIH1cbiAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XG4gIGxldCBmYWxsYmFja0luZGV4ID0gLTE7XG4gIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xuICAgICAgaWYgKG1hdGNoLnJvdXRlLkh5ZHJhdGVGYWxsYmFjayB8fCBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkKSB7XG4gICAgICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9yczogZXJyb3JzMiB9ID0gZGF0YVJvdXRlclN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNUb1J1bkxvYWRlciA9IG1hdGNoLnJvdXRlLmxvYWRlciAmJiAhbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCkgJiYgKCFlcnJvcnMyIHx8IGVycm9yczJbbWF0Y2gucm91dGUuaWRdID09PSB2b2lkIDApO1xuICAgICAgICBpZiAobWF0Y2gucm91dGUubGF6eSB8fCBuZWVkc1RvUnVuTG9hZGVyKSB7XG4gICAgICAgICAgcmVuZGVyRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBmYWxsYmFja0luZGV4ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IFtyZW5kZXJlZE1hdGNoZXNbMF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gZmFsc2U7XG4gICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgbGV0IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgaWYgKHJlbmRlckZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHdhcm5pbmdPbmNlKFxuICAgICAgICAgICAgXCJyb3V0ZS1mYWxsYmFja1wiLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaGVzMiA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW47XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjaykge1xuICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLkNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gbWF0Y2gucm91dGUuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVuZGVyZWRSb3V0ZSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hlczIsXG4gICAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBpbmRleCA9PT0gMCkgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSZW5kZXJFcnJvckJvdW5kYXJ5LFxuICAgICAge1xuICAgICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKCksXG4gICAgICAgIHJvdXRlQ29udGV4dDogeyBvdXRsZXQ6IG51bGwsIG1hdGNoZXM6IG1hdGNoZXMyLCBpc0RhdGFSb3V0ZTogdHJ1ZSB9XG4gICAgICB9XG4gICAgKSA6IGdldENoaWxkcmVuKCk7XG4gIH0sIG51bGwpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9lbi9tYWluL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gcm91dGU7XG59XG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBpbnZhcmlhbnQoXG4gICAgdGhpc1JvdXRlLnJvdXRlLmlkLFxuICAgIGAke2hvb2tOYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuZnVuY3Rpb24gdXNlUm91dGVJZCgpIHtcbiAgcmV0dXJuIHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlUm91dGVJZFwiIC8qIFVzZVJvdXRlSWQgKi8pO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlTmF2aWdhdGlvblwiIC8qIFVzZU5hdmlnYXRpb24gKi8pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZVJldmFsaWRhdG9yXCIgLyogVXNlUmV2YWxpZGF0b3IgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSZXZhbGlkYXRvclwiIC8qIFVzZVJldmFsaWRhdG9yICovKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBhc3luYyByZXZhbGlkYXRlKCkge1xuICAgICAgICBhd2FpdCBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIHN0YXRlOiBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICB9KSxcbiAgICBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLCBzdGF0ZS5yZXZhbGlkYXRpb25dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQgeyBtYXRjaGVzLCBsb2FkZXJEYXRhIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoXG4gICAgXCJ1c2VNYXRjaGVzXCIgLyogVXNlTWF0Y2hlcyAqL1xuICApO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hlcy5tYXAoKG0pID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIGxvYWRlckRhdGEpKSxcbiAgICBbbWF0Y2hlcywgbG9hZGVyRGF0YV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIiAvKiBVc2VSb3V0ZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUFjdGlvbkRhdGFcIiAvKiBVc2VBY3Rpb25EYXRhICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGEgPyBzdGF0ZS5hY3Rpb25EYXRhW3JvdXRlSWRdIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdXNlUm91dGVFcnJvcigpIHtcbiAgbGV0IGVycm9yID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSb3V0ZUVycm9yXCIgLyogVXNlUm91dGVFcnJvciAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VSb3V0ZUVycm9yXCIgLyogVXNlUm91dGVFcnJvciAqLyk7XG4gIGlmIChlcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBzdGF0ZS5lcnJvcnM/Lltyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0Mi51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2RhdGE7XG59XG5mdW5jdGlvbiB1c2VBc3luY0Vycm9yKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdDIudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9lcnJvcjtcbn1cbnZhciBibG9ja2VySWQgPSAwO1xuZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jaykge1xuICBsZXQgeyByb3V0ZXIsIGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZUJsb2NrZXJcIiAvKiBVc2VCbG9ja2VyICovKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlQmxvY2tlclwiIC8qIFVzZUJsb2NrZXIgKi8pO1xuICBsZXQgW2Jsb2NrZXJLZXksIHNldEJsb2NrZXJLZXldID0gUmVhY3QyLnVzZVN0YXRlKFwiXCIpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIChhcmcpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygc2hvdWxkQmxvY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gISFzaG91bGRCbG9jaztcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKGFyZyk7XG4gICAgICB9XG4gICAgICBsZXQgeyBjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbiwgaGlzdG9yeUFjdGlvbiB9ID0gYXJnO1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4uY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBuZXh0TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja11cbiAgKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGtleSA9IFN0cmluZygrK2Jsb2NrZXJJZCk7XG4gICAgc2V0QmxvY2tlcktleShrZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlQmxvY2tlcihrZXkpO1xuICB9LCBbcm91dGVyXSk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyS2V5ICE9PSBcIlwiKSB7XG4gICAgICByb3V0ZXIuZ2V0QmxvY2tlcihibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb24pO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSk7XG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KSA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSA6IElETEVfQkxPQ0tFUjtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlTmF2aWdhdGVcIiAvKiBVc2VOYXZpZ2F0ZVN0YWJsZSAqLyk7XG4gIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTmF2aWdhdGVcIiAvKiBVc2VOYXZpZ2F0ZVN0YWJsZSAqLyk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdDIudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0bywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpO1xuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcm91dGVyLm5hdmlnYXRlKHRvLCB7IGZyb21Sb3V0ZUlkOiBpZCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIsIGlkXVxuICApO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG52YXIgYWxyZWFkeVdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5LCBjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvd2FybmluZ3MudHNcbnZhciBhbHJlYWR5V2FybmVkMiA9IHt9O1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uICYmICFhbHJlYWR5V2FybmVkMlttZXNzYWdlXSkge1xuICAgIGFscmVhZHlXYXJuZWQyW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL2NvbXBvbmVudHMudHN4XG52YXIgRU5BQkxFX0RFVl9XQVJOSU5HUzIgPSB0cnVlO1xuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5oYXNFcnJvckJvdW5kYXJ5IHx8IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCByb3V0ZS5lcnJvckVsZW1lbnQgIT0gbnVsbFxuICB9O1xuICBpZiAocm91dGUuQ29tcG9uZW50KSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MyKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkNvbXBvbmVudCksXG4gICAgICBDb21wb25lbnQ6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUzIpIHtcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEh5ZHJhdGVGYWxsYmFja2AgYW5kIGBoeWRyYXRlRmFsbGJhY2tFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYEh5ZHJhdGVGYWxsYmFja2Agd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUzIpIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgRXJyb3JCb3VuZGFyeWAgYW5kIGBlcnJvckVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZXJyb3JFbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5FcnJvckJvdW5kYXJ5KSxcbiAgICAgIEVycm9yQm91bmRhcnk6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cGRhdGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllczogb3B0cz8uaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHM/LmluaXRpYWxJbmRleFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEsXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25cbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxudmFyIERlZmVycmVkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoe1xuICByb3V0ZXIsXG4gIGZsdXNoU3luYzogcmVhY3REb21GbHVzaFN5bmNJbXBsXG59KSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDMudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdDMudXNlU3RhdGUoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIGxldCBbcmVuZGVyRGZkLCBzZXRSZW5kZXJEZmRdID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFtpbnRlcnJ1cHRpb24sIHNldEludGVycnVwdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QzLnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSwgeyBkZWxldGVkRmV0Y2hlcnMsIGZsdXNoU3luYywgdmlld1RyYW5zaXRpb25PcHRzIH0pID0+IHtcbiAgICAgIG5ld1N0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgZmx1c2hTeW5jID09PSBmYWxzZSB8fCByZWFjdERvbUZsdXNoU3luY0ltcGwgIT0gbnVsbCxcbiAgICAgICAgJ1lvdSBwcm92aWRlZCB0aGUgYGZsdXNoU3luY2Agb3B0aW9uIHRvIGEgcm91dGVyIHVwZGF0ZSwgYnV0IHlvdSBhcmUgbm90IHVzaW5nIHRoZSBgPFJvdXRlclByb3ZpZGVyPmAgZnJvbSBgcmVhY3Qtcm91dGVyL2RvbWAgc28gYFJlYWN0RE9NLmZsdXNoU3luYygpYCBpcyB1bmF2YWlsYWJsZS4gIFBsZWFzZSB1cGRhdGUgeW91ciBhcHAgdG8gYGltcG9ydCB7IFJvdXRlclByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LXJvdXRlci9kb21cImAgYW5kIGVuc3VyZSB5b3UgaGF2ZSBgcmVhY3QtZG9tYCBpbnN0YWxsZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHVzZSB0aGUgYGZsdXNoU3luY2Agb3B0aW9uLidcbiAgICAgICk7XG4gICAgICBsZXQgaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSA9IHJvdXRlci53aW5kb3cgIT0gbnVsbCAmJiByb3V0ZXIud2luZG93LmRvY3VtZW50ICE9IG51bGwgJiYgdHlwZW9mIHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9PSBudWxsIHx8IGlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUsXG4gICAgICAgIFwiWW91IHByb3ZpZGVkIHRoZSBgdmlld1RyYW5zaXRpb25gIG9wdGlvbiB0byBhIHJvdXRlciB1cGRhdGUsIGJ1dCB5b3UgZG8gbm90IGFwcGVhciB0byBiZSBydW5uaW5nIGluIGEgRE9NIGVudmlyb25tZW50IGFzIGB3aW5kb3cuc3RhcnRWaWV3VHJhbnNpdGlvbmAgaXMgbm90IGF2YWlsYWJsZS5cIlxuICAgICAgKTtcbiAgICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8ICFpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlKSB7XG4gICAgICAgIGlmIChyZWFjdERvbUZsdXNoU3luY0ltcGwgJiYgZmx1c2hTeW5jKSB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0LmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRSZW5kZXJEZmQodm9pZCAwKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb24odm9pZCAwKTtcbiAgICAgICAgICAgIHNldFBlbmRpbmdTdGF0ZSh2b2lkIDApO1xuICAgICAgICAgICAgc2V0VnRDb250ZXh0KHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRUcmFuc2l0aW9uKHQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgc2V0SW50ZXJydXB0aW9uKHtcbiAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIud2luZG93LCByZWFjdERvbUZsdXNoU3luY0ltcGwsIHRyYW5zaXRpb24sIHJlbmRlckRmZF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgIXZ0Q29udGV4dC5mbHVzaFN5bmMpIHtcbiAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0XSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICBsZXQgdHJhbnNpdGlvbjIgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICBhd2FpdCByZW5kZXJQcm9taXNlO1xuICAgICAgfSk7XG4gICAgICB0cmFuc2l0aW9uMi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyRGZkKHZvaWQgMCk7XG4gICAgICAgIHNldFRyYW5zaXRpb24odm9pZCAwKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHZvaWQgMCk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbjIpO1xuICAgIH1cbiAgfSwgW3BlbmRpbmdTdGF0ZSwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih2b2lkIDApO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICBsZXQgbmF2aWdhdG9yMiA9IFJlYWN0My51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IChuKSA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlMiwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZTIsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICByb3V0ZXIsXG4gICAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIsXG4gICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgYmFzZW5hbWVcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IyLCBiYXNlbmFtZV1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChGZXRjaGVyc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGZldGNoZXJEYXRhLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdnRDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yMlxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgICAgTWVtb2l6ZWREYXRhUm91dGVzLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBudWxsKTtcbn1cbnZhciBNZW1vaXplZERhdGFSb3V0ZXMgPSBSZWFjdDMubWVtbyhEYXRhUm91dGVzKTtcbmZ1bmN0aW9uIERhdGFSb3V0ZXMoe1xuICByb3V0ZXMsXG4gIGZ1dHVyZSxcbiAgc3RhdGVcbn0pIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB2b2lkIDAsIHN0YXRlLCBmdXR1cmUpO1xufVxuZnVuY3Rpb24gTWVtb3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBpbml0aWFsRW50cmllcyxcbiAgaW5pdGlhbEluZGV4XG59KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QzLnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0My51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0My51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBOYXZpZ2F0ZSh7XG4gIHRvLFxuICByZXBsYWNlOiByZXBsYWNlMixcbiAgc3RhdGUsXG4gIHJlbGF0aXZlXG59KSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYDxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IHN0YXRpYzogaXNTdGF0aWMgfSA9IFJlYWN0My51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgd2FybmluZyhcbiAgICAhaXNTdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QzLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvLFxuICAgIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcyksXG4gICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgKTtcbiAgbGV0IGpzb25QYXRoID0gSlNPTi5zdHJpbmdpZnkocGF0aCk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7IHJlcGxhY2U6IHJlcGxhY2UyLCBzdGF0ZSwgcmVsYXRpdmUgfSk7XG4gIH0sIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlMiwgc3RhdGVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cbmZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IFwiUE9QXCIgLyogUG9wICovLFxuICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgYFlvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLmBcbiAgKTtcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIsXG4gICAgICBzdGF0aWM6IHN0YXRpY1Byb3AsXG4gICAgICBmdXR1cmU6IHt9XG4gICAgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IyLCBzdGF0aWNQcm9wXVxuICApO1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBuYXZpZ2F0aW9uQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IGNoaWxkcmVuLCB2YWx1ZTogbG9jYXRpb25Db250ZXh0IH0pKTtcbn1cbmZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvblxufSkge1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIEF3YWl0KHtcbiAgY2hpbGRyZW4sXG4gIGVycm9yRWxlbWVudCxcbiAgcmVzb2x2ZVxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwgeyByZXNvbHZlLCBlcnJvckVsZW1lbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pKTtcbn1cbnZhciBBd2FpdEVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0My5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4sIGVycm9yRWxlbWVudCwgcmVzb2x2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHN0YXR1cyA9IDEgLyogc3VjY2VzcyAqLztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IHJlc29sdmUgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICBzdGF0dXMgPSAyIC8qIGVycm9yICovO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHJlbmRlckVycm9yIH0pO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZS5fdHJhY2tlZCkge1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICBzdGF0dXMgPSBcIl9lcnJvclwiIGluIHByb21pc2UgPyAyIC8qIGVycm9yICovIDogXCJfZGF0YVwiIGluIHByb21pc2UgPyAxIC8qIHN1Y2Nlc3MgKi8gOiAwIC8qIHBlbmRpbmcgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGEyKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YTIgfSksXG4gICAgICAgIChlcnJvcikgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMiAvKiBlcnJvciAqLyAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMiAvKiBlcnJvciAqLykge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb21pc2UsIGNoaWxkcmVuOiBlcnJvckVsZW1lbnQgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDEgLyogc3VjY2VzcyAqLykge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb21pc2UsIGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59O1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgbGV0IGRhdGEyID0gdXNlQXN5bmNWYWx1ZSgpO1xuICBsZXQgdG9SZW5kZXIgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGRhdGEyKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgdG9SZW5kZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRQYXRoID0gW10pIHtcbiAgbGV0IHJvdXRlcyA9IFtdO1xuICBSZWFjdDMuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFSZWFjdDMuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdDMuRnJhZ21lbnQpIHtcbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7dHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCJcbiAgICApO1xuICAgIGxldCByb3V0ZSA9IHtcbiAgICAgIGlkOiBlbGVtZW50LnByb3BzLmlkIHx8IHRyZWVQYXRoLmpvaW4oXCItXCIpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgQ29tcG9uZW50OiBlbGVtZW50LnByb3BzLkNvbXBvbmVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgbG9hZGVyOiBlbGVtZW50LnByb3BzLmxvYWRlcixcbiAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBlbGVtZW50LnByb3BzLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQsXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IGVsZW1lbnQucHJvcHMuSHlkcmF0ZUZhbGxiYWNrLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSB8fCBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgIGxhenk6IGVsZW1lbnQucHJvcHMubGF6eVxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0cmVlUGF0aFxuICAgICAgKTtcbiAgICB9XG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbnZhciBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMgPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW47XG5mdW5jdGlvbiByZW5kZXJNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTAgZnJvbSBcInJlYWN0XCI7XG5cbi8vIGxpYi9kb20vZG9tLnRzXG52YXIgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG52YXIgZGVmYXVsdEVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5mdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKGluaXQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgIHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoaW5pdCkgfHwgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IGluaXQgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8yLCBrZXkpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICAgIHJldHVybiBtZW1vMi5jb25jYXQoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgKTtcbiAgICB9LCBbXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbnZhciBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IG51bGw7XG5mdW5jdGlvbiBpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkge1xuICBpZiAoX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZvcm1EYXRhKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiBGb3JtRGF0YSBzdXBwb3J0cyB0aGUgc3VibWl0dGVyIHBhcmFtZXRlciwgdGhpcyB3aWxsIHRocm93XG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyO1xufVxudmFyIHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsXG4gIFwidGV4dC9wbGFpblwiXG5dKTtcbmZ1bmN0aW9uIGdldEZvcm1FbmNUeXBlKGVuY1R5cGUpIHtcbiAgaWYgKGVuY1R5cGUgIT0gbnVsbCAmJiAhc3VwcG9ydGVkRm9ybUVuY1R5cGVzLmhhcyhlbmNUeXBlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBcIiR7ZW5jVHlwZX1cIiBpcyBub3QgYSB2YWxpZCBcXGBlbmNUeXBlXFxgIGZvciBcXGA8Rm9ybT5cXGAvXFxgPGZldGNoZXIuRm9ybT5cXGAgYW5kIHdpbGwgZGVmYXVsdCB0byBcIiR7ZGVmYXVsdEVuY1R5cGV9XCJgXG4gICAgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gIGxldCBtZXRob2Q7XG4gIGxldCBhY3Rpb247XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG4gIGxldCBib2R5O1xuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcbiAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpKSB8fCBnZXRGb3JtRW5jVHlwZShmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0sIHRhcmdldCk7XG4gICAgaWYgKCFpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxldCB7IG5hbWUsIHR5cGUsIHZhbHVlIH0gPSB0YXJnZXQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gYCR7bmFtZX0uYCA6IFwiXCI7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eGAsIFwiMFwiKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke3ByZWZpeH15YCwgXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgPGlucHV0IHR5cGU9XCJzdWJtaXR8aW1hZ2VcIj5gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG51bGw7XG4gICAgZW5jVHlwZSA9IGRlZmF1bHRFbmNUeXBlO1xuICAgIGJvZHkgPSB0YXJnZXQ7XG4gIH1cbiAgaWYgKGZvcm1EYXRhICYmIGVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgYm9keSA9IGZvcm1EYXRhO1xuICAgIGZvcm1EYXRhID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IGFjdGlvbiwgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSwgZW5jVHlwZSwgZm9ybURhdGEsIGJvZHkgfTtcbn1cblxuLy8gbGliL2RvbS9zc3IvY29tcG9uZW50cy50c3hcbmltcG9ydCAqIGFzIFJlYWN0OSBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3IvaW52YXJpYW50LnRzXG5mdW5jdGlvbiBpbnZhcmlhbnQyKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlTW9kdWxlcy50c1xuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICBpZiAocm91dGUuaWQgaW4gcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgaW1wb3J0KFxuICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICByb3V0ZS5tb2R1bGVcbiAgICApO1xuICAgIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXSA9IHJvdXRlTW9kdWxlO1xuICAgIHJldHVybiByb3V0ZU1vZHVsZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEVycm9yIGxvYWRpbmcgcm91dGUgbW9kdWxlIFxcYCR7cm91dGUubW9kdWxlfVxcYCwgcmVsb2FkaW5nIHBhZ2UuLi5gXG4gICAgKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBpZiAod2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ICYmIHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5pc1NwYU1vZGUgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGltcG9ydC5tZXRhLmhvdCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGxpYi9kb20vc3NyL2xpbmtzLnRzXG5mdW5jdGlvbiBnZXRLZXllZExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSB7XG4gIGxldCBkZXNjcmlwdG9ycyA9IG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgIGxldCBtb2R1bGUgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHJvdXRlICYmIHJvdXRlLmNzcyA/IHJvdXRlLmNzcy5tYXAoKGhyZWYyKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBocmVmMiB9KSkgOiBbXSxcbiAgICAgIG1vZHVsZT8ubGlua3M/LigpIHx8IFtdXG4gICAgXTtcbiAgfSkuZmxhdCgyKTtcbiAgbGV0IHByZWxvYWRzID0gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KTtcbiAgcmV0dXJuIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhkZXNjcmlwdG9ycywgcHJlbG9hZHMpO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSkge1xuICBpZiAoIXJvdXRlLmNzcykgcmV0dXJuIFtdO1xuICByZXR1cm4gcm91dGUuY3NzLm1hcCgoaHJlZjIpID0+ICh7IHJlbDogXCJzdHlsZXNoZWV0XCIsIGhyZWY6IGhyZWYyIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoUm91dGVDc3Mocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MpIHJldHVybjtcbiAgbGV0IGRlc2NyaXB0b3JzID0gZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGRlc2NyaXB0b3JzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSkge1xuICBpZiAoIXJvdXRlLmNzcyAmJiAhcm91dGVNb2R1bGUubGlua3MgfHwgIWlzUHJlbG9hZFN1cHBvcnRlZCgpKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IFtdO1xuICBpZiAocm91dGUuY3NzKSB7XG4gICAgZGVzY3JpcHRvcnMucHVzaCguLi5nZXRSb3V0ZUNzc0Rlc2NyaXB0b3JzKHJvdXRlKSk7XG4gIH1cbiAgaWYgKHJvdXRlTW9kdWxlLmxpbmtzKSB7XG4gICAgZGVzY3JpcHRvcnMucHVzaCguLi5yb3V0ZU1vZHVsZS5saW5rcygpKTtcbiAgfVxuICBpZiAoZGVzY3JpcHRvcnMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGxldCBzdHlsZUxpbmtzID0gW107XG4gIGZvciAobGV0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IucmVsID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgc3R5bGVMaW5rcy5wdXNoKHtcbiAgICAgICAgLi4uZGVzY3JpcHRvcixcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwic3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKHN0eWxlTGlua3MubWFwKHByZWZldGNoU3R5bGVMaW5rKSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFN0eWxlTGluayhkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmIChkZXNjcmlwdG9yLm1lZGlhICYmICF3aW5kb3cubWF0Y2hNZWRpYShkZXNjcmlwdG9yLm1lZGlhKS5tYXRjaGVzIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdW2hyZWY9XCIke2Rlc2NyaXB0b3IuaHJlZn1cIl1gXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBPYmplY3QuYXNzaWduKGxpbmssIGRlc2NyaXB0b3IpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZUxpbmsoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGVhZC5jb250YWlucyhsaW5rKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5rLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGxpbmsub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNQYWdlTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnBhZ2UgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0h0bWxMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChvYmplY3QuaHJlZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iamVjdC5yZWwgPT09IFwicHJlbG9hZFwiICYmIHR5cGVvZiBvYmplY3QuaW1hZ2VTcmNTZXQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5pbWFnZVNpemVzID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0LnJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmhyZWYgPT09IFwic3RyaW5nXCI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbGlua3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBtYXRjaGVzLm1hcChhc3luYyAobWF0Y2gpID0+IHtcbiAgICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgbGV0IG1vZCA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgICAgICAgcmV0dXJuIG1vZC5saW5rcyA/IG1vZC5saW5rcygpIDogW107XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhcbiAgICBsaW5rcy5mbGF0KDEpLmZpbHRlcihpc0h0bWxMaW5rRGVzY3JpcHRvcikuZmlsdGVyKChsaW5rKSA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgbGluay5yZWwgPT09IFwicHJlbG9hZFwiKS5tYXAoXG4gICAgICAobGluaykgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiID8geyAuLi5saW5rLCByZWw6IFwicHJlZmV0Y2hcIiwgYXM6IFwic3R5bGVcIiB9IDogeyAuLi5saW5rLCByZWw6IFwicHJlZmV0Y2hcIiB9XG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKHBhZ2UsIG5leHRNYXRjaGVzLCBjdXJyZW50TWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uLCBtb2RlKSB7XG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRNYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG4gIGxldCBtYXRjaFBhdGhDaGFuZ2VkID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoPy5lbmRzV2l0aChcIipcIikgJiYgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9O1xuICBpZiAobW9kZSA9PT0gXCJhc3NldHNcIikge1xuICAgIHJldHVybiBuZXh0TWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobWF0Y2gsIGluZGV4KSA9PiBpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KVxuICAgICk7XG4gIH1cbiAgaWYgKG1vZGUgPT09IFwiZGF0YVwiKSB7XG4gICAgcmV0dXJuIG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIW1hbmlmZXN0Um91dGUgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIGxldCByb3V0ZUNob2ljZSA9IG1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoe1xuICAgICAgICAgIGN1cnJlbnRVcmw6IG5ldyBVUkwoXG4gICAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gsXG4gICAgICAgICAgICB3aW5kb3cub3JpZ2luXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50TWF0Y2hlc1swXT8ucGFyYW1zIHx8IHt9LFxuICAgICAgICAgIG5leHRVcmw6IG5ldyBVUkwocGFnZSwgd2luZG93Lm9yaWdpbiksXG4gICAgICAgICAgbmV4dFBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0LCB7IGluY2x1ZGVIeWRyYXRlRmFsbGJhY2sgfSA9IHt9KSB7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhcbiAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIXJvdXRlKSByZXR1cm4gW107XG4gICAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcbiAgICAgIGlmIChyb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlSHlkcmF0ZUZhbGxiYWNrICYmIHJvdXRlLmh5ZHJhdGVGYWxsYmFja01vZHVsZSkge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tNb2R1bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdXRlLmltcG9ydHMpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHJlZnM7XG4gICAgfSkuZmxhdCgxKVxuICApO1xufVxuZnVuY3Rpb24gZGVkdXBlSHJlZnMoaHJlZnMpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGhyZWZzKV07XG59XG5mdW5jdGlvbiBzb3J0S2V5cyhvYmopIHtcbiAgbGV0IHNvcnRlZCA9IHt9O1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgpO1xuICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgIHNvcnRlZFtrZXldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHNvcnRlZDtcbn1cbmZ1bmN0aW9uIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhkZXNjcmlwdG9ycywgcHJlbG9hZHMpIHtcbiAgbGV0IHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBwcmVsb2Fkc1NldCA9IG5ldyBTZXQocHJlbG9hZHMpO1xuICByZXR1cm4gZGVzY3JpcHRvcnMucmVkdWNlKChkZWR1cGVkLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgbGV0IGFscmVhZHlNb2R1bGVQcmVsb2FkID0gcHJlbG9hZHMgJiYgIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IuYXMgPT09IFwic2NyaXB0XCIgJiYgZGVzY3JpcHRvci5ocmVmICYmIHByZWxvYWRzU2V0LmhhcyhkZXNjcmlwdG9yLmhyZWYpO1xuICAgIGlmIChhbHJlYWR5TW9kdWxlUHJlbG9hZCkge1xuICAgICAgcmV0dXJuIGRlZHVwZWQ7XG4gICAgfVxuICAgIGxldCBrZXkgPSBKU09OLnN0cmluZ2lmeShzb3J0S2V5cyhkZXNjcmlwdG9yKSk7XG4gICAgaWYgKCFzZXQuaGFzKGtleSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIGRlZHVwZWQucHVzaCh7IGtleSwgbGluazogZGVzY3JpcHRvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZHVwZWQ7XG4gIH0sIFtdKTtcbn1cbnZhciBfaXNQcmVsb2FkU3VwcG9ydGVkO1xuZnVuY3Rpb24gaXNQcmVsb2FkU3VwcG9ydGVkKCkge1xuICBpZiAoX2lzUHJlbG9hZFN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG4gIH1cbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gIF9pc1ByZWxvYWRTdXBwb3J0ZWQgPSBlbC5yZWxMaXN0LnN1cHBvcnRzKFwicHJlbG9hZFwiKTtcbiAgZWwgPSBudWxsO1xuICByZXR1cm4gX2lzUHJlbG9hZFN1cHBvcnRlZDtcbn1cblxuLy8gbGliL2RvbS9zc3IvbWFya3VwLnRzXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZShFU0NBUEVfUkVHRVgsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUFttYXRjaF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSHRtbChodG1sKSB7XG4gIHJldHVybiB7IF9faHRtbDogaHRtbCB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9zaW5nbGUtZmV0Y2gudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwidHVyYm8tc3RyZWFtXCI7XG5cbi8vIGxpYi9kb20vc3NyL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpIHtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbDogcmVxdWVzdC5zaWduYWwgfTtcbiAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgaW5pdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgcmVxdWVzdC5qc29uKCkpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYnRleHRcXC9wbGFpblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUgfTtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCByZXF1ZXN0LnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbnZhciBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sID0gU3ltYm9sKFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKTtcbmZ1bmN0aW9uIFN0cmVhbVRyYW5zZmVyKHtcbiAgY29udGV4dCxcbiAgaWRlbnRpZmllcixcbiAgcmVhZGVyLFxuICB0ZXh0RGVjb2RlcixcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEgfHwgIWNvbnRleHQucmVuZGVyTWV0YS5kaWRSZW5kZXJTY3JpcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUpIHtcbiAgICBjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUgPSB7fTtcbiAgfVxuICBsZXQgeyBzdHJlYW1DYWNoZSB9ID0gY29udGV4dC5yZW5kZXJNZXRhO1xuICBsZXQgcHJvbWlzZSA9IHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdO1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0gPSByZWFkZXIucmVhZCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0ucmVzdWx0ID0ge1xuICAgICAgICBkb25lOiByZXN1bHQuZG9uZSxcbiAgICAgICAgdmFsdWU6IHRleHREZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICB9O1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5lcnJvciA9IGU7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21pc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBwcm9taXNlLmVycm9yO1xuICB9XG4gIGlmIChwcm9taXNlLnJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxuICBsZXQgeyBkb25lLCB2YWx1ZSB9ID0gcHJvbWlzZS5yZXN1bHQ7XG4gIGxldCBzY3JpcHRUYWcgPSB2YWx1ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSgke2VzY2FwZUh0bWwoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICl9KTtgXG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbiAgaWYgKGRvbmUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5GcmFnbWVudCwgbnVsbCwgc2NyaXB0VGFnLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO2BcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuU3VzcGVuc2UsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0cmVhbVRyYW5zZmVyLFxuICAgICAge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyICsgMSxcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5KG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgZ2V0Um91dGVyKSB7XG4gIHJldHVybiBhc3luYyAoeyByZXF1ZXN0LCBtYXRjaGVzLCBmZXRjaGVyS2V5IH0pID0+IHtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaEFjdGlvblN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICBpZiAoIXNzcikge1xuICAgICAgbGV0IGZvdW5kUmV2YWxpZGF0aW5nU2VydmVyTG9hZGVyID0gbWF0Y2hlcy5zb21lKFxuICAgICAgICAobSkgPT4gbS5zaG91bGRMb2FkICYmIG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXT8uaGFzTG9hZGVyICYmICFtYW5pZmVzdC5yb3V0ZXNbbS5yb3V0ZS5pZF0/Lmhhc0NsaWVudExvYWRlclxuICAgICAgKTtcbiAgICAgIGlmICghZm91bmRSZXZhbGlkYXRpbmdTZXJ2ZXJMb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hdGNoZXNUb0xvYWQgPSBtYXRjaGVzLmZpbHRlcigobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgICAgICAgbGV0IHVybCA9IHN0cmlwSW5kZXhQYXJhbShzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCkpO1xuICAgICAgICBsZXQgaW5pdCA9IGF3YWl0IGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBtYXRjaGVzVG9Mb2FkLm1hcChcbiAgICAgICAgICAgIChtKSA9PiBtLnJlc29sdmUoYXN5bmMgKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWFuaWZlc3Qucm91dGVzW20ucm91dGUuaWRdPy5oYXNDbGllbnRMb2FkZXIgPyBhd2FpdCBmZXRjaFNpbmdsZUxvYWRlcihoYW5kbGVyLCB1cmwsIGluaXQsIG0ucm91dGUuaWQpIDogYXdhaXQgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQgfTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZldGNoZXJLZXkpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaExvYWRlckZldGNoZXJTdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyTmF2aWdhdGlvblN0cmF0ZWd5KFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzc3IsXG4gICAgICBnZXRSb3V0ZXIoKSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzXG4gICAgKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3kocmVxdWVzdCwgbWF0Y2hlcykge1xuICBsZXQgYWN0aW9uTWF0Y2ggPSBtYXRjaGVzLmZpbmQoKG0pID0+IG0uc2hvdWxkTG9hZCk7XG4gIGludmFyaWFudDIoYWN0aW9uTWF0Y2gsIFwiTm8gYWN0aW9uIG1hdGNoIGZvdW5kXCIpO1xuICBsZXQgYWN0aW9uU3RhdHVzID0gdm9pZCAwO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgYWN0aW9uTWF0Y2gucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgIGxldCByZXN1bHQyID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdXJsID0gc2luZ2xlRmV0Y2hVcmwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IGluaXQgPSBhd2FpdCBjcmVhdGVSZXF1ZXN0SW5pdChyZXF1ZXN0KTtcbiAgICAgIGxldCB7IGRhdGE6IGRhdGEyLCBzdGF0dXMgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKHVybCwgaW5pdCk7XG4gICAgICBhY3Rpb25TdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQoXG4gICAgICAgIGRhdGEyLFxuICAgICAgICBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfSk7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpIHx8IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgcmV0dXJuIHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiB7XG4gICAgICB0eXBlOiByZXN1bHQudHlwZSxcbiAgICAgIHJlc3VsdDogZGF0YShyZXN1bHQucmVzdWx0LCBhY3Rpb25TdGF0dXMpXG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3kobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCByb3V0ZXIsIHJlcXVlc3QsIG1hdGNoZXMpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBtYXRjaGVzLm1hcCgoKSA9PiBjcmVhdGVEZWZlcnJlZDIoKSk7XG4gIGxldCByb3V0ZXNMb2FkZWRQcm9taXNlID0gUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBzaW5nbGVGZXRjaERmZCA9IGNyZWF0ZURlZmVycmVkMigpO1xuICBsZXQgdXJsID0gc3RyaXBJbmRleFBhcmFtKHNpbmdsZUZldGNoVXJsKHJlcXVlc3QudXJsKSk7XG4gIGxldCBpbml0ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIG1hdGNoZXMubWFwKFxuICAgICAgYXN5bmMgKG0sIGkpID0+IG0ucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgICAgICByb3V0ZURmZHNbaV0ucmVzb2x2ZSgpO1xuICAgICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKCFtLnNob3VsZExvYWQpIHtcbiAgICAgICAgICBpZiAoIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobS5yb3V0ZS5pZCBpbiByb3V0ZXIuc3RhdGUubG9hZGVyRGF0YSAmJiBtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmIHJvdXRlTW9kdWxlc1ttLnJvdXRlLmlkXT8uc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgICAgaWYgKG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaFNpbmdsZUxvYWRlcihcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICBtLnJvdXRlLmlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFuaWZlc3RSb3V0ZSAmJiBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhkYXRhMiwgbS5yb3V0ZS5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgcm91dGVzTG9hZGVkUHJvbWlzZTtcbiAgaWYgKCghcm91dGVyLnN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSAmJiAhd2luZG93Ll9fcmVhY3RSb3V0ZXJIZHJBY3RpdmUpIHtcbiAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHNzciAmJiBmb3VuZE9wdE91dFJvdXRlICYmIHJvdXRlc1BhcmFtcy5zaXplID4gMCkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgICBtYXRjaGVzLmZpbHRlcigobSkgPT4gcm91dGVzUGFyYW1zLmhhcyhtLnJvdXRlLmlkKSkubWFwKChtKSA9PiBtLnJvdXRlLmlkKS5qb2luKFwiLFwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IGRhdGEyID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUodXJsLCBpbml0KTtcbiAgICAgIHNpbmdsZUZldGNoRGZkLnJlc29sdmUoZGF0YTIuZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2luZ2xlRmV0Y2hEZmQucmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuICBhd2FpdCByZXNvbHZlUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlckZldGNoZXJTdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzKSB7XG4gIGxldCBmZXRjaGVyTWF0Y2ggPSBtYXRjaGVzLmZpbmQoKG0pID0+IG0uc2hvdWxkTG9hZCk7XG4gIGludmFyaWFudDIoZmV0Y2hlck1hdGNoLCBcIk5vIGZldGNoZXIgbWF0Y2ggZm91bmRcIik7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaGVyTWF0Y2gucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgIGxldCB1cmwgPSBzdHJpcEluZGV4UGFyYW0oc2luZ2xlRmV0Y2hVcmwocmVxdWVzdC51cmwpKTtcbiAgICBsZXQgaW5pdCA9IGF3YWl0IGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpO1xuICAgIHJldHVybiBmZXRjaFNpbmdsZUxvYWRlcihoYW5kbGVyLCB1cmwsIGluaXQsIGZldGNoZXJNYXRjaC5yb3V0ZS5pZCk7XG4gIH0pO1xuICByZXR1cm4geyBbZmV0Y2hlck1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG59XG5mdW5jdGlvbiBmZXRjaFNpbmdsZUxvYWRlcihoYW5kbGVyLCB1cmwsIGluaXQsIHJvdXRlSWQpIHtcbiAgcmV0dXJuIGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzaW5nbGVMb2FkZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgc2luZ2xlTG9hZGVyVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJfcm91dGVzXCIsIHJvdXRlSWQpO1xuICAgIGxldCB7IGRhdGE6IGRhdGEyIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShzaW5nbGVMb2FkZXJVcmwsIGluaXQpO1xuICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdHMoZGF0YTIsIHJvdXRlSWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmlwSW5kZXhQYXJhbSh1cmwpIHtcbiAgbGV0IGluZGV4VmFsdWVzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgbGV0IGluZGV4VmFsdWVzVG9LZWVwID0gW107XG4gIGZvciAobGV0IGluZGV4VmFsdWUgb2YgaW5kZXhWYWx1ZXMpIHtcbiAgICBpZiAoaW5kZXhWYWx1ZSkge1xuICAgICAgaW5kZXhWYWx1ZXNUb0tlZXAucHVzaChpbmRleFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBzaW5nbGVGZXRjaFVybChyZXFVcmwpIHtcbiAgbGV0IHVybCA9IHR5cGVvZiByZXFVcmwgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKFxuICAgIHJlcVVybCxcbiAgICAvLyBUaGlzIGNhbiBiZSBjYWxsZWQgZHVyaW5nIHRoZSBTU1IgZmxvdyB2aWEgUHJlZmV0Y2hQYWdlTGlua3NJbXBsIHNvXG4gICAgLy8gZG9uJ3QgYXNzdW1lIHdpbmRvdyBpcyBhdmFpbGFibGVcbiAgICB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJzZXJ2ZXI6Ly9zaW5nbGVmZXRjaC9cIiA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgKSA6IHJlcVVybDtcbiAgaWYgKHVybC5wYXRobmFtZSA9PT0gXCIvXCIpIHtcbiAgICB1cmwucGF0aG5hbWUgPSBcIl9yb290LmRhdGFcIjtcbiAgfSBlbHNlIHtcbiAgICB1cmwucGF0aG5hbWUgPSBgJHt1cmwucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS5kYXRhYDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmREZWNvZGUodXJsLCBpbml0KSB7XG4gIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmICFyZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlc3BvbnNlXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwNCwgXCJOb3QgRm91bmRcIiwgdHJ1ZSk7XG4gIH1cbiAgY29uc3QgTk9fQk9EWV9TVEFUVVNfQ09ERVMyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzEwMCwgMTAxLCAyMDQsIDIwNV0pO1xuICBpZiAoTk9fQk9EWV9TVEFUVVNfQ09ERVMyLmhhcyhyZXMuc3RhdHVzKSkge1xuICAgIGlmICghaW5pdC5tZXRob2QgfHwgaW5pdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgZGF0YToge30gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiB7IGRhdGE6IHZvaWQgMCB9IH07XG4gICAgfVxuICB9XG4gIGludmFyaWFudDIocmVzLmJvZHksIFwiTm8gcmVzcG9uc2UgYm9keSB0byBkZWNvZGVcIik7XG4gIHRyeSB7XG4gICAgbGV0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVWaWFUdXJib1N0cmVhbShyZXMuYm9keSwgd2luZG93KTtcbiAgICByZXR1cm4geyBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IGRlY29kZWQudmFsdWUgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgdHVyYm8tc3RyZWFtIHJlc3BvbnNlXCIpO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvZGVWaWFUdXJib1N0cmVhbShib2R5LCBnbG9iYWwyKSB7XG4gIHJldHVybiBkZWNvZGUoYm9keSwge1xuICAgIHBsdWdpbnM6IFtcbiAgICAgICh0eXBlLCAuLi5yZXN0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNhbml0aXplZEVycm9yXCIpIHtcbiAgICAgICAgICBsZXQgW25hbWUsIG1lc3NhZ2UsIHN0YWNrXSA9IHJlc3Q7XG4gICAgICAgICAgbGV0IENvbnN0cnVjdG9yID0gRXJyb3I7XG4gICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSBpbiBnbG9iYWwyICYmIHR5cGVvZiBnbG9iYWwyW25hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gZ2xvYmFsMltuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGVycm9yID0gbmV3IENvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICAgICAgbGV0IFtkYXRhMiwgc3RhdHVzLCBzdGF0dXNUZXh0XSA9IHJlc3Q7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhMilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoUmVkaXJlY3RcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB7IFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogcmVzdFswXSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdFswXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoRmFsbGJhY2tcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdHMocmVzdWx0cywgcm91dGVJZCkge1xuICBsZXQgcmVkaXJlY3QyID0gcmVzdWx0c1tTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTtcbiAgaWYgKHJlZGlyZWN0Mikge1xuICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChyZWRpcmVjdDIsIHJvdXRlSWQpO1xuICB9XG4gIHJldHVybiByZXN1bHRzW3JvdXRlSWRdICE9PSB2b2lkIDAgPyB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChyZXN1bHRzW3JvdXRlSWRdLCByb3V0ZUlkKSA6IG51bGw7XG59XG5mdW5jdGlvbiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChyZXN1bHQsIHJvdXRlSWQpIHtcbiAgaWYgKFwiZXJyb3JcIiBpbiByZXN1bHQpIHtcbiAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gIH0gZWxzZSBpZiAoXCJyZWRpcmVjdFwiIGluIHJlc3VsdCkge1xuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgaWYgKHJlc3VsdC5yZXZhbGlkYXRlKSB7XG4gICAgICBoZWFkZXJzW1wiWC1SZW1peC1SZXZhbGlkYXRlXCJdID0gXCJ5ZXNcIjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5yZWxvYWQpIHtcbiAgICAgIGhlYWRlcnNbXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiXSA9IFwieWVzXCI7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucmVwbGFjZSkge1xuICAgICAgaGVhZGVyc1tcIlgtUmVtaXgtUmVwbGFjZVwiXSA9IFwieWVzXCI7XG4gICAgfVxuICAgIHRocm93IHJlZGlyZWN0KHJlc3VsdC5yZWRpcmVjdCwgeyBzdGF0dXM6IHJlc3VsdC5zdGF0dXMsIGhlYWRlcnMgfSk7XG4gIH0gZWxzZSBpZiAoXCJkYXRhXCIgaW4gcmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVzcG9uc2UgZm91bmQgZm9yIHJvdXRlSWQgXCIke3JvdXRlSWR9XCJgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQyKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZvZy1vZi13YXIudHNcbmltcG9ydCAqIGFzIFJlYWN0OCBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q3IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvZG9tL3Nzci9lcnJvckJvdW5kYXJpZXMudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDUgZnJvbSBcInJlYWN0XCI7XG52YXIgUmVtaXhFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDUuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbiB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbiB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnksXG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICBpc091dHNpZGVSZW1peEFwcDogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSh7XG4gIGVycm9yLFxuICBpc091dHNpZGVSZW1peEFwcFxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgbGV0IGhleURldmVsb3BlciA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9ndWlkZXMvZXJyb3JzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBgXG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChCb3VuZGFyeVNoZWxsLCB7IHRpdGxlOiBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBlcnJvci5zdGF0dXMsIFwiIFwiLCBlcnJvci5zdGF0dXNUZXh0KSwgaGV5RGV2ZWxvcGVyKTtcbiAgfVxuICBsZXQgZXJyb3JJbnN0YW5jZTtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBlcnJvckluc3RhbmNlID0gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVycm9yU3RyaW5nID0gZXJyb3IgPT0gbnVsbCA/IFwiVW5rbm93biBFcnJvclwiIDogdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwidG9TdHJpbmdcIiBpbiBlcnJvciA/IGVycm9yLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gICAgZXJyb3JJbnN0YW5jZSA9IG5ldyBFcnJvcihlcnJvclN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBCb3VuZGFyeVNoZWxsLFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIkFwcGxpY2F0aW9uIEVycm9yIVwiLFxuICAgICAgaXNPdXRzaWRlUmVtaXhBcHBcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMjRweFwiIH0gfSwgXCJBcHBsaWNhdGlvbiBFcnJvclwiKSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInByZVwiLFxuICAgICAge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBhZGRpbmc6IFwiMnJlbVwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFwiaHNsYSgxMCwgNTAlLCA1MCUsIDAuMSlcIixcbiAgICAgICAgICBjb2xvcjogXCJyZWRcIixcbiAgICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9ySW5zdGFuY2Uuc3RhY2tcbiAgICApLFxuICAgIGhleURldmVsb3BlclxuICApO1xufVxuZnVuY3Rpb24gQm91bmRhcnlTaGVsbCh7XG4gIHRpdGxlLFxuICByZW5kZXJTY3JpcHRzLFxuICBpc091dHNpZGVSZW1peEFwcCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgbGV0IHsgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGlmIChyb3V0ZU1vZHVsZXMucm9vdD8uTGF5b3V0ICYmICFpc091dHNpZGVSZW1peEFwcCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7IGxhbmc6IFwiZW5cIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwgeyBjaGFyU2V0OiBcInV0Zi04XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBcIm1ldGFcIixcbiAgICB7XG4gICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsdmlld3BvcnQtZml0PWNvdmVyXCJcbiAgICB9XG4gICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwibWFpblwiLCB7IHN0eWxlOiB7IGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsIHBhZGRpbmc6IFwiMnJlbVwiIH0gfSwgY2hpbGRyZW4sIHJlbmRlclNjcmlwdHMgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoU2NyaXB0cywgbnVsbCkgOiBudWxsKSkpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mYWxsYmFjay50c3hcbmltcG9ydCAqIGFzIFJlYWN0NiBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRIeWRyYXRlRmFsbGJhY2soKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJMb2FkaW5nLi4uXCIsIHJlbmRlclNjcmlwdHM6IHRydWUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn0uIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIndoZW4geW91ciBhcHAgaXMgbG9hZGluZyBKUyBtb2R1bGVzIGFuZC9vciBydW5uaW5nIFxcYGNsaWVudExvYWRlclxcYCBcIiArXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9yb3V0ZS9oeWRyYXRlLWZhbGxiYWNrIFwiICtcbiAgICAgICAgICAgICAgICBcImZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgICB9XG4gICAgfVxuICApKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBDb21wb25lbnQ0ID0gZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpO1xuICBsZXQgSHlkcmF0ZUZhbGxiYWNrID0gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrICYmICghaXNTcGFNb2RlIHx8IHJvdXRlLmlkID09PSBcInJvb3RcIikgPyByb3V0ZU1vZHVsZS5IeWRyYXRlRmFsbGJhY2sgOiByb3V0ZS5pZCA9PT0gXCJyb290XCIgPyBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIDogdm9pZCAwO1xuICBsZXQgRXJyb3JCb3VuZGFyeSA9IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnkgPyByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5IDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB7IGVycm9yOiB1c2VSb3V0ZUVycm9yKCkgfSkgOiB2b2lkIDA7XG4gIGlmIChyb3V0ZS5pZCA9PT0gXCJyb290XCIgJiYgcm91dGVNb2R1bGUuTGF5b3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkNvbXBvbmVudDQgPyB7XG4gICAgICAgIGVsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChDb21wb25lbnQ0LCBudWxsKSlcbiAgICAgIH0gOiB7IENvbXBvbmVudDogQ29tcG9uZW50NCB9LFxuICAgICAgLi4uRXJyb3JCb3VuZGFyeSA/IHtcbiAgICAgICAgZXJyb3JFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCkpXG4gICAgICB9IDogeyBFcnJvckJvdW5kYXJ5IH0sXG4gICAgICAuLi5IeWRyYXRlRmFsbGJhY2sgPyB7XG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIG51bGwpKVxuICAgICAgfSA6IHsgSHlkcmF0ZUZhbGxiYWNrIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IENvbXBvbmVudDogQ29tcG9uZW50NCwgRXJyb3JCb3VuZGFyeSwgSHlkcmF0ZUZhbGxiYWNrIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZnV0dXJlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIHNwYU1vZGVMYXp5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7IENvbXBvbmVudDogKCkgPT4gbnVsbCB9KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKFxuICAgICAgcm91dGVNb2R1bGUsXG4gICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIHRvIGNyZWF0ZSBzZXJ2ZXIgcm91dGVzXCJcbiAgICApO1xuICAgIGxldCBkYXRhUm91dGUgPSB7XG4gICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgIC8vIEZvciBTUEEgTW9kZSwgYWxsIHJvdXRlcyBhcmUgbGF6eSBleGNlcHQgcm9vdC4gIEhvd2V2ZXIgd2UgdGVsbCB0aGVcbiAgICAgIC8vIHJvdXRlciByb290IGlzIGFsc28gbGF6eSBoZXJlIHRvbyBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgZnVsbFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gLSB3ZSBqdXN0IG5lZWQgYSBgbGF6eWAgcHJvcCB0byB0ZWxsIHRoZSBSUiByZW5kZXJpbmdcbiAgICAgIC8vIHdoZXJlIHRvIHN0b3Agd2hpY2ggaXMgYWx3YXlzIGF0IHRoZSByb290IHJvdXRlIGluIFNQQSBtb2RlXG4gICAgICBsYXp5OiBpc1NwYU1vZGUgPyAoKSA9PiBzcGFNb2RlTGF6eVByb21pc2UgOiB2b2lkIDAsXG4gICAgICAvLyBGb3IgcGFydGlhbCBoeWRyYXRpb24gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGluZGljYXRlIHdoZW4gdGhlIHJvdXRlXG4gICAgICAvLyBoYXMgYSBsb2FkZXIvY2xpZW50TG9hZGVyLCBidXQgaXQgd29uJ3QgZXZlciBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzdGF0aWNcbiAgICAgIC8vIHJlbmRlciwgc28ganVzdCBnaXZlIGl0IGEgbm8tb3AgZnVuY3Rpb24gc28gd2UgY2FuIHJlbmRlciBkb3duIHRvIHRoZVxuICAgICAgLy8gcHJvcGVyIGZhbGxiYWNrXG4gICAgICBsb2FkZXI6IHJvdXRlLmhhc0xvYWRlciB8fCByb3V0ZS5oYXNDbGllbnRMb2FkZXIgPyAoKSA9PiBudWxsIDogdm9pZCAwXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIGFjdGlvbi9zaG91bGRSZXZhbGlkYXRlIG9uIHRoZXNlIHJvdXRlcyBzaW5jZSB0aGV5J3JlXG4gICAgICAvLyBmb3IgYSBzdGF0aWMgcmVuZGVyXG4gICAgfTtcbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVTZXJ2ZXJSb3V0ZXMoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIGZ1dHVyZSxcbiAgICAgIGlzU3BhTW9kZSxcbiAgICAgIHJvdXRlLmlkLFxuICAgICAgcm91dGVzQnlQYXJlbnRJZCxcbiAgICAgIHNwYU1vZGVMYXp5UHJvbWlzZVxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dChuZWVkc1JldmFsaWRhdGlvbiwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBpbml0aWFsU3RhdGUsIHNzciwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBjcmVhdGVDbGllbnRSb3V0ZXMoXG4gICAgbWFuaWZlc3QsXG4gICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHNzcixcbiAgICBpc1NwYU1vZGUsXG4gICAgXCJcIixcbiAgICBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLFxuICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICk7XG59XG5mdW5jdGlvbiBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKHR5cGUsIHJvdXRlKSB7XG4gIGlmICh0eXBlID09PSBcImxvYWRlclwiICYmICFyb3V0ZS5oYXNMb2FkZXIgfHwgdHlwZSA9PT0gXCJhY3Rpb25cIiAmJiAhcm91dGUuaGFzQWN0aW9uKSB7XG4gICAgbGV0IGZuID0gdHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwic2VydmVyQWN0aW9uKClcIiA6IFwic2VydmVyTG9hZGVyKClcIjtcbiAgICBsZXQgbXNnID0gYFlvdSBhcmUgdHJ5aW5nIHRvIGNhbGwgJHtmbn0gb24gYSByb3V0ZSB0aGF0IGRvZXMgbm90IGhhdmUgYSBzZXJ2ZXIgJHt0eXBlfSAocm91dGVJZDogXCIke3JvdXRlLmlkfVwiKWA7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDAsIFwiQmFkIFJlcXVlc3RcIiwgbmV3IEVycm9yKG1zZyksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBub0FjdGlvbkRlZmluZWRFcnJvcih0eXBlLCByb3V0ZUlkKSB7XG4gIGxldCBhcnRpY2xlID0gdHlwZSA9PT0gXCJjbGllbnRBY3Rpb25cIiA/IFwiYVwiIDogXCJhblwiO1xuICBsZXQgbXNnID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IGhhdmUgJHthcnRpY2xlfSAke3R5cGV9LCBidXQgeW91IGFyZSB0cnlpbmcgdG8gc3VibWl0IHRvIGl0LiBUbyBmaXggdGhpcywgcGxlYXNlIGFkZCAke2FydGljbGV9IFxcYCR7dHlwZX1cXGAgZnVuY3Rpb24gdG8gdGhlIHJvdXRlYDtcbiAgY29uc29sZS5lcnJvcihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDA1LCBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBpbml0aWFsU3RhdGUsIHNzciwgaXNTcGFNb2RlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCkge1xuICAgICAgaW52YXJpYW50MihcbiAgICAgICAgdHlwZW9mIHNpbmdsZUZldGNoID09PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTm8gc2luZ2xlIGZldGNoIGZ1bmN0aW9uIGF2YWlsYWJsZSBmb3Igcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0xvYWRlcikgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybiBmZXRjaFNlcnZlckhhbmRsZXIoc2luZ2xlRmV0Y2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCkge1xuICAgICAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJhY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWZldGNoTW9kdWxlKG1vZHVsZVBhdGgpIHtcbiAgICAgIGltcG9ydChcbiAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgbW9kdWxlUGF0aFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZmV0Y2hSb3V0ZU1vZHVsZUNodW5rcyhyb3V0ZTIpIHtcbiAgICAgIGlmIChyb3V0ZTIuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgIHByZWZldGNoTW9kdWxlKHJvdXRlMi5jbGllbnRBY3Rpb25Nb2R1bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdXRlMi5jbGllbnRMb2FkZXJNb2R1bGUpIHtcbiAgICAgICAgcHJlZmV0Y2hNb2R1bGUocm91dGUyLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgbGV0IGNhY2hlZE1vZHVsZSA9IHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgICAgIGxldCBsaW5rUHJlZmV0Y2hQcm9taXNlID0gY2FjaGVkTW9kdWxlID8gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCBjYWNoZWRNb2R1bGUpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgbGlua1ByZWZldGNoUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGFSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGhcbiAgICB9O1xuICAgIGlmIChyb3V0ZU1vZHVsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhUm91dGUsIHtcbiAgICAgICAgLi4uZGF0YVJvdXRlLFxuICAgICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIHNzcixcbiAgICAgICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGxldCBoYXNJbml0aWFsRGF0YSA9IGluaXRpYWxTdGF0ZSAmJiBpbml0aWFsU3RhdGUubG9hZGVyRGF0YSAmJiByb3V0ZS5pZCBpbiBpbml0aWFsU3RhdGUubG9hZGVyRGF0YTtcbiAgICAgIGxldCBpbml0aWFsRGF0YSA9IGhhc0luaXRpYWxEYXRhID8gaW5pdGlhbFN0YXRlPy5sb2FkZXJEYXRhPy5bcm91dGUuaWRdIDogdm9pZCAwO1xuICAgICAgbGV0IGhhc0luaXRpYWxFcnJvciA9IGluaXRpYWxTdGF0ZSAmJiBpbml0aWFsU3RhdGUuZXJyb3JzICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5lcnJvcnM7XG4gICAgICBsZXQgaW5pdGlhbEVycm9yID0gaGFzSW5pdGlhbEVycm9yID8gaW5pdGlhbFN0YXRlPy5lcnJvcnM/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaXNIeWRyYXRpb25SZXF1ZXN0ID0gbmVlZHNSZXZhbGlkYXRpb24gPT0gbnVsbCAmJiAocm91dGVNb2R1bGUuY2xpZW50TG9hZGVyPy5oeWRyYXRlID09PSB0cnVlIHx8ICFyb3V0ZS5oYXNMb2FkZXIpO1xuICAgICAgZGF0YVJvdXRlLmxvYWRlciA9IGFzeW5jICh7IHJlcXVlc3QsIHBhcmFtcyB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIGZvciBjcml0aWNhbC1yb3V0ZSBsb2FkZXJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyKHtcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICBhc3luYyBzZXJ2ZXJMb2FkZXIoKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW9uUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsRGF0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChoYXNJbml0aWFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5pdGlhbEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlzSHlkcmF0aW9uUmVxdWVzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGF0YVJvdXRlLmxvYWRlci5oeWRyYXRlID0gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgIGlzU3BhTW9kZVxuICAgICAgKTtcbiAgICAgIGRhdGFSb3V0ZS5hY3Rpb24gPSAoeyByZXF1ZXN0LCBwYXJhbXMgfSwgc2luZ2xlRmV0Y2gpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGFjdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIXJvdXRlTW9kdWxlLmNsaWVudEFjdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzU3BhTW9kZSkge1xuICAgICAgICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImNsaWVudEFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSAoeyByZXF1ZXN0IH0sIHNpbmdsZUZldGNoKSA9PiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSBhc3luYyAoYXJncywgc2luZ2xlRmV0Y2gpID0+IHtcbiAgICAgICAgICBpbnZhcmlhbnQyKHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICAgICAgbGV0IHsgY2xpZW50TG9hZGVyIH0gPSBhd2FpdCBpbXBvcnQoXG4gICAgICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgICAgIHJvdXRlLmNsaWVudExvYWRlck1vZHVsZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGNsaWVudExvYWRlcih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyTG9hZGVyKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50QWN0aW9uKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5hY3Rpb24gPSAoeyByZXF1ZXN0IH0sIHNpbmdsZUZldGNoKSA9PiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImNsaWVudEFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUpIHtcbiAgICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9IGFzeW5jIChhcmdzLCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICAgIGludmFyaWFudDIocm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKTtcbiAgICAgICAgICBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlKTtcbiAgICAgICAgICBsZXQgeyBjbGllbnRBY3Rpb24gfSA9IGF3YWl0IGltcG9ydChcbiAgICAgICAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICAgICAgcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gY2xpZW50QWN0aW9uKHtcbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZGF0YVJvdXRlLmxhenkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUgfHwgcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2RQcm9taXNlID0gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3MoXG4gICAgICAgICAgcm91dGUsXG4gICAgICAgICAgcm91dGVNb2R1bGVzQ2FjaGVcbiAgICAgICAgKTtcbiAgICAgICAgcHJlZmV0Y2hSb3V0ZU1vZHVsZUNodW5rcyhyb3V0ZSk7XG4gICAgICAgIGxldCBtb2QgPSBhd2FpdCBtb2RQcm9taXNlO1xuICAgICAgICBsZXQgbGF6eVJvdXRlID0geyAuLi5tb2QgfTtcbiAgICAgICAgaWYgKG1vZC5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICBsZXQgY2xpZW50TG9hZGVyID0gbW9kLmNsaWVudExvYWRlcjtcbiAgICAgICAgICBsYXp5Um91dGUubG9hZGVyID0gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBjbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZC5jbGllbnRBY3Rpb24pIHtcbiAgICAgICAgICBsZXQgY2xpZW50QWN0aW9uID0gbW9kLmNsaWVudEFjdGlvbjtcbiAgICAgICAgICBsYXp5Um91dGUuYWN0aW9uID0gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBjbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImFjdGlvblwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5sYXp5Um91dGUubG9hZGVyID8geyBsb2FkZXI6IGxhenlSb3V0ZS5sb2FkZXIgfSA6IHt9LFxuICAgICAgICAgIC4uLmxhenlSb3V0ZS5hY3Rpb24gPyB7IGFjdGlvbjogbGF6eVJvdXRlLmFjdGlvbiB9IDoge30sXG4gICAgICAgICAgaGFzRXJyb3JCb3VuZGFyeTogbGF6eVJvdXRlLmhhc0Vycm9yQm91bmRhcnksXG4gICAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgICAgbGF6eVJvdXRlLFxuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBzc3IsXG4gICAgICAgICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICAgICAgICksXG4gICAgICAgICAgaGFuZGxlOiBsYXp5Um91dGUuaGFuZGxlLFxuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gd3JhcCB0aGVzZSBpbiBsYXlvdXQgc2luY2UgdGhlIHJvb3Qgcm91dGUgaXMgbmV2ZXJcbiAgICAgICAgICAvLyBsb2FkZWQgdmlhIHJvdXRlLmxhenkoKVxuICAgICAgICAgIENvbXBvbmVudDogbGF6eVJvdXRlLkNvbXBvbmVudCxcbiAgICAgICAgICBFcnJvckJvdW5kYXJ5OiBsYXp5Um91dGUuRXJyb3JCb3VuZGFyeVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2xpZW50Um91dGVzKFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXNDYWNoZSxcbiAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgIHNzcixcbiAgICAgIGlzU3BhTW9kZSxcbiAgICAgIHJvdXRlLmlkLFxuICAgICAgcm91dGVzQnlQYXJlbnRJZCxcbiAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgZGF0YVJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGRhdGFSb3V0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24ocm91dGUsIG1hbmlmZXN0Um91dGUsIHNzciwgbmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgaWYgKG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXBTaG91bGRSZXZhbGlkYXRlRm9ySGRyKFxuICAgICAgbWFuaWZlc3RSb3V0ZS5pZCxcbiAgICAgIHJvdXRlLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKCFzc3IgJiYgbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIgJiYgIW1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgaWYgKHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgICByZXR1cm4gKG9wdHMpID0+IGZuKHsgLi4ub3B0cywgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCkgPT4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzc3IgJiYgcm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgcmV0dXJuIChvcHRzKSA9PiBmbih7IC4uLm9wdHMsIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xufVxuZnVuY3Rpb24gd3JhcFNob3VsZFJldmFsaWRhdGVGb3JIZHIocm91dGVJZCwgcm91dGVTaG91bGRSZXZhbGlkYXRlLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICBsZXQgaGFuZGxlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICByZXR1cm4gKGFyZykgPT4ge1xuICAgIGlmICghaGFuZGxlZFJldmFsaWRhdGlvbikge1xuICAgICAgaGFuZGxlZFJldmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm4gbmVlZHNSZXZhbGlkYXRpb24uaGFzKHJvdXRlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVTaG91bGRSZXZhbGlkYXRlID8gcm91dGVTaG91bGRSZXZhbGlkYXRlKGFyZykgOiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCByb3V0ZU1vZHVsZVByb21pc2UgPSBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gIGxldCBwcmVmZXRjaFJvdXRlQ3NzUHJvbWlzZSA9IHByZWZldGNoUm91dGVDc3Mocm91dGUpO1xuICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCByb3V0ZU1vZHVsZVByb21pc2U7XG4gIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBwcmVmZXRjaFJvdXRlQ3NzUHJvbWlzZSxcbiAgICBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlKVxuICBdKTtcbiAgcmV0dXJuIHtcbiAgICBDb21wb25lbnQ6IGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSxcbiAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5LFxuICAgIGNsaWVudEFjdGlvbjogcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uLFxuICAgIGNsaWVudExvYWRlcjogcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgIGxpbmtzOiByb3V0ZU1vZHVsZS5saW5rcyxcbiAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlTW9kdWxlLnNob3VsZFJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSB7XG4gIGlmIChyb3V0ZU1vZHVsZS5kZWZhdWx0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIGxldCBpc0VtcHR5T2JqZWN0ID0gdHlwZW9mIHJvdXRlTW9kdWxlLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocm91dGVNb2R1bGUuZGVmYXVsdCkubGVuZ3RoID09PSAwO1xuICBpZiAoIWlzRW1wdHlPYmplY3QpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGUuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBpc1NwYU1vZGUgJiYgcm91dGUuaWQgIT09IFwicm9vdFwiIHx8IHJvdXRlTW9kdWxlLmNsaWVudExvYWRlciAhPSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIuaHlkcmF0ZSA9PT0gdHJ1ZSB8fCByb3V0ZS5oYXNMb2FkZXIgIT09IHRydWUpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mb2ctb2Ytd2FyLnRzXG52YXIgbmV4dFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBkaXNjb3ZlcmVkUGF0aHNNYXhTaXplID0gMWUzO1xudmFyIGRpc2NvdmVyZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgVVJMX0xJTUlUID0gNzY4MDtcbmZ1bmN0aW9uIGlzRm9nT2ZXYXJFbmFibGVkKHNzcikge1xuICByZXR1cm4gc3NyID09PSB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFydGlhbE1hbmlmZXN0KG1hbmlmZXN0LCByb3V0ZXIpIHtcbiAgbGV0IHJvdXRlSWRzID0gbmV3IFNldChyb3V0ZXIuc3RhdGUubWF0Y2hlcy5tYXAoKG0pID0+IG0ucm91dGUuaWQpKTtcbiAgbGV0IHNlZ21lbnRzID0gcm91dGVyLnN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBwYXRocyA9IFtcIi9cIl07XG4gIHNlZ21lbnRzLnBvcCgpO1xuICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHBhdGhzLnB1c2goYC8ke3NlZ21lbnRzLmpvaW4oXCIvXCIpfWApO1xuICAgIHNlZ21lbnRzLnBvcCgpO1xuICB9XG4gIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlci5yb3V0ZXMsIHBhdGgsIHJvdXRlci5iYXNlbmFtZSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMuZm9yRWFjaCgobSkgPT4gcm91dGVJZHMuYWRkKG0ucm91dGUuaWQpKTtcbiAgICB9XG4gIH0pO1xuICBsZXQgaW5pdGlhbFJvdXRlcyA9IFsuLi5yb3V0ZUlkc10ucmVkdWNlKFxuICAgIChhY2MsIGlkKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbaWRdOiBtYW5pZmVzdC5yb3V0ZXNbaWRdIH0pLFxuICAgIHt9XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4ubWFuaWZlc3QsXG4gICAgcm91dGVzOiBpbml0aWFsUm91dGVzXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgaXNTcGFNb2RlLCBiYXNlbmFtZSkge1xuICBpZiAoIWlzRm9nT2ZXYXJFbmFibGVkKHNzcikpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhc3luYyAoeyBwYXRoLCBwYXRjaCwgc2lnbmFsIH0pID0+IHtcbiAgICBpZiAoZGlzY292ZXJlZFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKFxuICAgICAgW3BhdGhdLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHBhdGNoLFxuICAgICAgc2lnbmFsXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvZ09GV2FyRGlzY292ZXJ5KHJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCBpc1NwYU1vZGUpIHtcbiAgUmVhY3Q4LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0ZvZ09mV2FyRW5hYmxlZChzc3IpIHx8IG5hdmlnYXRvci5jb25uZWN0aW9uPy5zYXZlRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBwYXRoID0gZWwudGFnTmFtZSA9PT0gXCJGT1JNXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgOiBlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRobmFtZSA9IGVsLnRhZ05hbWUgPT09IFwiQVwiID8gZWwucGF0aG5hbWUgOiBuZXcgVVJMKHBhdGgsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLnBhdGhuYW1lO1xuICAgICAgaWYgKCFkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGhuYW1lKSkge1xuICAgICAgICBuZXh0UGF0aHMuYWRkKHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQYXRjaGVzKCkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImFbZGF0YS1kaXNjb3Zlcl0sIGZvcm1bZGF0YS1kaXNjb3Zlcl1cIikuZm9yRWFjaChyZWdpc3RlckVsZW1lbnQpO1xuICAgICAgbGV0IGxhenlQYXRocyA9IEFycmF5LmZyb20obmV4dFBhdGhzLmtleXMoKSkuZmlsdGVyKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICAgICAgbmV4dFBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChsYXp5UGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICAgICAgbGF6eVBhdGhzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgICBzc3IsXG4gICAgICAgICAgaXNTcGFNb2RlLFxuICAgICAgICAgIHJvdXRlci5iYXNlbmFtZSxcbiAgICAgICAgICByb3V0ZXIucGF0Y2hSb3V0ZXNcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYW5pZmVzdCBwYXRjaGVzXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVib3VuY2VkRmV0Y2hQYXRjaGVzID0gZGVib3VuY2UoZmV0Y2hQYXRjaGVzLCAxMDApO1xuICAgIGZldGNoUGF0Y2hlcygpO1xuICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IGRlYm91bmNlZEZldGNoUGF0Y2hlcygpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImRhdGEtZGlzY292ZXJcIiwgXCJocmVmXCIsIFwiYWN0aW9uXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW3NzciwgaXNTcGFNb2RlLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCByb3V0ZXJdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMocGF0aHMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgaXNTcGFNb2RlLCBiYXNlbmFtZSwgcGF0Y2hSb3V0ZXMsIHNpZ25hbCkge1xuICBsZXQgbWFuaWZlc3RQYXRoID0gYCR7YmFzZW5hbWUgIT0gbnVsbCA/IGJhc2VuYW1lIDogXCIvXCJ9L19fbWFuaWZlc3RgLnJlcGxhY2UoXG4gICAgL1xcLysvZyxcbiAgICBcIi9cIlxuICApO1xuICBsZXQgdXJsID0gbmV3IFVSTChtYW5pZmVzdFBhdGgsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICBwYXRocy5zb3J0KCkuZm9yRWFjaCgocGF0aCkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJwXCIsIHBhdGgpKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIG1hbmlmZXN0LnZlcnNpb24pO1xuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZXJ2ZXJQYXRjaGVzO1xuICB0cnkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgc2lnbmFsIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzLnRleHQoKSk7XG4gICAgfVxuICAgIHNlcnZlclBhdGNoZXMgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkgcmV0dXJuO1xuICAgIHRocm93IGU7XG4gIH1cbiAgbGV0IGtub3duUm91dGVzID0gbmV3IFNldChPYmplY3Qua2V5cyhtYW5pZmVzdC5yb3V0ZXMpKTtcbiAgbGV0IHBhdGNoZXMgPSBPYmplY3QudmFsdWVzKHNlcnZlclBhdGNoZXMpLnJlZHVjZSgoYWNjLCByb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSAmJiAha25vd25Sb3V0ZXMuaGFzKHJvdXRlLmlkKSkge1xuICAgICAgYWNjW3JvdXRlLmlkXSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIE9iamVjdC5hc3NpZ24obWFuaWZlc3Qucm91dGVzLCBwYXRjaGVzKTtcbiAgcGF0aHMuZm9yRWFjaCgocCkgPT4gYWRkVG9GaWZvUXVldWUocCwgZGlzY292ZXJlZFBhdGhzKSk7XG4gIGxldCBwYXJlbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBPYmplY3QudmFsdWVzKHBhdGNoZXMpLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgaWYgKHBhdGNoICYmICghcGF0Y2gucGFyZW50SWQgfHwgIXBhdGNoZXNbcGF0Y2gucGFyZW50SWRdKSkge1xuICAgICAgcGFyZW50SWRzLmFkZChwYXRjaC5wYXJlbnRJZCk7XG4gICAgfVxuICB9KTtcbiAgcGFyZW50SWRzLmZvckVhY2goXG4gICAgKHBhcmVudElkKSA9PiBwYXRjaFJvdXRlcyhcbiAgICAgIHBhcmVudElkIHx8IG51bGwsXG4gICAgICBjcmVhdGVDbGllbnRSb3V0ZXMocGF0Y2hlcywgcm91dGVNb2R1bGVzLCBudWxsLCBzc3IsIGlzU3BhTW9kZSwgcGFyZW50SWQpXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gYWRkVG9GaWZvUXVldWUocGF0aCwgcXVldWUpIHtcbiAgaWYgKHF1ZXVlLnNpemUgPj0gZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSkge1xuICAgIGxldCBmaXJzdCA9IHF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBxdWV1ZS5kZWxldGUoZmlyc3QpO1xuICB9XG4gIHF1ZXVlLmFkZChwYXRoKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB3YWl0KSB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayguLi5hcmdzKSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dDIoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQyKFxuICAgIGNvbnRleHQsXG4gICAgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIEZyYW1ld29ya0NvbnRleHQgPSBSZWFjdDkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuRnJhbWV3b3JrQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRnJhbWV3b3JrQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRnJhbWV3b3JrQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8SHlkcmF0ZWRSb3V0ZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHRoZWlyRWxlbWVudFByb3BzKSB7XG4gIGxldCBmcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGxldCBbbWF5YmVQcmVmZXRjaCwgc2V0TWF5YmVQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgeyBvbkZvY3VzLCBvbkJsdXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvblRvdWNoU3RhcnQgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBsZXQgcmVmID0gUmVhY3Q5LnVzZVJlZihudWxsKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcInJlbmRlclwiKSB7XG4gICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByZWZldGNoID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgIGxldCBjYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICBzZXRTaG91bGRQcmVmZXRjaChlbnRyeS5pc0ludGVyc2VjdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAgICAgIGlmIChyZWYuY3VycmVudCkgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ByZWZldGNoXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2godHJ1ZSk7XG4gIH07XG4gIGxldCBjYW5jZWxJbnRlbnQgPSAoKSA9PiB7XG4gICAgc2V0TWF5YmVQcmVmZXRjaChmYWxzZSk7XG4gICAgc2V0U2hvdWxkUHJlZmV0Y2goZmFsc2UpO1xuICB9O1xuICBpZiAoIWZyYW1ld29ya0NvbnRleHQpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCByZWYsIHt9XTtcbiAgfVxuICBpZiAocHJlZmV0Y2ggIT09IFwiaW50ZW50XCIpIHtcbiAgICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCByZWYsIHt9XTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHNob3VsZFByZWZldGNoLFxuICAgIHJlZixcbiAgICB7XG4gICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkZvY3VzLCBzZXRJbnRlbnQpLFxuICAgICAgb25CbHVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkJsdXIsIGNhbmNlbEludGVudCksXG4gICAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICAgIG9uTW91c2VMZWF2ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUxlYXZlLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Ub3VjaFN0YXJ0OiBjb21wb3NlRXZlbnRIYW5kbGVycyhvblRvdWNoU3RhcnQsIHNldEludGVudClcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyh0aGVpckhhbmRsZXIsIG91ckhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIHRoZWlySGFuZGxlciAmJiB0aGVpckhhbmRsZXIoZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlTWF0Y2hlcyhtYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSkge1xuICBpZiAoaXNTcGFNb2RlICYmICFpc0h5ZHJhdGVkKSB7XG4gICAgcmV0dXJuIFttYXRjaGVzWzBdXTtcbiAgfVxuICBpZiAoZXJyb3JzKSB7XG4gICAgbGV0IGVycm9ySWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBlcnJvcklkeCArIDEpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gTGlua3MoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgZXJyb3JzLCBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSk7XG4gIGxldCBrZXllZExpbmtzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCksXG4gICAgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBjcml0aWNhbENzcyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBjcml0aWNhbENzcyB9IH0pIDogbnVsbCwga2V5ZWRMaW5rcy5tYXAoXG4gICAgKHsga2V5LCBsaW5rIH0pID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IGtleSwgLi4ubGluayB9KSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSk7XG59XG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWUpLFxuICAgIFtyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWVdXG4gICk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCB7IHBhZ2UsIG1hdGNoZXMsIC4uLmRhdGFMaW5rUHJvcHMgfSk7XG59XG5mdW5jdGlvbiB1c2VLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcykge1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCBba2V5ZWRQcmVmZXRjaExpbmtzLCBzZXRLZXllZFByZWZldGNoTGlua3NdID0gUmVhY3Q5LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gICAgdm9pZCBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykudGhlbihcbiAgICAgIChsaW5rcykgPT4ge1xuICAgICAgICBpZiAoIWludGVycnVwdGVkKSB7XG4gICAgICAgICAgc2V0S2V5ZWRQcmVmZXRjaExpbmtzKGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc10pO1xuICByZXR1cm4ga2V5ZWRQcmVmZXRjaExpbmtzO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3NJbXBsKHtcbiAgcGFnZSxcbiAgbWF0Y2hlczogbmV4dE1hdGNoZXMsXG4gIC4uLmxpbmtQcm9wc1xufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGxvYWRlckRhdGEsIG1hdGNoZXMgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImRhdGFcIlxuICAgICksXG4gICAgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb25dXG4gICk7XG4gIGxldCBuZXdNYXRjaGVzRm9yQXNzZXRzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImFzc2V0c1wiXG4gICAgKSxcbiAgICBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbl1cbiAgKTtcbiAgbGV0IGRhdGFIcmVmcyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGFnZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCByb3V0ZXNQYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gICAgbmV4dE1hdGNoZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbS5yb3V0ZS5pZF07XG4gICAgICBpZiAoIW1hbmlmZXN0Um91dGUgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3TWF0Y2hlc0ZvckRhdGEuc29tZSgobTIpID0+IG0yLnJvdXRlLmlkID09PSBtLnJvdXRlLmlkKSAmJiBtLnJvdXRlLmlkIGluIGxvYWRlckRhdGEgJiYgcm91dGVNb2R1bGVzW20ucm91dGUuaWRdPy5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChwYWdlKTtcbiAgICBpZiAoZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgbmV4dE1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3VybC5wYXRobmFtZSArIHVybC5zZWFyY2hdO1xuICB9LCBbXG4gICAgbG9hZGVyRGF0YSxcbiAgICBsb2NhdGlvbixcbiAgICBtYW5pZmVzdCxcbiAgICBuZXdNYXRjaGVzRm9yRGF0YSxcbiAgICBuZXh0TWF0Y2hlcyxcbiAgICBwYWdlLFxuICAgIHJvdXRlTW9kdWxlc1xuICBdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSxcbiAgICBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdXG4gICk7XG4gIGxldCBrZXllZFByZWZldGNoTGlua3MgPSB1c2VLZXllZFByZWZldGNoTGlua3MobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJwcmVmZXRjaFwiLCBhczogXCJmZXRjaFwiLCBocmVmOiBocmVmMiwgLi4ubGlua1Byb3BzIH0pKSwgbW9kdWxlSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYyLCAuLi5saW5rUHJvcHMgfSkpLCBrZXllZFByZWZldGNoTGlua3MubWFwKCh7IGtleSwgbGluayB9KSA9PiAoXG4gICAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gICAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHsgaXNTcGFNb2RlLCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBlcnJvcnMsXG4gICAgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBfbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBpZiAoZXJyb3JzKSB7XG4gICAgZXJyb3IgPSBlcnJvcnNbX21hdGNoZXNbX21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWRdO1xuICB9XG4gIGxldCBtZXRhID0gW107XG4gIGxldCBsZWFmTWV0YSA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX21hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgX21hdGNoID0gX21hdGNoZXNbaV07XG4gICAgbGV0IHJvdXRlSWQgPSBfbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEyID0gbG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gX21hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IHJvdXRlTWV0YSA9IFtdO1xuICAgIGxldCBtYXRjaCA9IHtcbiAgICAgIGlkOiByb3V0ZUlkLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBtZXRhOiBbXSxcbiAgICAgIHBhcmFtczogX21hdGNoLnBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBfbWF0Y2gucGF0aG5hbWUsXG4gICAgICBoYW5kbGU6IF9tYXRjaC5yb3V0ZS5oYW5kbGUsXG4gICAgICBlcnJvclxuICAgIH07XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZU1vZHVsZT8ubWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShyb3V0ZU1vZHVsZS5tZXRhKSA/IFsuLi5yb3V0ZU1vZHVsZS5tZXRhXSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgfSBlbHNlIGlmIChsZWFmTWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gWy4uLmxlYWZNZXRhXTtcbiAgICB9XG4gICAgcm91dGVNZXRhID0gcm91dGVNZXRhIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyb3V0ZU1ldGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHJvdXRlIGF0IFwiICsgX21hdGNoLnJvdXRlLnBhdGggKyBcIiByZXR1cm5zIGFuIGludmFsaWQgdmFsdWUuIEFsbCByb3V0ZSBtZXRhIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBtZXRhIG9iamVjdHMuXFxuXFxuVG8gcmVmZXJlbmNlIHRoZSBtZXRhIGZ1bmN0aW9uIEFQSSwgc2VlIGh0dHBzOi8vcmVtaXgucnVuL3JvdXRlL21ldGFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWF0Y2gubWV0YSA9IHJvdXRlTWV0YTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgbWV0YSA9IFsuLi5yb3V0ZU1ldGFdO1xuICAgIGxlYWZNZXRhID0gbWV0YTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgbWV0YS5mbGF0KCkubWFwKChtZXRhUHJvcHMpID0+IHtcbiAgICBpZiAoIW1ldGFQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcInRhZ05hbWVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIGxldCB7IHRhZ05hbWUsIC4uLnJlc3QgfSA9IG1ldGFQcm9wcztcbiAgICAgIGlmICghaXNWYWxpZE1ldGFUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBBIG1ldGEgb2JqZWN0IHVzZXMgYW4gaW52YWxpZCB0YWdOYW1lOiAke3RhZ05hbWV9LiBFeHBlY3RlZCBlaXRoZXIgJ2xpbmsnIG9yICdtZXRhJ2BcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgQ29tcCA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KENvbXAsIHsga2V5OiBKU09OLnN0cmluZ2lmeShyZXN0KSwgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgaWYgKFwidGl0bGVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7IGtleTogXCJ0aXRsZVwiIH0sIFN0cmluZyhtZXRhUHJvcHMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKFwiY2hhcnNldFwiIGluIG1ldGFQcm9wcykge1xuICAgICAgbWV0YVByb3BzLmNoYXJTZXQgPz8gKG1ldGFQcm9wcy5jaGFyU2V0ID0gbWV0YVByb3BzLmNoYXJzZXQpO1xuICAgICAgZGVsZXRlIG1ldGFQcm9wcy5jaGFyc2V0O1xuICAgIH1cbiAgICBpZiAoXCJjaGFyU2V0XCIgaW4gbWV0YVByb3BzICYmIG1ldGFQcm9wcy5jaGFyU2V0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWV0YVByb3BzLmNoYXJTZXQgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBcImNoYXJTZXRcIiwgY2hhclNldDogbWV0YVByb3BzLmNoYXJTZXQgfSkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJzY3JpcHQ6bGQranNvblwiIGluIG1ldGFQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHNbXCJzY3JpcHQ6bGQranNvblwiXSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGBzY3JpcHQ6bGQranNvbjoke2pzb259YCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vbGQranNvblwiLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBqc29uIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHMpLCAuLi5tZXRhUHJvcHMgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdOYW1lID09PSBcInN0cmluZ1wiICYmIC9eKG1ldGF8bGluaykkLy50ZXN0KHRhZ05hbWUpO1xufVxudmFyIGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHsgbWFuaWZlc3QsIHNlcnZlckhhbmRvZmZTdHJpbmcsIGlzU3BhTW9kZSwgc3NyLCByZW5kZXJNZXRhIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IHJvdXRlciwgc3RhdGljOiBpc1N0YXRpYywgc3RhdGljQ29udGV4dCB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQyKCk7XG4gIGxldCB7IG1hdGNoZXM6IHJvdXRlck1hdGNoZXMgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKTtcbiAgbGV0IGVuYWJsZUZvZ09mV2FyID0gaXNGb2dPZldhckVuYWJsZWQoc3NyKTtcbiAgaWYgKHJlbmRlck1ldGEpIHtcbiAgICByZW5kZXJNZXRhLmRpZFJlbmRlclNjcmlwdHMgPSB0cnVlO1xuICB9XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBudWxsLCBpc1NwYU1vZGUpO1xuICBSZWFjdDkudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdDkudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHN0cmVhbVNjcmlwdCA9IFwid2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQoY29udHJvbGxlcil7d2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO319KS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XCI7XG4gICAgbGV0IGNvbnRleHRTY3JpcHQgPSBzdGF0aWNDb250ZXh0ID8gYHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCA9ICR7c2VydmVySGFuZG9mZlN0cmluZ307JHtzdHJlYW1TY3JpcHR9YCA6IFwiIFwiO1xuICAgIGxldCByb3V0ZU1vZHVsZXNTY3JpcHQgPSAhaXNTdGF0aWMgPyBcIiBcIiA6IGAke21hbmlmZXN0Lmhtcj8ucnVudGltZSA/IGBpbXBvcnQgJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5obXIucnVudGltZSl9O2AgOiBcIlwifSR7IWVuYWJsZUZvZ09mV2FyID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnVybCl9YCA6IFwiXCJ9O1xuJHttYXRjaGVzLm1hcCgobWF0Y2gsIHJvdXRlSW5kZXgpID0+IHtcbiAgICAgIGxldCByb3V0ZVZhck5hbWUgPSBgcm91dGUke3JvdXRlSW5kZXh9YDtcbiAgICAgIGxldCBtYW5pZmVzdEVudHJ5ID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGludmFyaWFudDIobWFuaWZlc3RFbnRyeSwgYFJvdXRlICR7bWF0Y2gucm91dGUuaWR9IG5vdCBmb3VuZCBpbiBtYW5pZmVzdGApO1xuICAgICAgbGV0IHtcbiAgICAgICAgY2xpZW50QWN0aW9uTW9kdWxlLFxuICAgICAgICBjbGllbnRMb2FkZXJNb2R1bGUsXG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja01vZHVsZSxcbiAgICAgICAgbW9kdWxlXG4gICAgICB9ID0gbWFuaWZlc3RFbnRyeTtcbiAgICAgIGxldCBjaHVua3MgPSBbXG4gICAgICAgIC4uLmNsaWVudEFjdGlvbk1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudEFjdGlvbk1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50QWN0aW9uYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5jbGllbnRMb2FkZXJNb2R1bGUgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW9kdWxlOiBjbGllbnRMb2FkZXJNb2R1bGUsXG4gICAgICAgICAgICB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X2NsaWVudExvYWRlcmBcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uaHlkcmF0ZUZhbGxiYWNrTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9IeWRyYXRlRmFsbGJhY2tgXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIHsgbW9kdWxlLCB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X21haW5gIH1cbiAgICAgIF07XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYGltcG9ydCAqIGFzICR7cm91dGVWYXJOYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkobW9kdWxlKX07YDtcbiAgICAgIH1cbiAgICAgIGxldCBjaHVua0ltcG9ydHNTbmlwcGV0ID0gY2h1bmtzLm1hcCgoY2h1bmspID0+IGBpbXBvcnQgKiBhcyAke2NodW5rLnZhck5hbWV9IGZyb20gXCIke2NodW5rLm1vZHVsZX1cIjtgKS5qb2luKFwiXFxuXCIpO1xuICAgICAgbGV0IG1lcmdlZENodW5rc1NuaXBwZXQgPSBgY29uc3QgJHtyb3V0ZVZhck5hbWV9ID0geyR7Y2h1bmtzLm1hcCgoY2h1bmspID0+IGAuLi4ke2NodW5rLnZhck5hbWV9YCkuam9pbihcIixcIil9fTtgO1xuICAgICAgcmV0dXJuIFtjaHVua0ltcG9ydHNTbmlwcGV0LCBtZXJnZWRDaHVua3NTbmlwcGV0XS5qb2luKFwiXFxuXCIpO1xuICAgIH0pLmpvaW4oXCJcXG5cIil9XG4gICR7ZW5hYmxlRm9nT2ZXYXIgPyAoXG4gICAgICAvLyBJbmxpbmUgYSBtaW5pbWFsIG1hbmlmZXN0IHdpdGggdGhlIFNTUiBtYXRjaGVzXG4gICAgICBgd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdCA9ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGdldFBhcnRpYWxNYW5pZmVzdChtYW5pZmVzdCwgcm91dGVyKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX07YFxuICAgICkgOiBcIlwifVxuICB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyA9IHske21hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IGAke0pTT04uc3RyaW5naWZ5KG1hdGNoLnJvdXRlLmlkKX06cm91dGUke2luZGV4fWApLmpvaW4oXCIsXCIpfX07XG5cbmltcG9ydCgke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSl9KTtgO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChjb250ZXh0U2NyaXB0KSxcbiAgICAgICAgdHlwZTogdm9pZCAwXG4gICAgICB9XG4gICAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwocm91dGVNb2R1bGVzU2NyaXB0KSxcbiAgICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH1cbiAgICApKTtcbiAgfSwgW10pO1xuICBsZXQgcHJlbG9hZHMgPSBpc0h5ZHJhdGVkID8gW10gOiBtYW5pZmVzdC5lbnRyeS5pbXBvcnRzLmNvbmNhdChcbiAgICBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QsIHtcbiAgICAgIGluY2x1ZGVIeWRyYXRlRmFsbGJhY2s6IHRydWVcbiAgICB9KVxuICApO1xuICByZXR1cm4gaXNIeWRyYXRlZCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCAhZW5hYmxlRm9nT2ZXYXIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IG1hbmlmZXN0LnVybCxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpblxuICAgIH1cbiAgKSA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gICAgfVxuICApLCBkZWR1cGUocHJlbG9hZHMpLm1hcCgocGF0aCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGlua1wiLFxuICAgIHtcbiAgICAgIGtleTogcGF0aCxcbiAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICBocmVmOiBwYXRoLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gICAgfVxuICApKSwgaW5pdGlhbFNjcmlwdHMpO1xufVxuZnVuY3Rpb24gZGVkdXBlKGFycmF5KSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZnVuY3Rpb24gbWVyZ2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vbGliLnRzeFxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG50cnkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJWZXJzaW9uID0gXCI3LjIuMFwiO1xuICB9XG59IGNhdGNoIChlKSB7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogb3B0cz8ud2luZG93IH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB3aW5kb3c/Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmVycm9ycykge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBlcnJvcnM6IGRlc2VyaWFsaXplRXJyb3JzKHN0YXRlLmVycm9ycylcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93OiB3aW5kb3cyXG59KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGFzaFJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgd2luZG93OiB3aW5kb3cyIH0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDEwLnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogd2luZG93MiwgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDEwLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QxMC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBoaXN0b3J5XG59KSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDEwLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QxMC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5IaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYMiA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBMaW5rID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZih7XG4gICAgb25DbGljayxcbiAgICBkaXNjb3ZlciA9IFwicmVuZGVyXCIsXG4gICAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgICByZWxhdGl2ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgdG8sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIC4uLnJlc3RcbiAgfSwgZm9yd2FyZGVkUmVmKSB7XG4gICAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGlzQWJzb2x1dGUgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYMi50ZXN0KHRvKTtcbiAgICBsZXQgYWJzb2x1dGVIcmVmO1xuICAgIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBpc0Fic29sdXRlKSB7XG4gICAgICBhYnNvbHV0ZUhyZWYgPSB0bztcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICAgICAgaWYgKHRhcmdldFVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdG8gPSBwYXRoICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0V4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBgPExpbmsgdG89XCIke3RvfVwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIHdoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaHJlZjIgPSB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBbc2hvdWxkUHJlZmV0Y2gsIHByZWZldGNoUmVmLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IoXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIHJlc3RcbiAgICApO1xuICAgIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB2aWV3VHJhbnNpdGlvblxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxpbmsgPSAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImFcIixcbiAgICAgICAge1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgLi4ucHJlZmV0Y2hIYW5kbGVycyxcbiAgICAgICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZjIsXG4gICAgICAgICAgb25DbGljazogaXNFeHRlcm5hbCB8fCByZWxvYWREb2N1bWVudCA/IG9uQ2xpY2sgOiBoYW5kbGVDbGljayxcbiAgICAgICAgICByZWY6IG1lcmdlUmVmcyhmb3J3YXJkZWRSZWYsIHByZWZldGNoUmVmKSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgXCJkYXRhLWRpc2NvdmVyXCI6ICFpc0Fic29sdXRlICYmIGRpc2NvdmVyID09PSBcInJlbmRlclwiID8gXCJ0cnVlXCIgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHNob3VsZFByZWZldGNoICYmICFpc0Fic29sdXRlID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChSZWFjdDEwLkZyYWdtZW50LCBudWxsLCBsaW5rLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IHBhZ2U6IGhyZWYyIH0pKSA6IGxpbms7XG4gIH1cbik7XG5MaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG52YXIgTmF2TGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoe1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgIGVuZCA9IGZhbHNlLFxuICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgdG8sXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgY2hpbGRyZW4sXG4gICAgLi4ucmVzdFxuICB9LCByZWYpIHtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZSB9KTtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0MTAudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQgeyBuYXZpZ2F0b3I6IG5hdmlnYXRvcjIsIGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc1RyYW5zaXRpb25pbmcgPSByb3V0ZXJTdGF0ZSAhPSBudWxsICYmIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHBhdGgpICYmIHZpZXdUcmFuc2l0aW9uID09PSB0cnVlO1xuICAgIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKG5leHRMb2NhdGlvblBhdGhuYW1lICYmIGJhc2VuYW1lKSB7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uUGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb25QYXRobmFtZTtcbiAgICB9XG4gICAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XG4gICAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gICAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1RyYW5zaXRpb25pbmdcbiAgICB9O1xuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdm9pZCAwO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZVByb3AsXG4gICAgICAgIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsXG4gICAgICAgIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCxcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsXG4gICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIExpbmssXG4gICAgICB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHJlZixcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHRvLFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSxcbiAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW5cbiAgICApO1xuICB9XG4pO1xuTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xudmFyIEZvcm0gPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICh7XG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIGZldGNoZXJLZXksXG4gICAgbmF2aWdhdGUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICBhY3Rpb24sXG4gICAgb25TdWJtaXQsXG4gICAgcmVsYXRpdmUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIC4uLnByb3BzXG4gIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgbGV0IGlzQWJzb2x1dGUgPSB0eXBlb2YgYWN0aW9uID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdChhY3Rpb24pO1xuICAgIGxldCBzdWJtaXRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBzdWJtaXR0ZXIgPSBldmVudC5uYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgICBsZXQgc3VibWl0TWV0aG9kID0gc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IG1ldGhvZDtcbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgICAgbmF2aWdhdGUsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImZvcm1cIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcbiAgICAgICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgICAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXIsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Gb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgbGV0IHJlbWl4Q29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7IGdldEtleSwgc3RvcmFnZUtleSB9KTtcbiAgbGV0IHNzcktleSA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoIXJlbWl4Q29udGV4dCB8fCAhZ2V0S2V5KSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCB1c2VyS2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgZ2V0S2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuIHVzZXJLZXkgIT09IGxvY2F0aW9uLmtleSA/IHVzZXJLZXkgOiBudWxsO1xuICAgIH0sXG4gICAgLy8gTmFoLCB3ZSBvbmx5IG5lZWQgdGhpcyB0aGUgZmlyc3QgdGltZSBmb3IgdGhlIFNTUiByZW5kZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW11cbiAgKTtcbiAgaWYgKCFyZW1peENvbnRleHQgfHwgcmVtaXhDb250ZXh0LmlzU3BhTW9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCByZXN0b3JlU2Nyb2xsID0gKChzdG9yYWdlS2V5MiwgcmVzdG9yZUtleSkgPT4ge1xuICAgIGlmICghd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwgIXdpbmRvdy5oaXN0b3J5LnN0YXRlLmtleSkge1xuICAgICAgbGV0IGtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpO1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5IH0sIFwiXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5MikgfHwgXCJ7fVwiKTtcbiAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3Jlc3RvcmVLZXkgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVkWSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc3RvcmVkWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5Mik7XG4gICAgfVxuICB9KS50b1N0cmluZygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgKCR7cmVzdG9yZVNjcm9sbH0pKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKX0sICR7SlNPTi5zdHJpbmdpZnkoc3NyS2V5KX0pYFxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0Myhob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZTIoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgdGFyZ2V0LFxuICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgc3RhdGUsXG4gIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgcmVsYXRpdmUsXG4gIHZpZXdUcmFuc2l0aW9uXG59ID0ge30pIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHJlcGxhY2UyID0gcmVwbGFjZVByb3AgIT09IHZvaWQgMCA/IHJlcGxhY2VQcm9wIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHBhdGgsXG4gICAgICByZXBsYWNlUHJvcCxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgXVxuICApO1xufVxuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zLmBcbiAgKTtcbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdDEwLnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiAoXG4gICAgICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAgICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50XG4gICAgICApXG4gICAgKSxcbiAgICBbbG9jYXRpb24uc2VhcmNoXVxuICApO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICAgICAgICB0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdFxuICAgICAgKTtcbiAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdXG4gICk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxudmFyIGZldGNoZXJJZCA9IDA7XG52YXIgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gYF9fJHtTdHJpbmcoKytmZXRjaGVySWQpfV9fYDtcbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VTdWJtaXRcIiAvKiBVc2VTdWJtaXQgKi8pO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGN1cnJlbnRSb3V0ZUlkID0gdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGxldCB7IGFjdGlvbiwgbWV0aG9kLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGJhc2VuYW1lXG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICAgIGF3YWl0IHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgICAgZmx1c2hTeW5jOiBvcHRpb25zLmZsdXNoU3luYyxcbiAgICAgICAgICB2aWV3VHJhbnNpdGlvbjogb3B0aW9ucy52aWV3VHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIGxldCBwYXRoID0geyAuLi51c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHsgcmVsYXRpdmUgfSkgfTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgICBsZXQgaGFzTmFrZWRJbmRleFBhcmFtID0gaW5kZXhWYWx1ZXMuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG4gICAgaWYgKGhhc05ha2VkSW5kZXhQYXJhbSkge1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgaW5kZXhWYWx1ZXMuZmlsdGVyKCh2KSA9PiB2KS5mb3JFYWNoKCh2KSA9PiBwYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdikpO1xuICAgICAgbGV0IHFzID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBwYXRoLnNlYXJjaCA9IHFzID8gYD8ke3FzfWAgOiBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hlcih7XG4gIGtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdDEwLnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcbiAgbGV0IHJvdXRlID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdPy5yb3V0ZS5pZDtcbiAgaW52YXJpYW50KGZldGNoZXJEYXRhLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0YCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIGxldCBkZWZhdWx0S2V5ID0gUmVhY3QxMC51c2VJZCgpO1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QxMC51c2VTdGF0ZShrZXkgfHwgZGVmYXVsdEtleSk7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICByb3V0ZXIuZ2V0RmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgbGV0IGxvYWQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChocmVmMiwgb3B0cykgPT4ge1xuICAgICAgaW52YXJpYW50KHJvdXRlSWQsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYyLCBvcHRzKTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdXG4gICk7XG4gIGxldCBzdWJtaXRJbXBsID0gdXNlU3VibWl0KCk7XG4gIGxldCBzdWJtaXQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdHMpID0+IHtcbiAgICAgIGF3YWl0IHN1Ym1pdEltcGwodGFyZ2V0LCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hlcktleVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF1cbiAgKTtcbiAgbGV0IEZldGNoZXJGb3JtID0gUmVhY3QxMC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0yID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICAgICAgKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoRm9ybSwgeyAuLi5wcm9wcywgbmF2aWdhdGU6IGZhbHNlLCBmZXRjaGVyS2V5LCByZWYgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBGZXRjaGVyRm9ybTIuZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgIHJldHVybiBGZXRjaGVyRm9ybTI7XG4gIH0sIFtmZXRjaGVyS2V5XSk7XG4gIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGZldGNoZXJLZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgbGV0IGRhdGEyID0gZmV0Y2hlckRhdGEuZ2V0KGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBGb3JtOiBGZXRjaGVyRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWQsXG4gICAgICAuLi5mZXRjaGVyLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9KSxcbiAgICBbRmV0Y2hlckZvcm0sIHN1Ym1pdCwgbG9hZCwgZmV0Y2hlciwgZGF0YTJdXG4gICk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlMihcInVzZUZldGNoZXJzXCIgLyogVXNlRmV0Y2hlcnMgKi8pO1xuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5mZXRjaGVycy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgZmV0Y2hlcl0pID0+ICh7XG4gICAgLi4uZmV0Y2hlcixcbiAgICBrZXlcbiAgfSkpO1xufVxudmFyIFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbnZhciBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHt9O1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCBnZXRLZXkpIHtcbiAgbGV0IGtleSA9IG51bGw7XG4gIGlmIChnZXRLZXkpIHtcbiAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBrZXkgPSBnZXRLZXkoXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5sb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgfVxuICB9XG4gIGlmIChrZXkgPT0gbnVsbCkge1xuICAgIGtleSA9IGxvY2F0aW9uLmtleTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXlcbn0gPSB7fSkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIgLyogVXNlU2Nyb2xsUmVzdG9yYXRpb24gKi8pO1xuICBsZXQgeyByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldCB9ID0gdXNlRGF0YVJvdXRlclN0YXRlMihcbiAgICBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIgLyogVXNlU2Nyb2xsUmVzdG9yYXRpb24gKi9cbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZVBhZ2VIaWRlKFxuICAgIFJlYWN0MTAudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSk7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoJHtlcnJvcn0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW25hdmlnYXRpb24uc3RhdGUsIGdldEtleSwgYmFzZW5hbWUsIGxvY2F0aW9uLCBtYXRjaGVzLCBzdG9yYWdlS2V5XSlcbiAgKTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgICApO1xuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlcj8uZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zLFxuICAgICAgICAoKSA9PiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgZ2V0S2V5ID8gKGxvY2F0aW9uMiwgbWF0Y2hlczIpID0+IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uMiwgbWF0Y2hlczIsIGJhc2VuYW1lLCBnZXRLZXkpIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICB9XG59XG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB2b2lkIDA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5mdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5mdW5jdGlvbiB1c2VQcm9tcHQoe1xuICB3aGVuLFxuICBtZXNzYWdlXG59KSB7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcbiAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmxvY2tlci5wcm9jZWVkLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgIXdoZW4pIHtcbiAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICB9XG4gIH0sIFtibG9ja2VyLCB3aGVuXSk7XG59XG5mdW5jdGlvbiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHRvLCBvcHRzID0ge30pIHtcbiAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChWaWV3VHJhbnNpdGlvbkNvbnRleHQpO1xuICBpbnZhcmlhbnQoXG4gICAgdnRDb250ZXh0ICE9IG51bGwsXG4gICAgXCJgdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgRGlkIHlvdSBhY2NpZGVudGFsbHkgaW1wb3J0IGBSb3V0ZXJQcm92aWRlcmAgZnJvbSBgcmVhY3Qtcm91dGVyYD9cIlxuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFxuICAgIFwidXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiIC8qIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUgKi9cbiAgKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IG9wdHMucmVsYXRpdmUgfSk7XG4gIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3VycmVudFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lO1xuICByZXR1cm4gbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIG5leHRQYXRoKSAhPSBudWxsIHx8IG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBjdXJyZW50UGF0aCkgIT0gbnVsbDtcbn1cblxuLy8gbGliL2RvbS9zZXJ2ZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDExIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gU3RhdGljUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wID0gXCIvXCJcbn0pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25Qcm9wLnBhdGhuYW1lIHx8IFwiL1wiLFxuICAgIHNlYXJjaDogbG9jYXRpb25Qcm9wLnNlYXJjaCB8fCBcIlwiLFxuICAgIGhhc2g6IGxvY2F0aW9uUHJvcC5oYXNoIHx8IFwiXCIsXG4gICAgc3RhdGU6IGxvY2F0aW9uUHJvcC5zdGF0ZSAhPSBudWxsID8gbG9jYXRpb25Qcm9wLnN0YXRlIDogbnVsbCxcbiAgICBrZXk6IGxvY2F0aW9uUHJvcC5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IGdldFN0YXRlbGVzc05hdmlnYXRvcigpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IGFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiB0cnVlXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gU3RhdGljUm91dGVyUHJvdmlkZXIoe1xuICBjb250ZXh0LFxuICByb3V0ZXIsXG4gIGh5ZHJhdGUgPSB0cnVlLFxuICBub25jZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVyICYmIGNvbnRleHQsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGByb3V0ZXJgIGFuZCBgY29udGV4dGAgdG8gPFN0YXRpY1JvdXRlclByb3ZpZGVyPlwiXG4gICk7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHtcbiAgICByb3V0ZXIsXG4gICAgbmF2aWdhdG9yOiBnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IoKSxcbiAgICBzdGF0aWM6IHRydWUsXG4gICAgc3RhdGljQ29udGV4dDogY29udGV4dCxcbiAgICBiYXNlbmFtZTogY29udGV4dC5iYXNlbmFtZSB8fCBcIi9cIlxuICB9O1xuICBsZXQgZmV0Y2hlcnNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGh5ZHJhdGVTY3JpcHQgPSBcIlwiO1xuICBpZiAoaHlkcmF0ZSAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZGF0YTIgPSB7XG4gICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycylcbiAgICB9O1xuICAgIGxldCBqc29uID0gaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShKU09OLnN0cmluZ2lmeShkYXRhMikpKTtcbiAgICBoeWRyYXRlU2NyaXB0ID0gYHdpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEgPSBKU09OLnBhcnNlKCR7anNvbn0pO2A7XG4gIH1cbiAgbGV0IHsgc3RhdGUgfSA9IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlcnNDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZTogZGF0YVJvdXRlckNvbnRleHQuYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogZGF0YVJvdXRlckNvbnRleHQubmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBEYXRhUm91dGVzMixcbiAgICAgIHtcbiAgICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9XG4gICAgKVxuICApKSkpKSwgaHlkcmF0ZVNjcmlwdCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBub25jZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaHlkcmF0ZVNjcmlwdCB9XG4gICAgfVxuICApIDogbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzMih7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIGZ1dHVyZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIiB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHtcbiAgICAgICAgbWVzc2FnZTogdmFsLm1lc3NhZ2UsXG4gICAgICAgIF9fdHlwZTogXCJFcnJvclwiLFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3ViY2xhc3MgKGkuZS4sIFJlZmVyZW5jZUVycm9yKSwgc2VuZCB1cCB0aGUgdHlwZSBzbyB3ZVxuICAgICAgICAvLyBjYW4gcmUtY3JlYXRlIHRoZSBzYW1lIHR5cGUgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgICAgLi4udmFsLm5hbWUgIT09IFwiRXJyb3JcIiA/IHtcbiAgICAgICAgICBfX3N1YlR5cGU6IHZhbC5uYW1lXG4gICAgICAgIH0gOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlbGVzc05hdmlnYXRvcigpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5wdXNoKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5yZXBsYWNlKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmdvKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtkZWx0YX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgYmFjaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5iYWNrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmZvcndhcmQoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyMihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0YXRpY0hhbmRsZXIocm91dGVzLCB7XG4gICAgLi4ub3B0cyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNSb3V0ZXIocm91dGVzLCBjb250ZXh0LCBvcHRzID0ge30pIHtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgbWF0Y2hlcyA9IGNvbnRleHQubWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3RbbWF0Y2gucm91dGUuaWRdIHx8IG1hdGNoLnJvdXRlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tYXRjaCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgfSk7XG4gIGxldCBtc2cgPSAobWV0aG9kKSA9PiBgWW91IGNhbm5vdCB1c2Ugcm91dGVyLiR7bWV0aG9kfSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudGA7XG4gIHJldHVybiB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgZnV0dXJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0cz8uZnV0dXJlXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogXCJQT1BcIiAvKiBQb3AgKi8sXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJpbml0aWFsaXplXCIpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgdGhyb3cgbXNnKFwic3Vic2NyaWJlXCIpO1xuICAgIH0sXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgICB0aHJvdyBtc2coXCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvblwiKTtcbiAgICB9LFxuICAgIG5hdmlnYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwibmF2aWdhdGVcIik7XG4gICAgfSxcbiAgICBmZXRjaCgpIHtcbiAgICAgIHRocm93IG1zZyhcImZldGNoXCIpO1xuICAgIH0sXG4gICAgcmV2YWxpZGF0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInJldmFsaWRhdGVcIik7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIGdldEZldGNoZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9GRVRDSEVSO1xuICAgIH0sXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuICAgIGdldEJsb2NrZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9CTE9DS0VSO1xuICAgIH0sXG4gICAgZGVsZXRlQmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUJsb2NrZXJcIik7XG4gICAgfSxcbiAgICBwYXRjaFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcInBhdGNoUm91dGVzXCIpO1xuICAgIH0sXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMoKSB7XG4gICAgICB0aHJvdyBtc2coXCJfaW50ZXJuYWxTZXRSb3V0ZXNcIik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gIGxldCBocmVmMiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIGhyZWYyID0gaHJlZjIucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgbGV0IGVuY29kZWQgPSBBQlNPTFVURV9VUkxfUkVHRVgzLnRlc3QoaHJlZjIpID8gbmV3IFVSTChocmVmMikgOiBuZXcgVVJMKGhyZWYyLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IGVuY29kZWQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBlbmNvZGVkLnNlYXJjaCxcbiAgICBoYXNoOiBlbmNvZGVkLmhhc2hcbiAgfTtcbn1cbnZhciBBQlNPTFVURV9VUkxfUkVHRVgzID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIEVTQ0FQRV9MT09LVVAyID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYMiA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFR0VYMiwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQMlttYXRjaF0pO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9zZXJ2ZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDEyIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gU2VydmVyUm91dGVyKHtcbiAgY29udGV4dCxcbiAgdXJsLFxuICBub25jZVxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBjcml0aWNhbENzcywgc2VydmVySGFuZG9mZlN0cmluZyB9ID0gY29udGV4dDtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICBtYW5pZmVzdC5yb3V0ZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGNvbnRleHQuZnV0dXJlLFxuICAgIGNvbnRleHQuaXNTcGFNb2RlXG4gICk7XG4gIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YSA9IHtcbiAgICAuLi5jb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFcbiAgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5tYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgcm91dGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IG1hbmlmZXN0Um91dGUgPSBjb250ZXh0Lm1hbmlmZXN0LnJvdXRlc1tyb3V0ZUlkXTtcbiAgICBpZiAocm91dGUgJiYgbWFuaWZlc3RSb3V0ZSAmJiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIobWFuaWZlc3RSb3V0ZSwgcm91dGUsIGNvbnRleHQuaXNTcGFNb2RlKSAmJiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikpIHtcbiAgICAgIGRlbGV0ZSBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXIgPSBjcmVhdGVTdGF0aWNSb3V0ZXIocm91dGVzLCBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgICBmdXR1cmU6IGNvbnRleHQuZnV0dXJlLFxuICAgICAgICBzc3I6IGNvbnRleHQuc3NyLFxuICAgICAgICBpc1NwYU1vZGU6IGNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgICBzZXJpYWxpemVFcnJvcjogY29udGV4dC5zZXJpYWxpemVFcnJvcixcbiAgICAgICAgcmVuZGVyTWV0YTogY29udGV4dC5yZW5kZXJNZXRhXG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogcm91dGVyLnN0YXRlLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICAgICAgICBoeWRyYXRlOiBmYWxzZVxuICAgICAgfVxuICAgICkpXG4gICksIGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBTdHJlYW1UcmFuc2ZlcixcbiAgICB7XG4gICAgICBjb250ZXh0LFxuICAgICAgaWRlbnRpZmllcjogMCxcbiAgICAgIHJlYWRlcjogY29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgdGV4dERlY29kZXI6IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgbm9uY2VcbiAgICB9XG4gICkpIDogbnVsbCk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy10ZXN0LXN0dWIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDEzIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzU3R1Yihyb3V0ZXMsIGNvbnRleHQgPSB7fSkge1xuICByZXR1cm4gZnVuY3Rpb24gUm91dGVzVGVzdFN0dWIoe1xuICAgIGluaXRpYWxFbnRyaWVzLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBoeWRyYXRpb25EYXRhLFxuICAgIGZ1dHVyZVxuICB9KSB7XG4gICAgbGV0IHJvdXRlclJlZiA9IFJlYWN0MTMudXNlUmVmKCk7XG4gICAgbGV0IHJlbWl4Q29udGV4dFJlZiA9IFJlYWN0MTMudXNlUmVmKCk7XG4gICAgaWYgKHJvdXRlclJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJlbWl4Q29udGV4dFJlZi5jdXJyZW50ID0ge1xuICAgICAgICBmdXR1cmU6IHt9LFxuICAgICAgICBtYW5pZmVzdDoge1xuICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgZW50cnk6IHsgaW1wb3J0czogW10sIG1vZHVsZTogXCJcIiB9LFxuICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlTW9kdWxlczoge30sXG4gICAgICAgIHNzcjogZmFsc2UsXG4gICAgICAgIGlzU3BhTW9kZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgcGF0Y2hlZCA9IHByb2Nlc3NSb3V0ZXMoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9hZGVyL2FjdGlvbiBjb250ZXh0IHR5cGVzIGRvbid0IG1hdGNoIDovXG4gICAgICAgIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCAocikgPT4gciksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJlbWl4Q29udGV4dFJlZi5jdXJyZW50Lm1hbmlmZXN0LFxuICAgICAgICByZW1peENvbnRleHRSZWYuY3VycmVudC5yb3V0ZU1vZHVsZXNcbiAgICAgICk7XG4gICAgICByb3V0ZXJSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeVJvdXRlcihwYXRjaGVkLCB7XG4gICAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGh5ZHJhdGlvbkRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByZW1peENvbnRleHRSZWYuY3VycmVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KFJvdXRlclByb3ZpZGVyLCB7IHJvdXRlcjogcm91dGVyUmVmLmN1cnJlbnQgfSkpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlcyhyb3V0ZXMsIGNvbnRleHQsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHBhcmVudElkKSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSkgPT4ge1xuICAgIGlmICghcm91dGUuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIHJvdXRlLmlkIGluIEByZW1peC1ydW4vdGVzdGluZyBwcm9jZXNzUm91dGVzKCkgZnVuY3Rpb25cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyLCBhY3Rpb24gfSA9IHJvdXRlO1xuICAgIGxldCBuZXdSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBDb21wb25lbnQ6IHJvdXRlLkNvbXBvbmVudCxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogcm91dGUuSHlkcmF0ZUZhbGxiYWNrLFxuICAgICAgRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGFjdGlvbjogYWN0aW9uID8gKGFyZ3MpID0+IGFjdGlvbih7IC4uLmFyZ3MsIGNvbnRleHQgfSkgOiB2b2lkIDAsXG4gICAgICBsb2FkZXI6IGxvYWRlciA/IChhcmdzKSA9PiBsb2FkZXIoeyAuLi5hcmdzLCBjb250ZXh0IH0pIDogdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBsZXQgZW50cnlSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIGhhc0FjdGlvbjogcm91dGUuYWN0aW9uICE9IG51bGwsXG4gICAgICBoYXNMb2FkZXI6IHJvdXRlLmxvYWRlciAhPSBudWxsLFxuICAgICAgLy8gV2hlbiB0ZXN0aW5nIHJvdXRlcywgeW91IHNob3VsZCBqdXN0IGJlIHN0dWJiaW5nIGxvYWRlci9hY3Rpb24sIG5vdFxuICAgICAgLy8gdHJ5aW5nIHRvIHJlLWltcGxlbWVudCB0aGUgZnVsbCBsb2FkZXIvY2xpZW50TG9hZGVyL1NTUi9oeWRyYXRpb24gZmxvdy5cbiAgICAgIC8vIFRoYXQgaXMgYmV0dGVyIHRlc3RlZCB2aWEgRTJFIHRlc3RzLlxuICAgICAgaGFzQ2xpZW50QWN0aW9uOiBmYWxzZSxcbiAgICAgIGhhc0NsaWVudExvYWRlcjogZmFsc2UsXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwsXG4gICAgICAvLyBhbnkgbmVlZCBmb3IgdGhlc2U/XG4gICAgICBtb2R1bGU6IFwiYnVpbGQvc3R1Yi1wYXRoLXRvLW1vZHVsZS5qc1wiLFxuICAgICAgY2xpZW50QWN0aW9uTW9kdWxlOiB2b2lkIDAsXG4gICAgICBjbGllbnRMb2FkZXJNb2R1bGU6IHZvaWQgMCxcbiAgICAgIGh5ZHJhdGVGYWxsYmFja01vZHVsZTogdm9pZCAwXG4gICAgfTtcbiAgICBtYW5pZmVzdC5yb3V0ZXNbbmV3Um91dGUuaWRdID0gZW50cnlSb3V0ZTtcbiAgICByb3V0ZU1vZHVsZXNbcm91dGUuaWRdID0ge1xuICAgICAgZGVmYXVsdDogcm91dGUuQ29tcG9uZW50IHx8IE91dGxldCxcbiAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgfHwgdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBsaW5rczogcm91dGUubGlua3MsXG4gICAgICBtZXRhOiByb3V0ZS5tZXRhLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICBuZXdSb3V0ZS5jaGlsZHJlbiA9IHByb2Nlc3NSb3V0ZXMoXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgICBuZXdSb3V0ZS5pZFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JvdXRlO1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Nvb2tpZXMudHNcbmltcG9ydCB7IHBhcnNlLCBzZXJpYWxpemUgfSBmcm9tIFwiY29va2llXCI7XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jcnlwdG8udHNcbnZhciBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG52YXIgc2lnbiA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGxldCBkYXRhMiA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IGtleSA9IGF3YWl0IGNyZWF0ZUtleTIoc2VjcmV0LCBbXCJzaWduXCJdKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihcIkhNQUNcIiwga2V5LCBkYXRhMik7XG4gIGxldCBoYXNoID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKS5yZXBsYWNlKFxuICAgIC89KyQvLFxuICAgIFwiXCJcbiAgKTtcbiAgcmV0dXJuIHZhbHVlICsgXCIuXCIgKyBoYXNoO1xufTtcbnZhciB1bnNpZ24gPSBhc3luYyAoY29va2llLCBzZWNyZXQpID0+IHtcbiAgbGV0IGluZGV4ID0gY29va2llLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgbGV0IHZhbHVlID0gY29va2llLnNsaWNlKDAsIGluZGV4KTtcbiAgbGV0IGhhc2ggPSBjb29raWUuc2xpY2UoaW5kZXggKyAxKTtcbiAgbGV0IGRhdGEyID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQga2V5ID0gYXdhaXQgY3JlYXRlS2V5MihzZWNyZXQsIFtcInZlcmlmeVwiXSk7XG4gIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICBsZXQgdmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShcIkhNQUNcIiwga2V5LCBzaWduYXR1cmUsIGRhdGEyKTtcbiAgcmV0dXJuIHZhbGlkID8gdmFsdWUgOiBmYWxzZTtcbn07XG52YXIgY3JlYXRlS2V5MiA9IGFzeW5jIChzZWNyZXQsIHVzYWdlcykgPT4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gIFwicmF3XCIsXG4gIGVuY29kZXIuZW5jb2RlKHNlY3JldCksXG4gIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH0sXG4gIGZhbHNlLFxuICB1c2FnZXNcbik7XG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jb29raWVzLnRzXG52YXIgY3JlYXRlQ29va2llID0gKG5hbWUsIGNvb2tpZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgeyBzZWNyZXRzID0gW10sIC4uLm9wdGlvbnMgfSA9IHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICAuLi5jb29raWVPcHRpb25zXG4gIH07XG4gIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIG9wdGlvbnMuZXhwaXJlcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIGdldCBpc1NpZ25lZCgpIHtcbiAgICAgIHJldHVybiBzZWNyZXRzLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICBnZXQgZXhwaXJlcygpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucy5leHBpcmVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoY29va2llSGVhZGVyLCBwYXJzZU9wdGlvbnMpIHtcbiAgICAgIGlmICghY29va2llSGVhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBjb29raWVzID0gcGFyc2UoY29va2llSGVhZGVyLCB7IC4uLm9wdGlvbnMsIC4uLnBhcnNlT3B0aW9ucyB9KTtcbiAgICAgIGlmIChuYW1lIGluIGNvb2tpZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29va2llc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpO1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlcmlhbGl6ZSh2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUgPT09IFwiXCIgPyBcIlwiIDogYXdhaXQgZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5zZXJpYWxpemVPcHRpb25zXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc0Nvb2tpZSA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmlzU2lnbmVkID09PSBcImJvb2xlYW5cIiAmJiB0eXBlb2Ygb2JqZWN0LnBhcnNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBsZXQgZW5jb2RlZCA9IGVuY29kZURhdGEodmFsdWUpO1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZW5jb2RlZCA9IGF3YWl0IHNpZ24oZW5jb2RlZCwgc2VjcmV0c1swXSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChsZXQgc2VjcmV0IG9mIHNlY3JldHMpIHtcbiAgICAgIGxldCB1bnNpZ25lZFZhbHVlID0gYXdhaXQgdW5zaWduKHZhbHVlLCBzZWNyZXQpO1xuICAgICAgaWYgKHVuc2lnbmVkVmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVEYXRhKHVuc2lnbmVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZGVjb2RlRGF0YSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKHZhbHVlKSB7XG4gIHJldHVybiBidG9hKG15VW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZURhdGEodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQobXlFc2NhcGUoYXRvYih2YWx1ZSkpKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5mdW5jdGlvbiBteUVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIGNvZGU7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmICgvW1xcdyorXFwtLi9AXS8uZXhlYyhjaHIpKSB7XG4gICAgICByZXN1bHQgKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICByZXN1bHQgKz0gXCIlXCIgKyBoZXgoY29kZSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gXCIldVwiICsgaGV4KGNvZGUsIDQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoZXgoY29kZSwgbGVuZ3RoKSB7XG4gIGxldCByZXN1bHQgPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGgpIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXlVbmVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIHBhcnQ7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmIChjaHIgPT09IFwiJVwiKSB7XG4gICAgICBpZiAoc3RyLmNoYXJBdChpbmRleCkgPT09IFwidVwiKSB7XG4gICAgICAgIHBhcnQgPSBzdHIuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDUpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXs0fSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4LCBpbmRleCArIDIpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXsyfSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCArPSBjaHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIGV4cGlyZXMpIHtcbiAgd2Fybk9uY2UoXG4gICAgIWV4cGlyZXMsXG4gICAgYFRoZSBcIiR7bmFtZX1cIiBjb29raWUgaGFzIGFuIFwiZXhwaXJlc1wiIHByb3BlcnR5IHNldC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBleHBpcmVzIHZhbHVlIHRvIG5vdCBiZSB1cGRhdGVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY29tbWl0dGVkLiBJbnN0ZWFkLCB5b3Ugc2hvdWxkIHNldCB0aGUgZXhwaXJlcyB2YWx1ZSB3aGVuIHNlcmlhbGl6aW5nIHRoZSBjb29raWUuIFlvdSBjYW4gdXNlIFxcYGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgeyBleHBpcmVzIH0pXFxgIGlmIHVzaW5nIGEgc2Vzc2lvbiBzdG9yYWdlIG9iamVjdCwgb3IgXFxgY29va2llLnNlcmlhbGl6ZShcInZhbHVlXCIsIHsgZXhwaXJlcyB9KVxcYCBpZiB5b3UncmUgdXNpbmcgdGhlIGNvb2tpZSBkaXJlY3RseS5gXG4gICk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lbnRyeS50c1xuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8yLCByb3V0ZUlkKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBtZW1vMltyb3V0ZUlkXSA9IHJvdXRlLm1vZHVsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW8yO1xuICB9LCB7fSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tb2RlLnRzXG52YXIgU2VydmVyTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1vZGUyKSA9PiB7XG4gIFNlcnZlck1vZGUyW1wiRGV2ZWxvcG1lbnRcIl0gPSBcImRldmVsb3BtZW50XCI7XG4gIFNlcnZlck1vZGUyW1wiUHJvZHVjdGlvblwiXSA9IFwicHJvZHVjdGlvblwiO1xuICBTZXJ2ZXJNb2RlMltcIlRlc3RcIl0gPSBcInRlc3RcIjtcbiAgcmV0dXJuIFNlcnZlck1vZGUyO1xufSkoU2VydmVyTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1NlcnZlck1vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8gfHwgdmFsdWUgPT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8gfHwgdmFsdWUgPT09IFwidGVzdFwiIC8qIFRlc3QgKi87XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lcnJvcnMudHNcbmZ1bmN0aW9uIHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgc2VydmVyTW9kZSAhPT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgbGV0IHNhbml0aXplZCA9IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpO1xuICAgIHNhbml0aXplZC5zdGFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gc2FuaXRpemVkO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXJyb3JzKGVycm9ycywgc2VydmVyTW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZXJyb3JzKS5yZWR1Y2UoKGFjYywgW3JvdXRlSWQsIGVycm9yXSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbcm91dGVJZF06IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIH0pO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogc2FuaXRpemVkLm1lc3NhZ2UsXG4gICAgc3RhY2s6IHNhbml0aXplZC5zdGFja1xuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3JzMihlcnJvcnMsIHNlcnZlck1vZGUpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplRXJyb3IodmFsLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHtcbiAgICAgICAgbWVzc2FnZTogc2FuaXRpemVkLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBzYW5pdGl6ZWQuc3RhY2ssXG4gICAgICAgIF9fdHlwZTogXCJFcnJvclwiLFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3ViY2xhc3MgKGkuZS4sIFJlZmVyZW5jZUVycm9yKSwgc2VuZCB1cCB0aGUgdHlwZSBzbyB3ZVxuICAgICAgICAvLyBjYW4gcmUtY3JlYXRlIHRoZSBzYW1lIHR5cGUgZHVyaW5nIGh5ZHJhdGlvbi4gIFRoaXMgd2lsbCBvbmx5IGFwcGx5XG4gICAgICAgIC8vIGluIGRldiBtb2RlIHNpbmNlIGFsbCBwcm9kdWN0aW9uIGVycm9ycyBhcmUgc2FuaXRpemVkIHRvIG5vcm1hbFxuICAgICAgICAvLyBFcnJvciBpbnN0YW5jZXNcbiAgICAgICAgLi4uc2FuaXRpemVkLm5hbWUgIT09IFwiRXJyb3JcIiA/IHtcbiAgICAgICAgICBfX3N1YlR5cGU6IHNhbml0aXplZC5uYW1lXG4gICAgICAgIH0gOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3JvdXRlTWF0Y2hpbmcudHNcbmZ1bmN0aW9uIG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIHBhdGhuYW1lLFxuICAgIGJhc2VuYW1lXG4gICk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcCgobWF0Y2gpID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiBtYXRjaC5yb3V0ZVxuICB9KSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9kYXRhLnRzXG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVIYW5kbGVyKGhhbmRsZXIsIGFyZ3MpIHtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoe1xuICAgIHJlcXVlc3Q6IHN0cmlwUm91dGVzUGFyYW0oc3RyaXBJbmRleFBhcmFtMihhcmdzLnJlcXVlc3QpKSxcbiAgICBwYXJhbXM6IGFyZ3MucGFyYW1zLFxuICAgIGNvbnRleHQ6IGFyZ3MuY29udGV4dFxuICB9KTtcbiAgaWYgKGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0KSAmJiByZXN1bHQuaW5pdCAmJiByZXN1bHQuaW5pdC5zdGF0dXMgJiYgaXNSZWRpcmVjdFN0YXR1c0NvZGUocmVzdWx0LmluaXQuc3RhdHVzKSkge1xuICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCByZXN1bHQuaW5pdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHN0cmlwSW5kZXhQYXJhbTIocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIGxldCBpbmRleFZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gIGxldCBpbmRleFZhbHVlc1RvS2VlcCA9IFtdO1xuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuICBsZXQgaW5pdCA9IHtcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICB9O1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaW5pdC5kdXBsZXggPSBcImhhbGZcIjtcbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIGluaXQpO1xufVxuZnVuY3Rpb24gc3RyaXBSb3V0ZXNQYXJhbShyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJfcm91dGVzXCIpO1xuICBsZXQgaW5pdCA9IHtcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICB9O1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaW5pdC5kdXBsZXggPSBcImhhbGZcIjtcbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIGluaXQpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvaW52YXJpYW50LnRzXG5mdW5jdGlvbiBpbnZhcmlhbnQzKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiVGhlIGZvbGxvd2luZyBlcnJvciBpcyBhIGJ1ZyBpbiBSZWFjdCBSb3V0ZXI7IHBsZWFzZSBvcGVuIGFuIGlzc3VlISBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvbmV3L2Nob29zZVwiXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3JvdXRlcy50c1xuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkge1xuICBsZXQgcm91dGVzID0ge307XG4gIE9iamVjdC52YWx1ZXMobWFuaWZlc3QpLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBsZXQgcGFyZW50SWQgPSByb3V0ZS5wYXJlbnRJZCB8fCBcIlwiO1xuICAgICAgaWYgKCFyb3V0ZXNbcGFyZW50SWRdKSB7XG4gICAgICAgIHJvdXRlc1twYXJlbnRJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlc1twYXJlbnRJZF0ucHVzaChyb3V0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcGFyZW50SWQgPSBcIlwiLCByb3V0ZXNCeVBhcmVudElkID0gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4gKHtcbiAgICAuLi5yb3V0ZSxcbiAgICBjaGlsZHJlbjogY3JlYXRlUm91dGVzKG1hbmlmZXN0LCByb3V0ZS5pZCwgcm91dGVzQnlQYXJlbnRJZClcbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMobWFuaWZlc3QsIGZ1dHVyZSwgcGFyZW50SWQgPSBcIlwiLCByb3V0ZXNCeVBhcmVudElkID0gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4ge1xuICAgIGxldCBjb21tb25Sb3V0ZSA9IHtcbiAgICAgIC8vIEFsd2F5cyBpbmNsdWRlIHJvb3QgZHVlIHRvIGRlZmF1bHQgYm91bmRhcmllc1xuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuaWQgPT09IFwicm9vdFwiIHx8IHJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwsXG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgLy8gTmVlZCB0byB1c2UgUlIncyB2ZXJzaW9uIGluIHRoZSBwYXJhbSB0eXBlZCBoZXJlIHRvIHBlcm1pdCB0aGUgb3B0aW9uYWxcbiAgICAgIC8vIGNvbnRleHQgZXZlbiB0aG91Z2ggd2Uga25vdyBpdCdsbCBhbHdheXMgYmUgcHJvdmlkZWQgaW4gcmVtaXhcbiAgICAgIGxvYWRlcjogcm91dGUubW9kdWxlLmxvYWRlciA/IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLnJlcXVlc3QuaGVhZGVycy5oYXMoXCJYLVJlYWN0LVJvdXRlci1QcmVyZW5kZXItRGF0YVwiKSkge1xuICAgICAgICAgIGNvbnN0IHByZVJlbmRlcmVkRGF0YSA9IGFyZ3MucmVxdWVzdC5oZWFkZXJzLmdldChcbiAgICAgICAgICAgIFwiWC1SZWFjdC1Sb3V0ZXItUHJlcmVuZGVyLURhdGFcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IGVuY29kZWQgPSBwcmVSZW5kZXJlZERhdGEgPyBkZWNvZGVVUkkocHJlUmVuZGVyZWREYXRhKSA6IHByZVJlbmRlcmVkRGF0YTtcbiAgICAgICAgICBpbnZhcmlhbnQzKGVuY29kZWQsIFwiTWlzc2luZyBwcmVyZW5kZXJlZCBkYXRhIGZvciByb3V0ZVwiKTtcbiAgICAgICAgICBsZXQgdWludDhhcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShlbmNvZGVkKTtcbiAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHVpbnQ4YXJyYXkpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVWaWFUdXJib1N0cmVhbShzdHJlYW0sIGdsb2JhbCk7XG4gICAgICAgICAgbGV0IGRhdGEyID0gZGVjb2RlZC52YWx1ZTtcbiAgICAgICAgICBpbnZhcmlhbnQzKFxuICAgICAgICAgICAgZGF0YTIgJiYgcm91dGUuaWQgaW4gZGF0YTIsXG4gICAgICAgICAgICBcIlVuYWJsZSB0byBkZWNvZGUgcHJlcmVuZGVyZWQgZGF0YVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZGF0YTJbcm91dGUuaWRdO1xuICAgICAgICAgIGludmFyaWFudDMoXCJkYXRhXCIgaW4gcmVzdWx0LCBcIlVuYWJsZSB0byBwcm9jZXNzIHByZXJlbmRlcmVkIGRhdGFcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5sb2FkZXIsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSA6IHZvaWQgMCxcbiAgICAgIGFjdGlvbjogcm91dGUubW9kdWxlLmFjdGlvbiA/IChhcmdzKSA9PiBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5hY3Rpb24sIGFyZ3MpIDogdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5tb2R1bGUuaGFuZGxlXG4gICAgfTtcbiAgICByZXR1cm4gcm91dGUuaW5kZXggPyB7XG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfSA6IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICBjaGlsZHJlbjogY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMoXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBmdXR1cmUsXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZXNCeVBhcmVudElkXG4gICAgICApLFxuICAgICAgLi4uY29tbW9uUm91dGVcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAzID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYMyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sMihodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYMywgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQM1ttYXRjaF0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2VydmVySGFuZG9mZi50c1xuZnVuY3Rpb24gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sMihKU09OLnN0cmluZ2lmeShzZXJ2ZXJIYW5kb2ZmKSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9kZXYudHNcbnZhciBnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleSA9IFwiX19yZWFjdFJvdXRlckRldlNlcnZlckhvb2tzXCI7XG5mdW5jdGlvbiBzZXREZXZTZXJ2ZXJIb29rcyhkZXZTZXJ2ZXJIb29rcykge1xuICBnbG9iYWxUaGlzW2dsb2JhbERldlNlcnZlckhvb2tzS2V5XSA9IGRldlNlcnZlckhvb2tzO1xufVxuZnVuY3Rpb24gZ2V0RGV2U2VydmVySG9va3MoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERldlNlcnZlckhvb2tzS2V5XTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NpbmdsZS1mZXRjaC50c1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcInR1cmJvLXN0cmVhbVwiO1xuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvaGVhZGVycy50c1xuaW1wb3J0IHsgc3BsaXRDb29raWVzU3RyaW5nIH0gZnJvbSBcInNldC1jb29raWUtcGFyc2VyXCI7XG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpIHtcbiAgbGV0IGJvdW5kYXJ5SWR4ID0gY29udGV4dC5lcnJvcnMgPyBjb250ZXh0Lm1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBjb250ZXh0LmVycm9yc1ttLnJvdXRlLmlkXSkgOiAtMTtcbiAgbGV0IG1hdGNoZXMgPSBib3VuZGFyeUlkeCA+PSAwID8gY29udGV4dC5tYXRjaGVzLnNsaWNlKDAsIGJvdW5kYXJ5SWR4ICsgMSkgOiBjb250ZXh0Lm1hdGNoZXM7XG4gIGxldCBlcnJvckhlYWRlcnM7XG4gIGlmIChib3VuZGFyeUlkeCA+PSAwKSB7XG4gICAgbGV0IHsgYWN0aW9uSGVhZGVycywgYWN0aW9uRGF0YSwgbG9hZGVySGVhZGVycywgbG9hZGVyRGF0YSB9ID0gY29udGV4dDtcbiAgICBjb250ZXh0Lm1hdGNoZXMuc2xpY2UoYm91bmRhcnlJZHgpLnNvbWUoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICAgIGlmIChhY3Rpb25IZWFkZXJzW2lkXSAmJiAoIWFjdGlvbkRhdGEgfHwgIWFjdGlvbkRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBhY3Rpb25IZWFkZXJzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAobG9hZGVySGVhZGVyc1tpZF0gJiYgIWxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGVycm9ySGVhZGVycyA9IGxvYWRlckhlYWRlcnNbaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9ySGVhZGVycyAhPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZSgocGFyZW50SGVhZGVycywgbWF0Y2gsIGlkeCkgPT4ge1xuICAgIGxldCB7IGlkIH0gPSBtYXRjaC5yb3V0ZTtcbiAgICBsZXQgcm91dGUgPSBidWlsZC5yb3V0ZXNbaWRdO1xuICAgIGludmFyaWFudDMocm91dGUsIGBSb3V0ZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQgaW4gYnVpbGRgKTtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZS5tb2R1bGU7XG4gICAgbGV0IGxvYWRlckhlYWRlcnMgPSBjb250ZXh0LmxvYWRlckhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGFjdGlvbkhlYWRlcnMgPSBjb250ZXh0LmFjdGlvbkhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGluY2x1ZGVFcnJvckhlYWRlcnMgPSBlcnJvckhlYWRlcnMgIT0gbnVsbCAmJiBpZHggPT09IG1hdGNoZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaW5jbHVkZUVycm9yQ29va2llcyA9IGluY2x1ZGVFcnJvckhlYWRlcnMgJiYgZXJyb3JIZWFkZXJzICE9PSBsb2FkZXJIZWFkZXJzICYmIGVycm9ySGVhZGVycyAhPT0gYWN0aW9uSGVhZGVycztcbiAgICBpZiAocm91dGVNb2R1bGUuaGVhZGVycyA9PSBudWxsKSB7XG4gICAgICBsZXQgaGVhZGVyczIgPSBuZXcgSGVhZGVycyhwYXJlbnRIZWFkZXJzKTtcbiAgICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICAgIHByZXBlbmRDb29raWVzKGVycm9ySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgfVxuICAgICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcmV0dXJuIGhlYWRlcnMyO1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKFxuICAgICAgcm91dGVNb2R1bGUuaGVhZGVycyA/IHR5cGVvZiByb3V0ZU1vZHVsZS5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5oZWFkZXJzKHtcbiAgICAgICAgbG9hZGVySGVhZGVycyxcbiAgICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgICAgYWN0aW9uSGVhZGVycyxcbiAgICAgICAgZXJyb3JIZWFkZXJzOiBpbmNsdWRlRXJyb3JIZWFkZXJzID8gZXJyb3JIZWFkZXJzIDogdm9pZCAwXG4gICAgICB9KSA6IHJvdXRlTW9kdWxlLmhlYWRlcnMgOiB2b2lkIDBcbiAgICApO1xuICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBjaGlsZEhlYWRlcnMpIHtcbiAgbGV0IHBhcmVudFNldENvb2tpZVN0cmluZyA9IHBhcmVudEhlYWRlcnMuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcbiAgaWYgKHBhcmVudFNldENvb2tpZVN0cmluZykge1xuICAgIGxldCBjb29raWVzID0gc3BsaXRDb29raWVzU3RyaW5nKHBhcmVudFNldENvb2tpZVN0cmluZyk7XG4gICAgbGV0IGNoaWxkQ29va2llcyA9IG5ldyBTZXQoY2hpbGRIZWFkZXJzLmdldFNldENvb2tpZSgpKTtcbiAgICBjb29raWVzLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgaWYgKCFjaGlsZENvb2tpZXMuaGFzKGNvb2tpZSkpIHtcbiAgICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2luZ2xlLWZldGNoLnRzXG52YXIgU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyA9IDIwMjtcbmZ1bmN0aW9uIGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5Mih7XG4gIGlzQWN0aW9uRGF0YVJlcXVlc3QsXG4gIGxvYWRSb3V0ZUlkc1xufSA9IHt9KSB7XG4gIHJldHVybiBhc3luYyAoeyByZXF1ZXN0LCBtYXRjaGVzIH0pID0+IHtcbiAgICBpZiAoaXNBY3Rpb25EYXRhUmVxdWVzdCAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGxvYWRSb3V0ZUlkcyA/IG1hdGNoZXMuZmlsdGVyKChtKSA9PiBsb2FkUm91dGVJZHMuaW5jbHVkZXMobS5yb3V0ZS5pZCkpIDogbWF0Y2hlcztcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yZXNvbHZlKCkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoXG4gICAgICAoYWNjLCByZXN1bHQsIGkpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttYXRjaGVzVG9Mb2FkW2ldLnJvdXRlLmlkXTogcmVzdWx0IH0pLFxuICAgICAge31cbiAgICApO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb24oYnVpbGQsIHNlcnZlck1vZGUsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGhhbmRsZXJVcmwsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGhhbmRsZXJVcmwsIHtcbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuICAgICAgLi4ucmVxdWVzdC5ib2R5ID8geyBkdXBsZXg6IFwiaGFsZlwiIH0gOiB2b2lkIDBcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShoYW5kbGVyUmVxdWVzdCwge1xuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IHRydWUsXG4gICAgICBkYXRhU3RyYXRlZ3k6IGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5Mih7XG4gICAgICAgIGlzQWN0aW9uRGF0YVJlcXVlc3Q6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgIHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHQgPSByZXN1bHQ7XG4gICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICAgIGlmIChpc1JlZGlyZWN0U3RhdHVzQ29kZShjb250ZXh0LnN0YXR1c0NvZGUpICYmIGhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICApLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycykuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnRleHQuZXJyb3JzID0gc2FuaXRpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBsZXQgc2luZ2xlRmV0Y2hSZXN1bHQ7XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBzaW5nbGVGZXRjaFJlc3VsdCA9IHsgZXJyb3I6IE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpWzBdIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbmdsZUZldGNoUmVzdWx0ID0geyBkYXRhOiBPYmplY3QudmFsdWVzKGNvbnRleHQuYWN0aW9uRGF0YSB8fCB7fSlbMF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogc2luZ2xlRmV0Y2hSZXN1bHQsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc3RhdHVzOiBjb250ZXh0LnN0YXR1c0NvZGVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7IGVycm9yIH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlcnMoYnVpbGQsIHNlcnZlck1vZGUsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGhhbmRsZXJVcmwsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGhhbmRsZXJVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgbG9hZFJvdXRlSWRzID0gbmV3IFVSTChyZXF1ZXN0LnVybCkuc2VhcmNoUGFyYW1zLmdldChcIl9yb3V0ZXNcIik/LnNwbGl0KFwiLFwiKSB8fCB2b2lkIDA7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0hhbmRsZXIucXVlcnkoaGFuZGxlclJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nOiB0cnVlLFxuICAgICAgZGF0YVN0cmF0ZWd5OiBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneTIoe1xuICAgICAgICBsb2FkUm91dGVJZHNcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjb250ZXh0ID0gcmVzdWx0O1xuICAgIGxldCBoZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KTtcbiAgICBpZiAoaXNSZWRpcmVjdFN0YXR1c0NvZGUoY29udGV4dC5zdGF0dXNDb2RlKSAmJiBoZWFkZXJzLmhhcyhcIkxvY2F0aW9uXCIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKS5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzID0ge307XG4gICAgbGV0IGxvYWRlZE1hdGNoZXMgPSBsb2FkUm91dGVJZHMgPyBjb250ZXh0Lm1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0ucm91dGUubG9hZGVyICYmIGxvYWRSb3V0ZUlkcy5pbmNsdWRlcyhtLnJvdXRlLmlkKVxuICAgICkgOiBjb250ZXh0Lm1hdGNoZXM7XG4gICAgbG9hZGVkTWF0Y2hlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgICBsZXQgeyBpZCB9ID0gbS5yb3V0ZTtcbiAgICAgIGlmIChjb250ZXh0LmVycm9ycyAmJiBjb250ZXh0LmVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGVycm9yOiBjb250ZXh0LmVycm9yc1tpZF0gfTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5sb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICByZXN1bHRzW2lkXSA9IHsgZGF0YTogY29udGV4dC5sb2FkZXJEYXRhW2lkXSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc3RhdHVzOiBjb250ZXh0LnN0YXR1c0NvZGVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7IHJvb3Q6IHsgZXJyb3IgfSB9LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICAgIHN0YXR1czogNTAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChzdGF0dXMsIGhlYWRlcnMsIGJhc2VuYW1lKSB7XG4gIGxldCByZWRpcmVjdDIgPSBoZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICBpZiAoYmFzZW5hbWUpIHtcbiAgICByZWRpcmVjdDIgPSBzdHJpcEJhc2VuYW1lKHJlZGlyZWN0MiwgYmFzZW5hbWUpIHx8IHJlZGlyZWN0MjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlZGlyZWN0OiByZWRpcmVjdDIsXG4gICAgc3RhdHVzLFxuICAgIHJldmFsaWRhdGU6IChcbiAgICAgIC8vIFRlY2huaWNhbGx5IFgtUmVtaXgtUmV2YWxpZGF0ZSBpc24ndCBuZWVkZWQgaGVyZSAtIHRoYXQgd2FzIGFuIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBkZXRhaWwgb2YgP19kYXRhIHJlcXVlc3RzIGFzIG91ciB3YXkgdG8gdGVsbCB0aGUgZnJvbnQgZW5kIHRvIHJldmFsaWRhdGUgd2hlblxuICAgICAgLy8gd2UgZGlkbid0IGhhdmUgYSByZXNwb25zZSBib2R5IHRvIGluY2x1ZGUgdGhhdCBpbmZvcm1hdGlvbiBpbi5cbiAgICAgIC8vIFdpdGggc2luZ2xlIGZldGNoLCB3ZSB0ZWxsIHRoZSBmcm9udCBlbmQgdmlhIHRoaXMgcmV2YWxpZGF0ZSBib29sZWFuIGZpZWxkLlxuICAgICAgLy8gSG93ZXZlciwgd2UncmUgcmVzcGVjdGluZyBpdCBmb3Igbm93IGJlY2F1c2UgaXQgbWF5IGJlIHNvbWV0aGluZyBmb2xrcyBoYXZlXG4gICAgICAvLyB1c2VkIGluIHRoZWlyIG93biByZXNwb25zZXNcbiAgICAgIC8vIFRPRE8odjMpOiBDb25zaWRlciByZW1vdmluZyBvciBtYWtpbmcgdGhpcyBvZmZpY2lhbCBwdWJsaWMgQVBJXG4gICAgICBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSB8fCBoZWFkZXJzLmhhcyhcIlNldC1Db29raWVcIilcbiAgICApLFxuICAgIHJlbG9hZDogaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSxcbiAgICByZXBsYWNlOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVwbGFjZVwiKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlVmlhVHVyYm9TdHJlYW0oZGF0YTIsIHJlcXVlc3RTaWduYWwsIHN0cmVhbVRpbWVvdXQsIHNlcnZlck1vZGUpIHtcbiAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGxldCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICgpID0+IGNvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKFwiU2VydmVyIFRpbWVvdXRcIikpLFxuICAgIHR5cGVvZiBzdHJlYW1UaW1lb3V0ID09PSBcIm51bWJlclwiID8gc3RyZWFtVGltZW91dCA6IDQ5NTBcbiAgKTtcbiAgcmVxdWVzdFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkpO1xuICByZXR1cm4gZW5jb2RlKGRhdGEyLCB7XG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICBwbHVnaW5zOiBbXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBsZXQgeyBuYW1lLCBtZXNzYWdlLCBzdGFjayB9ID0gc2VydmVyTW9kZSA9PT0gXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLyA/IHNhbml0aXplRXJyb3IodmFsdWUsIHNlcnZlck1vZGUpIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIFtcIlNhbml0aXplZEVycm9yXCIsIG5hbWUsIG1lc3NhZ2UsIHN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvclJlc3BvbnNlSW1wbCkge1xuICAgICAgICAgIGxldCB7IGRhdGE6IGRhdGEzLCBzdGF0dXMsIHN0YXR1c1RleHQgfSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBbXCJFcnJvclJlc3BvbnNlXCIsIGRhdGEzLCBzdGF0dXMsIHN0YXR1c1RleHRdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCBpbiB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBbXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIsIHZhbHVlW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0sXG4gICAgcG9zdFBsdWdpbnM6IFtcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcIlNpbmdsZUZldGNoQ2xhc3NJbnN0YW5jZVwiLFxuICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkpXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKCkgPT4gW1wiU2luZ2xlRmV0Y2hGYWxsYmFja1wiXVxuICAgIF1cbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXJ2ZXIudHNcbnZhciBOT19CT0RZX1NUQVRVU19DT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsxMDAsIDEwMSwgMjA0LCAyMDUsIDMwNF0pO1xuZnVuY3Rpb24gZGVyaXZlKGJ1aWxkLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhidWlsZC5yb3V0ZXMsIGJ1aWxkLmZ1dHVyZSk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi87XG4gIGxldCBzdGF0aWNIYW5kbGVyID0gY3JlYXRlU3RhdGljSGFuZGxlcihkYXRhUm91dGVzLCB7XG4gICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lXG4gIH0pO1xuICBsZXQgZXJyb3JIYW5kbGVyID0gYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZUVycm9yIHx8ICgoZXJyb3IsIHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFwidGVzdFwiIC8qIFRlc3QgKi8gJiYgIXJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSAmJiBlcnJvci5lcnJvciA/IGVycm9yLmVycm9yIDogZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXMsXG4gICAgZGF0YVJvdXRlcyxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyXG4gIH07XG59XG52YXIgY3JlYXRlUmVxdWVzdEhhbmRsZXIgPSAoYnVpbGQsIG1vZGUpID0+IHtcbiAgbGV0IF9idWlsZDtcbiAgbGV0IHJvdXRlcztcbiAgbGV0IHNlcnZlck1vZGU7XG4gIGxldCBzdGF0aWNIYW5kbGVyO1xuICBsZXQgZXJyb3JIYW5kbGVyO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgbG9hZENvbnRleHQgPSB7fSkge1xuICAgIF9idWlsZCA9IHR5cGVvZiBidWlsZCA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgYnVpbGQoKSA6IGJ1aWxkO1xuICAgIGlmICh0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9IGVsc2UgaWYgKCFyb3V0ZXMgfHwgIXNlcnZlck1vZGUgfHwgIXN0YXRpY0hhbmRsZXIgfHwgIWVycm9ySGFuZGxlcikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IHVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC5kYXRhJC8sIFwiXCIpLnJlcGxhY2UoL15cXC9fcm9vdCQvLCBcIi9cIik7XG4gICAgaWYgKG5vcm1hbGl6ZWRQYXRoICE9PSBcIi9cIiAmJiBub3JtYWxpemVkUGF0aC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplZFBhdGguc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgbGV0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgICAgIGdldERldlNlcnZlckhvb2tzKCk/LnByb2Nlc3NSZXF1ZXN0RXJyb3I/LihlcnJvcik7XG4gICAgICB9XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIV9idWlsZC5zc3IpIHtcbiAgICAgIGlmIChfYnVpbGQucHJlcmVuZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KFwiWC1SZWFjdC1Sb3V0ZXItU1BBLU1vZGVcIiwgXCJ5ZXNcIik7XG4gICAgICB9IGVsc2UgaWYgKCFfYnVpbGQucHJlcmVuZGVyLmluY2x1ZGVzKG5vcm1hbGl6ZWRQYXRoKSAmJiAhX2J1aWxkLnByZXJlbmRlci5pbmNsdWRlcyhub3JtYWxpemVkUGF0aCArIFwiL1wiKSkge1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoXG4gICAgICAgICAgICBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICAgIDQwNCxcbiAgICAgICAgICAgICAgXCJOb3QgRm91bmRcIixcbiAgICAgICAgICAgICAgYFJlZnVzaW5nIHRvIFNTUiB0aGUgcGF0aCBcXGAke25vcm1hbGl6ZWRQYXRofVxcYCBiZWNhdXNlIFxcYHNzcjpmYWxzZVxcYCBpcyBzZXQgYW5kIHRoZSBwYXRoIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgXFxgcHJlcmVuZGVyXFxgIGNvbmZpZywgc28gaW4gcHJvZHVjdGlvbiB0aGUgcGF0aCB3aWxsIGJlIGEgNDA0LmBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJOb3QgRm91bmRcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldChcIlgtUmVhY3QtUm91dGVyLVNQQS1Nb2RlXCIsIFwieWVzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYW5pZmVzdFVybCA9IGAke19idWlsZC5iYXNlbmFtZSA/PyBcIi9cIn0vX19tYW5pZmVzdGAucmVwbGFjZShcbiAgICAgIC9cXC8rL2csXG4gICAgICBcIi9cIlxuICAgICk7XG4gICAgaWYgKHVybC5wYXRobmFtZSA9PT0gbWFuaWZlc3RVcmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoX2J1aWxkLCByb3V0ZXMsIHVybCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIiwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHVybC5wYXRobmFtZSwgX2J1aWxkLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBtYXRjaGVzWzBdLnBhcmFtcyk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZTtcbiAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgIGxldCBoYW5kbGVyVXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBoYW5kbGVyVXJsLnBhdGhuYW1lID0gbm9ybWFsaXplZFBhdGg7XG4gICAgICBsZXQgc2luZ2xlRmV0Y2hNYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgaGFuZGxlclVybC5wYXRobmFtZSxcbiAgICAgICAgX2J1aWxkLmJhc2VuYW1lXG4gICAgICApO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgaGFuZGxlclVybCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yXG4gICAgICApO1xuICAgICAgaWYgKF9idWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLCB7XG4gICAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgICAgcGFyYW1zOiBzaW5nbGVGZXRjaE1hdGNoZXMgPyBzaW5nbGVGZXRjaE1hdGNoZXNbMF0ucGFyYW1zIDoge30sXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICBfYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgICAgICBfYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5kZWZhdWx0ID09IG51bGwgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ID09IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBzdGF0aWNIYW5kbGVyLFxuICAgICAgICBtYXRjaGVzLnNsaWNlKC0xKVswXS5yb3V0ZS5pZCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3JpdGljYWxDc3MgPSBtb2RlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8gPyBhd2FpdCBnZXREZXZTZXJ2ZXJIb29rcygpPy5nZXRDcml0aWNhbENzcz8uKF9idWlsZCwgdXJsLnBhdGhuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgY3JpdGljYWxDc3NcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoYnVpbGQsIHJvdXRlcywgdXJsKSB7XG4gIGxldCBwYXRjaGVzID0ge307XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcInBcIikpIHtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwicFwiKSkge1xuICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGgsIGJ1aWxkLmJhc2VuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgICAgIGxldCByb3V0ZSA9IGJ1aWxkLmFzc2V0cy5yb3V0ZXNbcm91dGVJZF07XG4gICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBwYXRjaGVzW3JvdXRlSWRdID0gcm91dGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZS5qc29uKHBhdGNoZXMsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwicHVibGljLCBtYXgtYWdlPTMxNTM2MDAwLCBpbW11dGFibGVcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCJJbnZhbGlkIFJlcXVlc3RcIiwgeyBzdGF0dXM6IDQwMCB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNpbmdsZUZldGNoUmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIGxldCB7IHJlc3VsdCwgaGVhZGVycywgc3RhdHVzIH0gPSByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIiA/IGF3YWl0IHNpbmdsZUZldGNoQWN0aW9uKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKSA6IGF3YWl0IHNpbmdsZUZldGNoTG9hZGVycyhcbiAgICBidWlsZCxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgcmVxdWVzdCxcbiAgICBoYW5kbGVyVXJsLFxuICAgIGxvYWRDb250ZXh0LFxuICAgIGhhbmRsZUVycm9yXG4gICk7XG4gIGxldCByZXN1bHRIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gIHJlc3VsdEhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXNwb25zZVwiLCBcInllc1wiKTtcbiAgaWYgKE5PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhzdGF0dXMpKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1cywgaGVhZGVyczogcmVzdWx0SGVhZGVycyB9KTtcbiAgfVxuICByZXN1bHRIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICByZXN1bHQsXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBzdGF0dXMgfHwgMjAwLFxuICAgICAgaGVhZGVyczogcmVzdWx0SGVhZGVyc1xuICAgIH1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50UmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yLCBjcml0aWNhbENzcykge1xuICBsZXQgaXNTcGFNb2RlID0gcmVxdWVzdC5oZWFkZXJzLmhhcyhcIlgtUmVhY3QtUm91dGVyLVNQQS1Nb2RlXCIpO1xuICBsZXQgY29udGV4dDtcbiAgdHJ5IHtcbiAgICBjb250ZXh0ID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShyZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHRcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG4gIGlmIChpc1Jlc3BvbnNlKGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICBpZiAoTk9fQk9EWV9TVEFUVVNfQ09ERVMuaGFzKGNvbnRleHQuc3RhdHVzQ29kZSkpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiBjb250ZXh0LnN0YXR1c0NvZGUsIGhlYWRlcnMgfSk7XG4gIH1cbiAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycykuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gIH1cbiAgbGV0IHN0YXRlID0ge1xuICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgZXJyb3JzOiBzZXJpYWxpemVFcnJvcnMyKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKVxuICB9O1xuICBsZXQgZW50cnlDb250ZXh0ID0ge1xuICAgIG1hbmlmZXN0OiBidWlsZC5hc3NldHMsXG4gICAgcm91dGVNb2R1bGVzOiBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyhidWlsZC5yb3V0ZXMpLFxuICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgIGNyaXRpY2FsQ3NzLFxuICAgIHNlcnZlckhhbmRvZmZTdHJpbmc6IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoe1xuICAgICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lLFxuICAgICAgY3JpdGljYWxDc3MsXG4gICAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgaXNTcGFNb2RlXG4gICAgfSksXG4gICAgc2VydmVySGFuZG9mZlN0cmVhbTogZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICBzZXJ2ZXJNb2RlXG4gICAgKSxcbiAgICByZW5kZXJNZXRhOiB7fSxcbiAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICBzc3I6IGJ1aWxkLnNzcixcbiAgICBpc1NwYU1vZGUsXG4gICAgc2VyaWFsaXplRXJyb3I6IChlcnIpID0+IHNlcmlhbGl6ZUVycm9yKGVyciwgc2VydmVyTW9kZSlcbiAgfTtcbiAgbGV0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uID0gYnVpbGQuZW50cnkubW9kdWxlLmRlZmF1bHQ7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnRyeUNvbnRleHQsXG4gICAgICBsb2FkQ29udGV4dFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIGxldCBlcnJvckZvclNlY29uZFJlbmRlciA9IGVycm9yO1xuICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGRhdGEyID0gYXdhaXQgdW53cmFwUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICBlcnJvckZvclNlY29uZFJlbmRlciA9IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgICBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgZXJyb3Iuc3RhdHVzVGV4dCxcbiAgICAgICAgICBkYXRhMlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0ID0gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgICAgIHN0YXRpY0hhbmRsZXIuZGF0YVJvdXRlcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBlcnJvckZvclNlY29uZFJlbmRlclxuICAgICk7XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzMihjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSlcbiAgICB9O1xuICAgIGVudHJ5Q29udGV4dCA9IHtcbiAgICAgIC4uLmVudHJ5Q29udGV4dCxcbiAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyh7XG4gICAgICAgIGJhc2VuYW1lOiBidWlsZC5iYXNlbmFtZSxcbiAgICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgICBpc1NwYU1vZGVcbiAgICAgIH0pLFxuICAgICAgc2VydmVySGFuZG9mZlN0cmVhbTogZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICAgIHN0YXRlMixcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICApLFxuICAgICAgcmVuZGVyTWV0YToge31cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgZW50cnlDb250ZXh0LFxuICAgICAgICBsb2FkQ29udGV4dFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yMik7XG4gICAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IyLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc291cmNlUmVxdWVzdChzZXJ2ZXJNb2RlLCBzdGF0aWNIYW5kbGVyLCByb3V0ZUlkLCByZXF1ZXN0LCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dFxuICAgIH0pO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3IsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JSZXNwb25zZVRvSnNvbihlcnJvclJlc3BvbnNlLCBzZXJ2ZXJNb2RlKSB7XG4gIHJldHVybiBSZXNwb25zZS5qc29uKFxuICAgIHNlcmlhbGl6ZUVycm9yKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIGlzIFwicHJpdmF0ZVwiIGZyb20gdXNlcnMgYnV0IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgIGVycm9yUmVzcG9uc2UuZXJyb3IgfHwgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIiksXG4gICAgICBzZXJ2ZXJNb2RlXG4gICAgKSxcbiAgICB7XG4gICAgICBzdGF0dXM6IGVycm9yUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogZXJyb3JSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIlgtUmVtaXgtRXJyb3JcIjogXCJ5ZXNcIlxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuICBpZiAoc2VydmVyTW9kZSAhPT0gXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLykge1xuICAgIG1lc3NhZ2UgKz0gYFxuXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICBzdGF0dXM6IDUwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBSZXNwb25zZShyZXNwb25zZSkge1xuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpID8gcmVzcG9uc2UuYm9keSA9PSBudWxsID8gbnVsbCA6IHJlc3BvbnNlLmpzb24oKSA6IHJlc3BvbnNlLnRleHQoKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zLnRzXG5mdW5jdGlvbiBmbGFzaChuYW1lKSB7XG4gIHJldHVybiBgX19mbGFzaF8ke25hbWV9X19gO1xufVxudmFyIGNyZWF0ZVNlc3Npb24gPSAoaW5pdGlhbERhdGEgPSB7fSwgaWQgPSBcIlwiKSA9PiB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGlkKCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG1hcCk7XG4gICAgfSxcbiAgICBoYXMobmFtZSkge1xuICAgICAgcmV0dXJuIG1hcC5oYXMobmFtZSkgfHwgbWFwLmhhcyhmbGFzaChuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQobmFtZSkge1xuICAgICAgaWYgKG1hcC5oYXMobmFtZSkpIHJldHVybiBtYXAuZ2V0KG5hbWUpO1xuICAgICAgbGV0IGZsYXNoTmFtZSA9IGZsYXNoKG5hbWUpO1xuICAgICAgaWYgKG1hcC5oYXMoZmxhc2hOYW1lKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGZsYXNoTmFtZSk7XG4gICAgICAgIG1hcC5kZWxldGUoZmxhc2hOYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBmbGFzaChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChmbGFzaChuYW1lKSwgdmFsdWUpO1xuICAgIH0sXG4gICAgdW5zZXQobmFtZSkge1xuICAgICAgbWFwLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGlzU2Vzc2lvbiA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QuaWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5kYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvYmplY3QuaGFzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZmxhc2ggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnVuc2V0ID09PSBcImZ1bmN0aW9uXCI7XG59O1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWU6IGNvb2tpZUFyZyxcbiAgY3JlYXRlRGF0YSxcbiAgcmVhZERhdGEsXG4gIHVwZGF0ZURhdGEsXG4gIGRlbGV0ZURhdGFcbn0pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaWQgPSBjb29raWVIZWFkZXIgJiYgYXdhaXQgY29va2llLnBhcnNlKGNvb2tpZUhlYWRlciwgb3B0aW9ucyk7XG4gICAgICBsZXQgZGF0YTIgPSBpZCAmJiBhd2FpdCByZWFkRGF0YShpZCk7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihkYXRhMiB8fCB7fSwgaWQgfHwgXCJcIik7XG4gICAgfSxcbiAgICBhc3luYyBjb21taXRTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB7IGlkLCBkYXRhOiBkYXRhMiB9ID0gc2Vzc2lvbjtcbiAgICAgIGxldCBleHBpcmVzID0gb3B0aW9ucz8ubWF4QWdlICE9IG51bGwgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucz8uZXhwaXJlcyAhPSBudWxsID8gb3B0aW9ucy5leHBpcmVzIDogY29va2llLmV4cGlyZXM7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgYXdhaXQgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBhd2FpdCBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKGlkLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGRlc3Ryb3lTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGF3YWl0IGRlbGV0ZURhdGEoc2Vzc2lvbi5pZCk7XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShcIlwiLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1heEFnZTogdm9pZCAwLFxuICAgICAgICBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpIHtcbiAgd2Fybk9uY2UoXG4gICAgY29va2llLmlzU2lnbmVkLFxuICAgIGBUaGUgXCIke2Nvb2tpZS5uYW1lfVwiIGNvb2tpZSBpcyBub3Qgc2lnbmVkLCBidXQgc2Vzc2lvbiBjb29raWVzIHNob3VsZCBiZSBzaWduZWQgdG8gcHJldmVudCB0YW1wZXJpbmcgb24gdGhlIGNsaWVudCBiZWZvcmUgdGhleSBhcmUgc2VudCBiYWNrIHRvIHRoZSBzZXJ2ZXIuIFNlZSBodHRwczovL3JlbWl4LnJ1bi91dGlscy9jb29raWVzI3NpZ25pbmctY29va2llcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy9jb29raWVTdG9yYWdlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSh7IGNvb2tpZTogY29va2llQXJnIH0gPSB7fSkge1xuICBsZXQgY29va2llID0gaXNDb29raWUoY29va2llQXJnKSA/IGNvb2tpZUFyZyA6IGNyZWF0ZUNvb2tpZShjb29raWVBcmc/Lm5hbWUgfHwgXCJfX3Nlc3Npb25cIiwgY29va2llQXJnKTtcbiAgd2Fybk9uY2VBYm91dFNpZ25pbmdTZXNzaW9uQ29va2llKGNvb2tpZSk7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgZ2V0U2Vzc2lvbihjb29raWVIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTZXNzaW9uKFxuICAgICAgICBjb29raWVIZWFkZXIgJiYgYXdhaXQgY29va2llLnBhcnNlKGNvb2tpZUhlYWRlciwgb3B0aW9ucykgfHwge31cbiAgICAgICk7XG4gICAgfSxcbiAgICBhc3luYyBjb21taXRTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkQ29va2llID0gYXdhaXQgY29va2llLnNlcmlhbGl6ZShzZXNzaW9uLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWRDb29raWUubGVuZ3RoID4gNDA5Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDb29raWUgbGVuZ3RoIHdpbGwgZXhjZWVkIGJyb3dzZXIgbWF4aW11bS4gTGVuZ3RoOiBcIiArIHNlcmlhbGl6ZWRDb29raWUubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplZENvb2tpZTtcbiAgICB9LFxuICAgIGFzeW5jIGRlc3Ryb3lTZXNzaW9uKF9zZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShcIlwiLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1heEFnZTogdm9pZCAwLFxuICAgICAgICBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zL21lbW9yeVN0b3JhZ2UudHNcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlKHsgY29va2llIH0gPSB7fSkge1xuICBsZXQgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgICBjb29raWUsXG4gICAgYXN5bmMgY3JlYXRlRGF0YShkYXRhMiwgZXhwaXJlcykge1xuICAgICAgbGV0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbiAgICAgIG1hcC5zZXQoaWQsIHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICBhc3luYyByZWFkRGF0YShpZCkge1xuICAgICAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgICAgIGxldCB7IGRhdGE6IGRhdGEyLCBleHBpcmVzIH0gPSBtYXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFleHBpcmVzIHx8IGV4cGlyZXMgPiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkge1xuICAgICAgICAgIHJldHVybiBkYXRhMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwaXJlcykgbWFwLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGFzeW5jIHVwZGF0ZURhdGEoaWQsIGRhdGEyLCBleHBpcmVzKSB7XG4gICAgICBtYXAuc2V0KGlkLCB7IGRhdGE6IGRhdGEyLCBleHBpcmVzIH0pO1xuICAgIH0sXG4gICAgYXN5bmMgZGVsZXRlRGF0YShpZCkge1xuICAgICAgbWFwLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gbGliL2hyZWYudHNcbmZ1bmN0aW9uIGhyZWYocGF0aCwgLi4uYXJncykge1xuICBsZXQgcGFyYW1zID0gYXJnc1swXTtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/KT8vKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gc2VnbWVudDtcbiAgICBjb25zdCBwYXJhbSA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zID8gcGFyYW1zW3BhcmFtXSA6IHZvaWQgMDtcbiAgICBjb25zdCBpc1JlcXVpcmVkID0gbWF0Y2hbMl0gPT09IHZvaWQgMDtcbiAgICBpZiAoaXNSZXF1aXJlZCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFBhdGggJyR7cGF0aH0nIHJlcXVpcmVzIHBhcmFtICcke3BhcmFtfScgYnV0IGl0IHdhcyBub3QgcHJvdmlkZWRgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pLmZpbHRlcigoc2VnbWVudCkgPT4gc2VnbWVudCAhPT0gdm9pZCAwKS5qb2luKFwiL1wiKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZXJyb3JzLnRzXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9yczIoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgdmFsLnN0YXR1cyxcbiAgICAgICAgdmFsLnN0YXR1c1RleHQsXG4gICAgICAgIHZhbC5kYXRhLFxuICAgICAgICB2YWwuaW50ZXJuYWwgPT09IHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSB2YWwuc3RhY2s7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSB2YWwuc3RhY2s7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG5leHBvcnQge1xuICBBY3Rpb24sXG4gIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBpbnZhcmlhbnQsXG4gIGNyZWF0ZVBhdGgsXG4gIHBhcnNlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hQYXRoLFxuICByZXNvbHZlUGF0aCxcbiAgZGF0YSxcbiAgcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlcGxhY2UsXG4gIEVycm9yUmVzcG9uc2VJbXBsLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgSURMRV9OQVZJR0FUSU9OLFxuICBJRExFX0ZFVENIRVIsXG4gIElETEVfQkxPQ0tFUixcbiAgY3JlYXRlUm91dGVyLFxuICBEYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVmlld1RyYW5zaXRpb25Db250ZXh0LFxuICBGZXRjaGVyc0NvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0LFxuICBMb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCxcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlT3V0bGV0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VCbG9ja2VyLFxuICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBBd2FpdCxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIHJlbmRlck1hdGNoZXMsXG4gIGNyZWF0ZVNlYXJjaFBhcmFtcyxcbiAgU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3ksXG4gIGRlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBSZW1peEVycm9yQm91bmRhcnksXG4gIGNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQsXG4gIGNyZWF0ZUNsaWVudFJvdXRlcyxcbiAgc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uLFxuICB1c2VGb2dPRldhckRpc2NvdmVyeSxcbiAgRnJhbWV3b3JrQ29udGV4dCxcbiAgTGlua3MsXG4gIFByZWZldGNoUGFnZUxpbmtzLFxuICBNZXRhLFxuICBTY3JpcHRzLFxuICBjcmVhdGVCcm93c2VyUm91dGVyLFxuICBjcmVhdGVIYXNoUm91dGVyLFxuICBCcm93c2VyUm91dGVyLFxuICBIYXNoUm91dGVyLFxuICBIaXN0b3J5Um91dGVyLFxuICBMaW5rLFxuICBOYXZMaW5rLFxuICBGb3JtLFxuICBTY3JvbGxSZXN0b3JhdGlvbixcbiAgdXNlTGlua0NsaWNrSGFuZGxlcixcbiAgdXNlU2VhcmNoUGFyYW1zLFxuICB1c2VTdWJtaXQsXG4gIHVzZUZvcm1BY3Rpb24sXG4gIHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzLFxuICB1c2VTY3JvbGxSZXN0b3JhdGlvbixcbiAgdXNlQmVmb3JlVW5sb2FkLFxuICB1c2VQcm9tcHQsXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUsXG4gIFN0YXRpY1JvdXRlcixcbiAgU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gIGNyZWF0ZVN0YXRpY0hhbmRsZXIyIGFzIGNyZWF0ZVN0YXRpY0hhbmRsZXIsXG4gIGNyZWF0ZVN0YXRpY1JvdXRlcixcbiAgU2VydmVyUm91dGVyLFxuICBjcmVhdGVSb3V0ZXNTdHViLFxuICBjcmVhdGVDb29raWUsXG4gIGlzQ29va2llLFxuICBTZXJ2ZXJNb2RlLFxuICBzZXREZXZTZXJ2ZXJIb29rcyxcbiAgY3JlYXRlUmVxdWVzdEhhbmRsZXIsXG4gIGNyZWF0ZVNlc3Npb24sXG4gIGlzU2Vzc2lvbixcbiAgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSxcbiAgaHJlZixcbiAgZGVzZXJpYWxpemVFcnJvcnMyIGFzIGRlc2VyaWFsaXplRXJyb3JzXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGNvb2tpZS1uYW1lIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxuICogVGhpcyByZWZlcnMgb3V0IHRvIHRoZSBvYnNvbGV0ZWQgZGVmaW5pdGlvbiBvZiB0b2tlbiBpbiBSRkMgMjYxNiBzZWMgMi4yXG4gKiB3aGljaCBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgdG9rZW4gZGVmaW5pdGlvbiBpbiBSRkMgNzIzMCBhcHBlbmRpeCBCLlxuICpcbiAqIGNvb2tpZS1uYW1lICAgICAgID0gdG9rZW5cbiAqIHRva2VuICAgICAgICAgICAgID0gMSp0Y2hhclxuICogdGNoYXIgICAgICAgICAgICAgPSBcIiFcIiAvIFwiI1wiIC8gXCIkXCIgLyBcIiVcIiAvIFwiJlwiIC8gXCInXCIgL1xuICogICAgICAgICAgICAgICAgICAgICBcIipcIiAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiAvIFwiXlwiIC8gXCJfXCIgL1xuICogICAgICAgICAgICAgICAgICAgICBcImBcIiAvIFwifFwiIC8gXCJ+XCIgLyBESUdJVCAvIEFMUEhBXG4gKlxuICogTm90ZTogQWxsb3dpbmcgbW9yZSBjaGFyYWN0ZXJzIC0gaHR0cHM6Ly9naXRodWIuY29tL2pzaHR0cC9jb29raWUvaXNzdWVzLzE5MVxuICogQWxsb3cgc2FtZSByYW5nZSBhcyBjb29raWUgdmFsdWUsIGV4Y2VwdCBgPWAsIHdoaWNoIGRlbGltaXRzIGVuZCBvZiBuYW1lLlxuICovXG5jb25zdCBjb29raWVOYW1lUmVnRXhwID0gL15bXFx1MDAyMS1cXHUwMDNBXFx1MDAzQ1xcdTAwM0UtXFx1MDA3RV0rJC87XG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBjb29raWUtdmFsdWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXG4gKlxuICogY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuICogY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICogICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICpcbiAqIEFsbG93aW5nIG1vcmUgY2hhcmFjdGVyczogaHR0cHM6Ly9naXRodWIuY29tL2pzaHR0cC9jb29raWUvaXNzdWVzLzE5MVxuICogQ29tbWEsIGJhY2tzbGFzaCwgYW5kIERRVU9URSBhcmUgbm90IHBhcnQgb2YgdGhlIHBhcnNpbmcgYWxnb3JpdGhtLlxuICovXG5jb25zdCBjb29raWVWYWx1ZVJlZ0V4cCA9IC9eW1xcdTAwMjEtXFx1MDAzQVxcdTAwM0MtXFx1MDA3RV0qJC87XG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBkb21haW4tdmFsdWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXG4gKlxuICogZG9tYWluLXZhbHVlICAgICAgPSA8c3ViZG9tYWluPlxuICogICAgICAgICAgICAgICAgICAgICA7IGRlZmluZWQgaW4gW1JGQzEwMzRdLCBTZWN0aW9uIDMuNSwgYXNcbiAqICAgICAgICAgICAgICAgICAgICAgOyBlbmhhbmNlZCBieSBbUkZDMTEyM10sIFNlY3Rpb24gMi4xXG4gKiA8c3ViZG9tYWluPiAgICAgICA9IDxsYWJlbD4gfCA8c3ViZG9tYWluPiBcIi5cIiA8bGFiZWw+XG4gKiA8bGFiZWw+ICAgICAgICAgICA9IDxsZXQtZGlnPiBbIFsgPGxkaC1zdHI+IF0gPGxldC1kaWc+IF1cbiAqICAgICAgICAgICAgICAgICAgICAgTGFiZWxzIG11c3QgYmUgNjMgY2hhcmFjdGVycyBvciBsZXNzLlxuICogICAgICAgICAgICAgICAgICAgICAnbGV0LWRpZycgbm90ICdsZXR0ZXInIGluIHRoZSBmaXJzdCBjaGFyLCBwZXIgUkZDMTEyM1xuICogPGxkaC1zdHI+ICAgICAgICAgPSA8bGV0LWRpZy1oeXA+IHwgPGxldC1kaWctaHlwPiA8bGRoLXN0cj5cbiAqIDxsZXQtZGlnLWh5cD4gICAgID0gPGxldC1kaWc+IHwgXCItXCJcbiAqIDxsZXQtZGlnPiAgICAgICAgID0gPGxldHRlcj4gfCA8ZGlnaXQ+XG4gKiA8bGV0dGVyPiAgICAgICAgICA9IGFueSBvbmUgb2YgdGhlIDUyIGFscGhhYmV0aWMgY2hhcmFjdGVycyBBIHRocm91Z2ggWiBpblxuICogICAgICAgICAgICAgICAgICAgICB1cHBlciBjYXNlIGFuZCBhIHRocm91Z2ggeiBpbiBsb3dlciBjYXNlXG4gKiA8ZGlnaXQ+ICAgICAgICAgICA9IGFueSBvbmUgb2YgdGhlIHRlbiBkaWdpdHMgMCB0aHJvdWdoIDlcbiAqXG4gKiBLZWVwIHN1cHBvcnQgZm9yIGxlYWRpbmcgZG90OiBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL2Nvb2tpZS9pc3N1ZXMvMTczXG4gKlxuICogPiAoTm90ZSB0aGF0IGEgbGVhZGluZyAleDJFIChcIi5cIiksIGlmIHByZXNlbnQsIGlzIGlnbm9yZWQgZXZlbiB0aG91Z2ggdGhhdFxuICogY2hhcmFjdGVyIGlzIG5vdCBwZXJtaXR0ZWQsIGJ1dCBhIHRyYWlsaW5nICV4MkUgKFwiLlwiKSwgaWYgcHJlc2VudCwgd2lsbFxuICogY2F1c2UgdGhlIHVzZXIgYWdlbnQgdG8gaWdub3JlIHRoZSBhdHRyaWJ1dGUuKVxuICovXG5jb25zdCBkb21haW5WYWx1ZVJlZ0V4cCA9IC9eKFsuXT9bYS16MC05XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/KShbLl1bYS16MC05XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2k7XG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBwYXRoLXZhbHVlIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxuICpcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQ0hBUiAgICAgICAgICAgICAgPSAleDAxLTdGXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgZGVmaW5lZCBpbiBSRkMgNTIzNCBhcHBlbmRpeCBCLjFcbiAqL1xuY29uc3QgcGF0aFZhbHVlUmVnRXhwID0gL15bXFx1MDAyMC1cXHUwMDNBXFx1MDAzRC1cXHUwMDdFXSokLztcbmNvbnN0IF9fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgTnVsbE9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IEMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBDO1xufSkoKTtcbi8qKlxuICogUGFyc2UgYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFBhcnNlIHRoZSBnaXZlbiBjb29raWUgaGVhZGVyIHN0cmluZyBpbnRvIGFuIG9iamVjdFxuICogVGhlIG9iamVjdCBoYXMgdGhlIHZhcmlvdXMgY29va2llcyBhcyBrZXlzKG5hbWVzKSA9PiB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JqID0gbmV3IE51bGxPYmplY3QoKTtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIC8vIFJGQyA2MjY1IHNlYyA0LjEuMSwgUkZDIDI2MTYgMi4yIGRlZmluZXMgYSBjb29raWUgbmFtZSBjb25zaXN0cyBvZiBvbmUgY2hhciBtaW5pbXVtLCBwbHVzICc9Jy5cbiAgICBpZiAobGVuIDwgMilcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICBjb25zdCBkZWMgPSBvcHRpb25zPy5kZWNvZGUgfHwgZGVjb2RlO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCBlcUlkeCA9IHN0ci5pbmRleE9mKFwiPVwiLCBpbmRleCk7XG4gICAgICAgIGlmIChlcUlkeCA9PT0gLTEpXG4gICAgICAgICAgICBicmVhazsgLy8gTm8gbW9yZSBjb29raWUgcGFpcnMuXG4gICAgICAgIGNvbnN0IGNvbG9uSWR4ID0gc3RyLmluZGV4T2YoXCI7XCIsIGluZGV4KTtcbiAgICAgICAgY29uc3QgZW5kSWR4ID0gY29sb25JZHggPT09IC0xID8gbGVuIDogY29sb25JZHg7XG4gICAgICAgIGlmIChlcUlkeCA+IGVuZElkeCkge1xuICAgICAgICAgICAgLy8gYmFja3RyYWNrIG9uIHByaW9yIHNlbWljb2xvblxuICAgICAgICAgICAgaW5kZXggPSBzdHIubGFzdEluZGV4T2YoXCI7XCIsIGVxSWR4IC0gMSkgKyAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5U3RhcnRJZHggPSBzdGFydEluZGV4KHN0ciwgaW5kZXgsIGVxSWR4KTtcbiAgICAgICAgY29uc3Qga2V5RW5kSWR4ID0gZW5kSW5kZXgoc3RyLCBlcUlkeCwga2V5U3RhcnRJZHgpO1xuICAgICAgICBjb25zdCBrZXkgPSBzdHIuc2xpY2Uoa2V5U3RhcnRJZHgsIGtleUVuZElkeCk7XG4gICAgICAgIC8vIG9ubHkgYXNzaWduIG9uY2VcbiAgICAgICAgaWYgKG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB2YWxTdGFydElkeCA9IHN0YXJ0SW5kZXgoc3RyLCBlcUlkeCArIDEsIGVuZElkeCk7XG4gICAgICAgICAgICBsZXQgdmFsRW5kSWR4ID0gZW5kSW5kZXgoc3RyLCBlbmRJZHgsIHZhbFN0YXJ0SWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjKHN0ci5zbGljZSh2YWxTdGFydElkeCwgdmFsRW5kSWR4KSk7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gZW5kSWR4ICsgMTtcbiAgICB9IHdoaWxlIChpbmRleCA8IGxlbik7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHN0YXJ0SW5kZXgoc3RyLCBpbmRleCwgbWF4KSB7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICBpZiAoY29kZSAhPT0gMHgyMCAvKiAgICovICYmIGNvZGUgIT09IDB4MDkgLyogXFx0ICovKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0gd2hpbGUgKCsraW5kZXggPCBtYXgpO1xuICAgIHJldHVybiBtYXg7XG59XG5mdW5jdGlvbiBlbmRJbmRleChzdHIsIGluZGV4LCBtaW4pIHtcbiAgICB3aGlsZSAoaW5kZXggPiBtaW4pIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KC0taW5kZXgpO1xuICAgICAgICBpZiAoY29kZSAhPT0gMHgyMCAvKiAgICovICYmIGNvZGUgIT09IDB4MDkgLyogXFx0ICovKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbn1cbi8qKlxuICogU2VyaWFsaXplIGRhdGEgaW50byBhIGNvb2tpZSBoZWFkZXIuXG4gKlxuICogU2VyaWFsaXplIGEgbmFtZSB2YWx1ZSBwYWlyIGludG8gYSBjb29raWUgc3RyaW5nIHN1aXRhYmxlIGZvclxuICogaHR0cCBoZWFkZXJzLiBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY29va2llIHBhcmFtZXRlcnMuXG4gKlxuICogc2VyaWFsaXplKCdmb28nLCAnYmFyJywgeyBodHRwT25seTogdHJ1ZSB9KVxuICogICA9PiBcImZvbz1iYXI7IGh0dHBPbmx5XCJcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplKG5hbWUsIHZhbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuYyA9IG9wdGlvbnM/LmVuY29kZSB8fCBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgaWYgKCFjb29raWVOYW1lUmVnRXhwLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYXJndW1lbnQgbmFtZSBpcyBpbnZhbGlkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZW5jKHZhbCk7XG4gICAgaWYgKCFjb29raWVWYWx1ZVJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBhcmd1bWVudCB2YWwgaXMgaW52YWxpZDogJHt2YWx9YCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSBuYW1lICsgXCI9XCIgKyB2YWx1ZTtcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubWF4QWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIG1heEFnZSBpcyBpbnZhbGlkOiAke29wdGlvbnMubWF4QWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBcIjsgTWF4LUFnZT1cIiArIG9wdGlvbnMubWF4QWdlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgaWYgKCFkb21haW5WYWx1ZVJlZ0V4cC50ZXN0KG9wdGlvbnMuZG9tYWluKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIGRvbWFpbiBpcyBpbnZhbGlkOiAke29wdGlvbnMuZG9tYWlufWApO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBcIjsgRG9tYWluPVwiICsgb3B0aW9ucy5kb21haW47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoVmFsdWVSZWdFeHAudGVzdChvcHRpb25zLnBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gcGF0aCBpcyBpbnZhbGlkOiAke29wdGlvbnMucGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IFBhdGg9XCIgKyBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cGlyZXMpIHtcbiAgICAgICAgaWYgKCFpc0RhdGUob3B0aW9ucy5leHBpcmVzKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0Zpbml0ZShvcHRpb25zLmV4cGlyZXMudmFsdWVPZigpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIGV4cGlyZXMgaXMgaW52YWxpZDogJHtvcHRpb25zLmV4cGlyZXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBFeHBpcmVzPVwiICsgb3B0aW9ucy5leHBpcmVzLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmh0dHBPbmx5KSB7XG4gICAgICAgIHN0ciArPSBcIjsgSHR0cE9ubHlcIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlKSB7XG4gICAgICAgIHN0ciArPSBcIjsgU2VjdXJlXCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhcnRpdGlvbmVkKSB7XG4gICAgICAgIHN0ciArPSBcIjsgUGFydGl0aW9uZWRcIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJpb3JpdHkpIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHkgPSB0eXBlb2Ygb3B0aW9ucy5wcmlvcml0eSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBvcHRpb25zLnByaW9yaXR5LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHByaW9yaXR5KSB7XG4gICAgICAgICAgICBjYXNlIFwibG93XCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBQcmlvcml0eT1Mb3dcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZWRpdW1cIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PU1lZGl1bVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhpZ2hcIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PUhpZ2hcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIHByaW9yaXR5IGlzIGludmFsaWQ6ICR7b3B0aW9ucy5wcmlvcml0eX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zYW1lU2l0ZSkge1xuICAgICAgICBjb25zdCBzYW1lU2l0ZSA9IHR5cGVvZiBvcHRpb25zLnNhbWVTaXRlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG9wdGlvbnMuc2FtZVNpdGUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiBvcHRpb25zLnNhbWVTaXRlO1xuICAgICAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1TdHJpY3RcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsYXhcIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFNhbWVTaXRlPUxheFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFNhbWVTaXRlPU5vbmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIHNhbWVTaXRlIGlzIGludmFsaWQ6ICR7b3B0aW9ucy5zYW1lU2l0ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKiBVUkwtZGVjb2RlIHN0cmluZyB2YWx1ZS4gT3B0aW1pemVkIHRvIHNraXAgbmF0aXZlIGNhbGwgd2hlbiBubyAlLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKFwiJVwiKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHZhbHVlIGlzIGEgRGF0ZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICAgIHJldHVybiBfX3RvU3RyaW5nLmNhbGwodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcobWV0aG9kTmFtZSwgaW5mbykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCIlcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlc1wiLFxuICAgICAgICAgICAgaW5mb1swXSxcbiAgICAgICAgICAgIGluZm9bMV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgICAgIHB1YmxpY0luc3RhbmNlID1cbiAgICAgICAgKChwdWJsaWNJbnN0YW5jZSA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAgIChwdWJsaWNJbnN0YW5jZS5kaXNwbGF5TmFtZSB8fCBwdWJsaWNJbnN0YW5jZS5uYW1lKSkgfHxcbiAgICAgICAgXCJSZWFjdENsYXNzXCI7XG4gICAgICB2YXIgd2FybmluZ0tleSA9IHB1YmxpY0luc3RhbmNlICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgIGNsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSlcbiAgICAgICAgPyAhMFxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgICAgIG5ld0tleSA9IFJlYWN0RWxlbWVudChcbiAgICAgICAgb2xkRWxlbWVudC50eXBlLFxuICAgICAgICBuZXdLZXksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBvbGRFbGVtZW50Ll9vd25lcixcbiAgICAgICAgb2xkRWxlbWVudC5wcm9wc1xuICAgICAgKTtcbiAgICAgIG5ld0tleS5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgIT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5vZGUpKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KGNoaWxkKSAmJiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKVxuICAgICAgICAgIG5vZGUuX3N0b3JlICYmIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChpID0gZ2V0SXRlcmF0b3JGbihub2RlKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFwiICtcbiAgICAgICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgICAgICA/IChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KSwgZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSkpXG4gICAgICAgIDogaW5kZXgudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHJlc29sdmVUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgICA/IHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpXG4gICAgICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS5yZWFzb24gPSBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlKSBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgICAgIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW4uX2luaXQpLFxuICAgICAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW47XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaW52b2tlQ2FsbGJhY2spO1xuICAgICAgICB2YXIgY2hpbGRLZXkgPVxuICAgICAgICAgIFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiICsgZ2V0RWxlbWVudEtleShpbnZva2VDYWxsYmFjaywgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICAgID8gKChlc2NhcGVkUHJlZml4ID0gXCJcIiksXG4gICAgICAgICAgICBudWxsICE9IGNoaWxkS2V5ICYmXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjaGlsZEtleS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCBcIiQmL1wiKSArIFwiL1wiKSxcbiAgICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgIChudWxsICE9IGNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgICgoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpIHx8XG4gICAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNhbGxiYWNrLmtleSkpLFxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgIChudWxsID09IGNhbGxiYWNrLmtleSB8fFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiAoXCJcIiArIGNhbGxiYWNrLmtleSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyBcIi9cIikgK1xuICAgICAgICAgICAgICAgICAgY2hpbGRLZXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwiXCIgIT09IG5hbWVTb0ZhciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChpbnZva2VDYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICBudWxsID09IGludm9rZUNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAgICFpbnZva2VDYWxsYmFjay5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXguX3N0b3JlLnZhbGlkYXRlZCA9IDIpLFxuICAgICAgICAgICAgICAoY2FsbGJhY2sgPSBlc2NhcGVkUHJlZml4KSksXG4gICAgICAgICAgICBhcnJheS5wdXNoKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaW52b2tlQ2FsbGJhY2sgPSAwO1xuICAgICAgY2hpbGRLZXkgPSBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiA6IG5hbWVTb0ZhciArIFwiOlwiO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAobmFtZVNvRmFyID0gY2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkgPT09IGNoaWxkcmVuLmVudHJpZXMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgIShuYW1lU29GYXIgPSBjaGlsZHJlbi5uZXh0KCkpLmRvbmU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKyspKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkcmVuLnRoZW4pXG4gICAgICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgY3RvciA9IGN0b3IoKTtcbiAgICAgICAgY3Rvci50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMiksIChwYXlsb2FkLl9yZXN1bHQgPSBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzICYmXG4gICAgICAgICAgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gY3RvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5EaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0P1wiLFxuICAgICAgICAgICAgICBjdG9yXG4gICAgICAgICAgICApLFxuICAgICAgICAgIFwiZGVmYXVsdFwiIGluIGN0b3IgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXCIsXG4gICAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY3Rvci5kZWZhdWx0XG4gICAgICAgICk7XG4gICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKG51bGwgPT09IGVucXVldWVUYXNrSW1wbClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpO1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IChtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddKS5jYWxsKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgXCJ0aW1lcnNcIlxuICAgICAgICAgICkuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAhMSA9PT0gZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIHJldHVybiAxIDwgZXJyb3JzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICA/IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpXG4gICAgICAgIDogZXJyb3JzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICBwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBxdWV1ZSlcbiAgICAgICAgaWYgKDAgIT09IHF1ZXVlLmxlbmd0aClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsO1xuICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgPyAoKHF1ZXVlID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgcmVqZWN0KHF1ZXVlKSlcbiAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSAhMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250aW51YXRpb24gPSBjYWxsYmFjayghMSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcXVldWVbaV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjb250aW51YXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSksIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0ZsdXNoaW5nID0gITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fSxcbiAgICAgIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwiZm9yY2VVcGRhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcInJlcGxhY2VTdGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJzZXRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBlbXB0eU9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgcGFydGlhbFN0YXRlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZVxuICAgICAgKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcInRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiXG4gICAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIFwic2V0U3RhdGVcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgIH07XG4gICAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgICAgICBpc01vdW50ZWQ6IFtcbiAgICAgICAgICBcImlzTW91bnRlZFwiLFxuICAgICAgICAgIFwiSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXCJcbiAgICAgICAgXSxcbiAgICAgICAgcmVwbGFjZVN0YXRlOiBbXG4gICAgICAgICAgXCJyZXBsYWNlU3RhdGVcIixcbiAgICAgICAgICBcIlJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZuTmFtZTtcbiAgICBmb3IgKGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcylcbiAgICAgIGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkgJiZcbiAgICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBkZXByZWNhdGVkQVBJcyA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG4gICAgZGVwcmVjYXRlZEFQSXMuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuICAgIGFzc2lnbihkZXByZWNhdGVkQVBJcywgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgZGVwcmVjYXRlZEFQSXMuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbiAgICB2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgICAgICAgSDogbnVsbCxcbiAgICAgICAgQTogbnVsbCxcbiAgICAgICAgVDogbnVsbCxcbiAgICAgICAgUzogbnVsbCxcbiAgICAgICAgYWN0UXVldWU6IG51bGwsXG4gICAgICAgIGlzQmF0Y2hpbmdMZWdhY3k6ICExLFxuICAgICAgICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogITEsXG4gICAgICAgIGRpZFVzZVByb21pc2U6ICExLFxuICAgICAgICB0aHJvd25FcnJvcnM6IFtdLFxuICAgICAgICBnZXRDdXJyZW50U3RhY2s6IG51bGxcbiAgICAgIH0sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sXG4gICAgICBkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9ICExLFxuICAgICAgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nLFxuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXBvcnRFcnJvclxuICAgICAgICAgID8gcmVwb3J0RXJyb3JcbiAgICAgICAgICA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHdpbmRvdyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdpbmRvdy5FcnJvckV2ZW50XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyB3aW5kb3cuRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcm9jZXNzLmVtaXRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICExLFxuICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbCxcbiAgICAgIGFjdFNjb3BlRGVwdGggPSAwLFxuICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgPSAhMSxcbiAgICAgIGlzRmx1c2hpbmcgPSAhMSxcbiAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAgID8gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGVucXVldWVUYXNrO1xuICAgIGV4cG9ydHMuQ2hpbGRyZW4gPSB7XG4gICAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICAgICAgbWFwQ2hpbGRyZW4oXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvckVhY2hDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY291bnQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LFxuICAgICAgdG9BcnJheTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgIH0pIHx8IFtdXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25seTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICAgIGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICBleHBvcnRzLl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSA9XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscztcbiAgICBleHBvcnRzLmFjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLFxuICAgICAgICBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICB2YXIgcXVldWUgPSAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPVxuICAgICAgICAgIG51bGwgIT09IHByZXZBY3RRdWV1ZSA/IHByZXZBY3RRdWV1ZSA6IFtdKSxcbiAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgIChwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSxcbiAgICAgICAgICAoY2FsbGJhY2sgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICBjYWxsYmFjaylcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcmVzdWx0ICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXN1bHQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVzdWx0LnRoZW5cbiAgICAgICkge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSByZXN1bHQ7XG4gICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgfHxcbiAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsIGludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciBzY29wZXMuIFlvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTtcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDIpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IkMik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aHJvd25FcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKChlcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcikpXG4gICAgICAgICAgICAgICAgICA6IHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblZhbHVlJGpzY29tcCQwID0gcmVzdWx0O1xuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAwID09PSBwcmV2QWN0U2NvcGVEZXB0aCAmJlxuICAgICAgICAoZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgIDAgIT09IHF1ZXVlLmxlbmd0aCAmJlxuICAgICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlkQXdhaXRBY3RDYWxsIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBzdXNwZW5kZWQgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBidXQgdGhlIGBhY3RgIGNhbGwgd2FzIG5vdCBhd2FpdGVkLiBXaGVuIHRlc3RpbmcgUmVhY3QgY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgYXdhaXQgdGhlIHJlc3VsdDpcXG5cXG5hd2FpdCBhY3QoKCkgPT4gLi4uKVwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsKSk7XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITA7XG4gICAgICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGhcbiAgICAgICAgICAgID8gKChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IHF1ZXVlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IHJlc29sdmUocmV0dXJuVmFsdWUkanNjb21wJDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgPT09IGVsZW1lbnQgfHwgdm9pZCAwID09PSBlbGVtZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgK1xuICAgICAgICAgICAgZWxlbWVudCArXG4gICAgICAgICAgICBcIi5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKSxcbiAgICAgICAga2V5ID0gZWxlbWVudC5rZXksXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBpZiAobnVsbCAhPSBjb25maWcpIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgYToge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSAmJlxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgXCJyZWZcIlxuICAgICAgICAgICAgKS5nZXQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuaXNSZWFjdFdhcm5pbmdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdm9pZCAwICE9PSBjb25maWcucmVmO1xuICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJiAob3duZXIgPSBnZXRPd25lcigpKTtcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgfHxcbiAgICAgICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICBcIl9fc2VsZlwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IHByb3BOYW1lKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IEFycmF5KHByb3BOYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZTsgaSsrKVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHZvaWQgMCwgdm9pZCAwLCBvd25lciwgcHJvcHMpO1xuICAgICAgZm9yIChrZXkgPSAyOyBrZXkgPCBhcmd1bWVudHMubGVuZ3RoOyBrZXkrKylcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2tleV0sIHByb3BzLnR5cGUpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIENvbnN1bWVyOiBudWxsXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICAgICAgZGVmYXVsdFZhbHVlLkNvbnN1bWVyID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgICAgICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpXG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaSA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGkgKz1cbiAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHZhciB0eXBlU3RyaW5nID0gXCJudWxsXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAodHlwZVN0cmluZyA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgodHlwZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChpID1cbiAgICAgICAgICAgICAgICAgIFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpKVxuICAgICAgICAgICAgICA6ICh0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGUpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIHR5cGVTdHJpbmcsXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgaSA9IHt9O1xuICAgICAgdHlwZVN0cmluZyA9IG51bGw7XG4gICAgICBpZiAobnVsbCAhPSBjb25maWcpXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gKGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWUgfHxcbiAgICAgICAgICAhKFwiX19zZWxmXCIgaW4gY29uZmlnKSB8fFxuICAgICAgICAgIFwia2V5XCIgaW4gY29uZmlnIHx8XG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lID0gITApLFxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiWW91ciBhcHAgKG9yIG9uZSBvZiBpdHMgZGVwZW5kZW5jaWVzKSBpcyB1c2luZyBhbiBvdXRkYXRlZCBKU1ggdHJhbnNmb3JtLiBVcGRhdGUgdG8gdGhlIG1vZGVybiBKU1ggdHJhbnNmb3JtIGZvciBmYXN0ZXIgcGVyZm9ybWFuY2U6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbmV3LWpzeC10cmFuc2Zvcm1cIlxuICAgICAgICAgICkpLFxuICAgICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksICh0eXBlU3RyaW5nID0gXCJcIiArIGNvbmZpZy5rZXkpKSxcbiAgICAgICAgY29uZmlnKSlcbiAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmXG4gICAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgXCJfX3NlbGZcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgICAgIFwiX19zb3VyY2VcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgICAgIChpW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoMSA9PT0gY2hpbGRyZW5MZW5ndGgpIGkuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIGVsc2UgaWYgKDEgPCBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpLCBfaSA9IDA7XG4gICAgICAgICAgX2kgPCBjaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICBfaSsrXG4gICAgICAgIClcbiAgICAgICAgICBjaGlsZEFycmF5W19pXSA9IGFyZ3VtZW50c1tfaSArIDJdO1xuICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICAgIGkuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gKChjaGlsZHJlbkxlbmd0aCA9IHR5cGUuZGVmYXVsdFByb3BzKSwgY2hpbGRyZW5MZW5ndGgpKVxuICAgICAgICAgIHZvaWQgMCA9PT0gaVtwcm9wTmFtZV0gJiYgKGlbcHJvcE5hbWVdID0gY2hpbGRyZW5MZW5ndGhbcHJvcE5hbWVdKTtcbiAgICAgIHR5cGVTdHJpbmcgJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgaSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwgdHlwZVN0cmluZywgdm9pZCAwLCB2b2lkIDAsIGdldE93bmVyKCksIGkpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVmT2JqZWN0ID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICAgICAgcmV0dXJuIHJlZk9iamVjdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICAgIG51bGwgIT0gcmVuZGVyICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLFxuICAgICAgICAgICAgICBudWxsID09PSByZW5kZXIgPyBcIm51bGxcIiA6IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IDAgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIDIgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLFxuICAgICAgICAgICAgICAxID09PSByZW5kZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBcIkRpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj9cIlxuICAgICAgICAgICAgICAgIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICBudWxsICE9IHJlbmRlciAmJlxuICAgICAgICBudWxsICE9IHJlbmRlci5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBkZWZhdWx0UHJvcHMuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH0sXG4gICAgICAgIG93bk5hbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICByZW5kZXIubmFtZSB8fFxuICAgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlciwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAocmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbiAgICBleHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IHsgX3N0YXR1czogLTEsIF9yZXN1bHQ6IGN0b3IgfSxcbiAgICAgICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gICAgICBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIm1lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1wiLFxuICAgICAgICAgIG51bGwgPT09IHR5cGUgPyBcIm51bGxcIiA6IHR5cGVvZiB0eXBlXG4gICAgICAgICk7XG4gICAgICBjb21wYXJlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb21wYXJlOiB2b2lkIDAgPT09IGNvbXBhcmUgPyBudWxsIDogY29tcGFyZVxuICAgICAgfTtcbiAgICAgIHZhciBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBhcmUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICB0eXBlLm5hbWUgfHxcbiAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgIChPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAodHlwZS5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzY29wZSgpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKG5vb3AsIHJlcG9ydEdsb2JhbEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAoKHNjb3BlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAxMCA8IHNjb3BlICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VDYWNoZVJlZnJlc2goKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlKHVzYWJsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUFjdGlvblN0YXRlKFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcGVybWFsaW5rXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIENvbnRleHQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGJ1Z3MuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJZCgpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVkdWNlciA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVRyYW5zaXRpb24oKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMC4wXCI7XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG5cbiAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICB2YXIgcGFyc2VkID0gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpO1xuICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgK1xuICAgICAgICB2YWx1ZSArXG4gICAgICAgIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cblxuICB2YXIgY29va2llID0ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICB9O1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwicGFydGl0aW9uZWRcIikge1xuICAgICAgY29va2llLnBhcnRpdGlvbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb29raWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKSB7XG4gIC8vIFBhcnNlcyBuYW1lLXZhbHVlLXBhaXIgYWNjb3JkaW5nIHRvIHJmYzYyNjViaXMgZHJhZnRcblxuICB2YXIgbmFtZSA9IFwiXCI7XG4gIHZhciB2YWx1ZSA9IFwiXCI7XG4gIHZhciBuYW1lVmFsdWVBcnIgPSBuYW1lVmFsdWVQYWlyU3RyLnNwbGl0KFwiPVwiKTtcbiAgaWYgKG5hbWVWYWx1ZUFyci5sZW5ndGggPiAxKSB7XG4gICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgIHZhbHVlID0gbmFtZVZhbHVlQXJyLmpvaW4oXCI9XCIpOyAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA9LCBqb2luZWQgYnkgYSBcIj1cIiBpZiB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBwYXJ0XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyU3RyO1xuICB9XG5cbiAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIWlucHV0KSB7XG4gICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGZvciBmZXRjaCByZXNwb25zZXMgLSB0aGV5IGNvbWJpbmUgaGVhZGVycyBvZiB0aGUgc2FtZSB0eXBlIGluIHRoZSBoZWFkZXJzIGFycmF5LFxuICAgICAgLy8gYnV0IGdldFNldENvb2tpZSByZXR1cm5zIGFuIHVuY29tYmluZWQgYXJyYXlcbiAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZVxuICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2xvdy1wYXRoIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBzZWUgIzI1XG4gICAgICB2YXIgc2NoID1cbiAgICAgICAgaW5wdXQuaGVhZGVyc1tcbiAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgICAgfSlcbiAgICAgICAgXTtcbiAgICAgIC8vIHdhcm4gaWYgY2FsbGVkIG9uIGEgcmVxdWVzdC1saWtlIG9iamVjdCB3aXRoIGEgY29va2llIGhlYWRlciByYXRoZXIgdGhhbiBhIHNldC1jb29raWUgaGVhZGVyIC0gc2VlICMzNCwgMzZcbiAgICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IHNjaDtcbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29va2llcyA9IHt9O1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uIChjb29raWVzLCBzdHIpIHtcbiAgICAgIHZhciBjb29raWUgPSBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgY29va2llc1tjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICByZXR1cm4gY29va2llcztcbiAgICB9LCBjb29raWVzKTtcbiAgfVxufVxuXG4vKlxuICBTZXQtQ29va2llIGhlYWRlciBmaWVsZC12YWx1ZXMgYXJlIHNvbWV0aW1lcyBjb21tYSBqb2luZWQgaW4gb25lIHN0cmluZy4gVGhpcyBzcGxpdHMgdGhlbSB3aXRob3V0IGNob2tpbmcgb24gY29tbWFzXG4gIHRoYXQgYXJlIHdpdGhpbiBhIHNpbmdsZSBzZXQtY29va2llIGZpZWxkLXZhbHVlLCBzdWNoIGFzIGluIHRoZSBFeHBpcmVzIHBvcnRpb24uXG5cbiAgVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGV4cGxpY2l0bHkgYWxsb3dlZCAtIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMlxuICBOb2RlLmpzIGRvZXMgdGhpcyBmb3IgZXZlcnkgaGVhZGVyICpleGNlcHQqIHNldC1jb29raWUgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZDVlMzYzYjc3ZWJhZjFjYWY2N2NkNzUyODIyNGI2NTFjODY4MTVjMS9saWIvX2h0dHBfaW5jb21pbmcuanMjTDEyOFxuICBSZWFjdCBOYXRpdmUncyBmZXRjaCBkb2VzIHRoaXMgZm9yICpldmVyeSogaGVhZGVyLCBpbmNsdWRpbmcgc2V0LWNvb2tpZS5cblxuICBCYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9qMm9iamMvY29tbWl0LzE2ODIwZmRiYzhmNzZjYTBjMzM0NzI4MTBjZTBjYjAzZDIwZWZlMjVcbiAgQ3JlZGl0cyB0bzogaHR0cHM6Ly9naXRodWIuY29tL3RvbWJhbGwgZm9yIG9yaWdpbmFsIGFuZCBodHRwczovL2dpdGh1Yi5jb20vY2hydXNhcnQgZm9yIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiovXG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgIHJldHVybiBjb29raWVzU3RyaW5nO1xuICB9XG4gIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG5cbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cblxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgIC8vICcsJyBpcyBhIGNvb2tpZSBzZXBhcmF0b3IgaWYgd2UgaGF2ZSBsYXRlciBmaXJzdCAnPScsIG5vdCAnOycgb3IgJywnXG4gICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgcG9zICs9IDE7XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50bHkgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiLy8gc3JjL3V0aWxzLnRzXG52YXIgSE9MRSA9IC0xO1xudmFyIE5BTiA9IC0yO1xudmFyIE5FR0FUSVZFX0lORklOSVRZID0gLTM7XG52YXIgTkVHQVRJVkVfWkVSTyA9IC00O1xudmFyIE5VTEwgPSAtNTtcbnZhciBQT1NJVElWRV9JTkZJTklUWSA9IC02O1xudmFyIFVOREVGSU5FRCA9IC03O1xudmFyIFRZUEVfQklHSU5UID0gXCJCXCI7XG52YXIgVFlQRV9EQVRFID0gXCJEXCI7XG52YXIgVFlQRV9FUlJPUiA9IFwiRVwiO1xudmFyIFRZUEVfTUFQID0gXCJNXCI7XG52YXIgVFlQRV9OVUxMX09CSkVDVCA9IFwiTlwiO1xudmFyIFRZUEVfUFJPTUlTRSA9IFwiUFwiO1xudmFyIFRZUEVfUkVHRVhQID0gXCJSXCI7XG52YXIgVFlQRV9TRVQgPSBcIlNcIjtcbnZhciBUWVBFX1NZTUJPTCA9IFwiWVwiO1xudmFyIFRZUEVfVVJMID0gXCJVXCI7XG52YXIgVFlQRV9QUkVWSU9VU19SRVNPTFZFRCA9IFwiWlwiO1xudmFyIERlZmVycmVkID0gY2xhc3Mge1xuICBwcm9taXNlO1xuICByZXNvbHZlO1xuICByZWplY3Q7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGxlZnRvdmVyID0gXCJcIjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3RyID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFydHMgPSAobGVmdG92ZXIgKyBzdHIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgbGVmdG92ZXIgPSBwYXJ0cy5wb3AoKSB8fCBcIlwiO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobGVmdG92ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9mbGF0dGVuLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGlucHV0KSB7XG4gIGNvbnN0IHsgaW5kaWNlcyB9ID0gdGhpcztcbiAgY29uc3QgZXhpc3RpbmcgPSBpbmRpY2VzLmdldChpbnB1dCk7XG4gIGlmIChleGlzdGluZylcbiAgICByZXR1cm4gW2V4aXN0aW5nXTtcbiAgaWYgKGlucHV0ID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKGlucHV0ID09PSBudWxsKVxuICAgIHJldHVybiBOVUxMO1xuICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSlcbiAgICByZXR1cm4gTkFOO1xuICBpZiAoaW5wdXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICByZXR1cm4gUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgIHJldHVybiBORUdBVElWRV9JTkZJTklUWTtcbiAgaWYgKGlucHV0ID09PSAwICYmIDEgLyBpbnB1dCA8IDApXG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk87XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICBpbmRpY2VzLnNldChpbnB1dCwgaW5kZXgpO1xuICBzdHJpbmdpZnkuY2FsbCh0aGlzLCBpbnB1dCwgaW5kZXgpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQsIGluZGV4KSB7XG4gIGNvbnN0IHsgZGVmZXJyZWQsIHBsdWdpbnMsIHBvc3RQbHVnaW5zIH0gPSB0aGlzO1xuICBjb25zdCBzdHIgPSB0aGlzLnN0cmluZ2lmaWVkO1xuICBjb25zdCBzdGFjayA9IFtbaW5wdXQsIGluZGV4XV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2lucHV0MiwgaW5kZXgyXSA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHBhcnRzRm9yT2JqID0gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKS5tYXAoKGspID0+IGBcIl8ke2ZsYXR0ZW4uY2FsbCh0aGlzLCBrKX1cIjoke2ZsYXR0ZW4uY2FsbCh0aGlzLCBvYmpba10pfWApLmpvaW4oXCIsXCIpO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXQyKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBzdHJbaW5kZXgyXSA9IEpTT04uc3RyaW5naWZ5KGlucHV0Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfQklHSU5UfVwiLFwiJHtpbnB1dDJ9XCJdYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6IHtcbiAgICAgICAgY29uc3Qga2V5Rm9yID0gU3ltYm9sLmtleUZvcihpbnB1dDIpO1xuICAgICAgICBpZiAoIWtleUZvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3QgZW5jb2RlIHN5bWJvbCB1bmxlc3MgY3JlYXRlZCB3aXRoIFN5bWJvbC5mb3IoKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU1lNQk9MfVwiLCR7SlNPTi5zdHJpbmdpZnkoa2V5Rm9yKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlucHV0Mikge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYCR7TlVMTH1gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGlucHV0Mik7XG4gICAgICAgIGxldCBwbHVnaW5IYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghaXNBcnJheSAmJiBwbHVnaW5zKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luUmVzdWx0ID0gcGx1Z2luKGlucHV0Mik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCBbcGx1Z2luSWRlbnRpZmllciwgLi4ucmVzdF0gPSBwbHVnaW5SZXN1bHQ7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFske0pTT04uc3RyaW5naWZ5KHBsdWdpbklkZW50aWZpZXIpfWA7XG4gICAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7cmVzdC5tYXAoKHYpID0+IGZsYXR0ZW4uY2FsbCh0aGlzLCB2KSkuam9pbihcIixcIil9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGx1Z2luSGFuZGxlZCkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBpc0FycmF5ID8gXCJbXCIgOiBcIntcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dDIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIHJlc3VsdCArPSAoaSA/IFwiLFwiIDogXCJcIikgKyAoaSBpbiBpbnB1dDIgPyBmbGF0dGVuLmNhbGwodGhpcywgaW5wdXQyW2ldKSA6IEhPTEUpO1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtyZXN1bHR9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfREFURX1cIiwke2lucHV0Mi5nZXRUaW1lKCl9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9VUkx9XCIsJHtKU09OLnN0cmluZ2lmeShpbnB1dDIuaHJlZil9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9SRUdFWFB9XCIsJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgaW5wdXQyLnNvdXJjZVxuICAgICAgICAgICAgKX0sJHtKU09OLnN0cmluZ2lmeShpbnB1dDIuZmxhZ3MpfV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TRVR9XCIsJHtbLi4uaW5wdXQyXS5tYXAoKHZhbCkgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHZhbCkpLmpvaW4oXCIsXCIpfV1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1NFVH1cIl1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9NQVB9XCIsJHtbLi4uaW5wdXQyXS5mbGF0TWFwKChbaywgdl0pID0+IFtcbiAgICAgICAgICAgICAgICBmbGF0dGVuLmNhbGwodGhpcywgayksXG4gICAgICAgICAgICAgICAgZmxhdHRlbi5jYWxsKHRoaXMsIHYpXG4gICAgICAgICAgICAgIF0pLmpvaW4oXCIsXCIpfV1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX01BUH1cIl1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1BST01JU0V9XCIsJHtpbmRleDJ9XWA7XG4gICAgICAgICAgICBkZWZlcnJlZFtpbmRleDJdID0gaW5wdXQyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9FUlJPUn1cIiwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5tZXNzYWdlKX1gO1xuICAgICAgICAgICAgaWYgKGlucHV0Mi5uYW1lICE9PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5uYW1lKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQyKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX05VTExfT0JKRUNUfVwiLHske3BhcnRzRm9yT2JqKGlucHV0Mil9fV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbnB1dDIpKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGB7JHtwYXJ0c0Zvck9iaihpbnB1dDIpfX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgb2JqZWN0IHdpdGggcHJvdG90eXBlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZW5jb2RlIGZ1bmN0aW9uIG9yIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxldCBwbHVnaW5IYW5kbGVkID0gZmFsc2U7XG4gICAgICBpZiAocG9zdFBsdWdpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcG9zdFBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXN1bHQpKSB7XG4gICAgICAgICAgICBwbHVnaW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFske0pTT04uc3RyaW5naWZ5KHBsdWdpbklkZW50aWZpZXIpfWA7XG4gICAgICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGx1Z2luSGFuZGxlZCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBvYmplY3RQcm90b05hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LnByb3RvdHlwZSkuc29ydCgpLmpvaW4oXCJcXDBcIik7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHRoaW5nKSB7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaW5nKTtcbiAgcmV0dXJuIHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5zb3J0KCkuam9pbihcIlxcMFwiKSA9PT0gb2JqZWN0UHJvdG9OYW1lcztcbn1cblxuLy8gc3JjL3VuZmxhdHRlbi50c1xudmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB2b2lkIDA7XG5mdW5jdGlvbiB1bmZsYXR0ZW4ocGFyc2VkKSB7XG4gIGNvbnN0IHsgaHlkcmF0ZWQsIHZhbHVlcyB9ID0gdGhpcztcbiAgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGh5ZHJhdGUuY2FsbCh0aGlzLCBwYXJzZWQpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyc2VkKSB8fCAhcGFyc2VkLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgcGFyc2VkKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG4gIGh5ZHJhdGVkLmxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBoeWRyYXRlLmNhbGwodGhpcywgc3RhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBoeWRyYXRlKGluZGV4KSB7XG4gIGNvbnN0IHsgaHlkcmF0ZWQsIHZhbHVlcywgZGVmZXJyZWQsIHBsdWdpbnMgfSA9IHRoaXM7XG4gIGxldCByZXN1bHQ7XG4gIGNvbnN0IHN0YWNrID0gW1xuICAgIFtcbiAgICAgIGluZGV4LFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgIH1cbiAgICBdXG4gIF07XG4gIGxldCBwb3N0UnVuID0gW107XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2luZGV4Miwgc2V0XSA9IHN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaCAoaW5kZXgyKSB7XG4gICAgICBjYXNlIFVOREVGSU5FRDpcbiAgICAgICAgc2V0KHZvaWQgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBOVUxMOlxuICAgICAgICBzZXQobnVsbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBOQU46XG4gICAgICAgIHNldChOYU4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgUE9TSVRJVkVfSU5GSU5JVFk6XG4gICAgICAgIHNldChJbmZpbml0eSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBORUdBVElWRV9JTkZJTklUWTpcbiAgICAgICAgc2V0KC1JbmZpbml0eSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBORUdBVElWRV9aRVJPOlxuICAgICAgICBzZXQoLTApO1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGh5ZHJhdGVkW2luZGV4Ml0pIHtcbiAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleDJdO1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBoeWRyYXRlZFtpbmRleDJdID0gdmFsdWU7XG4gICAgICBzZXQodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBbdHlwZSwgYiwgY10gPSB2YWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBUWVBFX0RBVEU6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBEYXRlKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9VUkw6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBVUkwoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX0JJR0lOVDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gQmlnSW50KGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9SRUdFWFA6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBSZWdFeHAoYiwgYykpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1NZTUJPTDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gU3ltYm9sLmZvcihiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfU0VUOlxuICAgICAgICAgICAgY29uc3QgbmV3U2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBuZXdTZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgc2V0KG5ld1NldCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfTUFQOlxuICAgICAgICAgICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBtYXA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgdmFsdWVbaSArIDFdLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHJbMF0sIHJbMV0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldChtYXApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX05VTExfT0JKRUNUOlxuICAgICAgICAgICAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gb2JqO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYikucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgYltrZXldLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICBOdW1iZXIoa2V5LnNsaWNlKDEpKSxcbiAgICAgICAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvYmpbclswXV0gPSByWzFdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldChvYmopO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1BST01JU0U6XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZWRbYl0pIHtcbiAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBoeWRyYXRlZFtiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICAgIGRlZmVycmVkW2JdID0gZDtcbiAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBkLnByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX0VSUk9SOlxuICAgICAgICAgICAgY29uc3QgWywgbWVzc2FnZSwgZXJyb3JUeXBlXSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZXJyb3JUeXBlICYmIGdsb2JhbE9iaiAmJiBnbG9iYWxPYmpbZXJyb3JUeXBlXSA/IG5ldyBnbG9iYWxPYmpbZXJyb3JUeXBlXShtZXNzYWdlKSA6IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBlcnJvcjtcbiAgICAgICAgICAgIHNldChlcnJvcik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfUFJFVklPVVNfUkVTT0xWRUQ6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGh5ZHJhdGVkW2JdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5zKSkge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHMgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHNbaV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgKHYyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJbaV0gPSB2MjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBwbHVnaW4odmFsdWVbMF0sIC4uLnIpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSByZXN1bHQyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBhcnJheTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG4gPSB2YWx1ZVtpXTtcbiAgICAgICAgICBpZiAobiAhPT0gSE9MRSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGFycmF5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG9iamVjdDtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICB2YWx1ZVtrZXldLFxuICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICBOdW1iZXIoa2V5LnNsaWNlKDEpKSxcbiAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICBvYmplY3RbclswXV0gPSByWzFdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNldChvYmplY3QpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChwb3N0UnVuLmxlbmd0aCA+IDApIHtcbiAgICBwb3N0UnVuLnBvcCgpKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3R1cmJvLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGx1Z2lucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgZG9uZSA9IG5ldyBEZWZlcnJlZCgpO1xuICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5waXBlVGhyb3VnaChjcmVhdGVMaW5lU3BsaXR0aW5nVHJhbnNmb3JtKCkpLmdldFJlYWRlcigpO1xuICBjb25zdCBkZWNvZGVyID0ge1xuICAgIHZhbHVlczogW10sXG4gICAgaHlkcmF0ZWQ6IFtdLFxuICAgIGRlZmVycmVkOiB7fSxcbiAgICBwbHVnaW5zXG4gIH07XG4gIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVJbml0aWFsLmNhbGwoZGVjb2RlciwgcmVhZGVyKTtcbiAgbGV0IGRvbmVQcm9taXNlID0gZG9uZS5wcm9taXNlO1xuICBpZiAoZGVjb2RlZC5kb25lKSB7XG4gICAgZG9uZS5yZXNvbHZlKCk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZVByb21pc2UgPSBkZWNvZGVEZWZlcnJlZC5jYWxsKGRlY29kZXIsIHJlYWRlcikudGhlbihkb25lLnJlc29sdmUpLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVmZXJyZWQgb2YgT2JqZWN0LnZhbHVlcyhkZWNvZGVyLmRlZmVycmVkKSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGRvbmUucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkb25lOiBkb25lUHJvbWlzZS50aGVuKCgpID0+IHJlYWRlci5jbG9zZWQpLFxuICAgIHZhbHVlOiBkZWNvZGVkLnZhbHVlXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVJbml0aWFsKHJlYWRlcikge1xuICBjb25zdCByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgaWYgKCFyZWFkLnZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gIH1cbiAgbGV0IGxpbmU7XG4gIHRyeSB7XG4gICAgbGluZSA9IEpTT04ucGFyc2UocmVhZC52YWx1ZSk7XG4gIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogcmVhZC5kb25lLFxuICAgIHZhbHVlOiB1bmZsYXR0ZW4uY2FsbCh0aGlzLCBsaW5lKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlRGVmZXJyZWQocmVhZGVyKSB7XG4gIGxldCByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgd2hpbGUgKCFyZWFkLmRvbmUpIHtcbiAgICBpZiAoIXJlYWQudmFsdWUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBsaW5lID0gcmVhZC52YWx1ZTtcbiAgICBzd2l0Y2ggKGxpbmVbMF0pIHtcbiAgICAgIGNhc2UgVFlQRV9QUk9NSVNFOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUWVBFX0VSUk9SOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICB9XG4gICAgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCB7IHBsdWdpbnMsIHBvc3RQbHVnaW5zLCBzaWduYWwgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGVuY29kZXIgPSB7XG4gICAgZGVmZXJyZWQ6IHt9LFxuICAgIGluZGV4OiAwLFxuICAgIGluZGljZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3RyaW5naWZpZWQ6IFtdLFxuICAgIHBsdWdpbnMsXG4gICAgcG9zdFBsdWdpbnMsXG4gICAgc2lnbmFsXG4gIH07XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBsYXN0U2VudEluZGV4ID0gMDtcbiAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGlkID0gZmxhdHRlbi5jYWxsKGVuY29kZXIsIGlucHV0KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgICB9XG4gICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7aWR9XG5gKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGBbJHtlbmNvZGVyLnN0cmluZ2lmaWVkLmpvaW4oXCIsXCIpfV1cbmApXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyLnN0cmluZ2lmaWVkLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWVuUHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICAgIHdoaWxlIChPYmplY3Qua2V5cyhlbmNvZGVyLmRlZmVycmVkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2RlZmVycmVkSWQsIGRlZmVycmVkXSBvZiBPYmplY3QuZW50cmllcyhlbmNvZGVyLmRlZmVycmVkKSkge1xuICAgICAgICAgIGlmIChzZWVuUHJvbWlzZXMuaGFzKGRlZmVycmVkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIHNlZW5Qcm9taXNlcy5hZGQoXG4gICAgICAgICAgICBlbmNvZGVyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV0gPSByYWNlU2lnbmFsKFxuICAgICAgICAgICAgICBkZWZlcnJlZCxcbiAgICAgICAgICAgICAgZW5jb2Rlci5zaWduYWxcbiAgICAgICAgICAgICkudGhlbihcbiAgICAgICAgICAgICAgKHJlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQyID0gZmxhdHRlbi5jYWxsKGVuY29kZXIsIHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZDIpKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICBgJHtUWVBFX1BST01JU0V9JHtkZWZlcnJlZElkfTpbW1wiJHtUWVBFX1BSRVZJT1VTX1JFU09MVkVEfVwiLCR7aWQyWzBdfV1dXG5gXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlbmNvZGVyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZDIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShgJHtUWVBFX1BST01JU0V9JHtkZWZlcnJlZElkfToke2lkMn1cbmApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBlbmNvZGVyLnN0cmluZ2lmaWVkLnNsaWNlKGxhc3RTZW50SW5kZXggKyAxKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9Olske3ZhbHVlc31dXG5gXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4ID0gZW5jb2Rlci5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVhc29uIHx8IHR5cGVvZiByZWFzb24gIT09IFwib2JqZWN0XCIgfHwgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkMiA9IGZsYXR0ZW4uY2FsbChlbmNvZGVyLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfTpbW1wiJHtUWVBFX1BSRVZJT1VTX1JFU09MVkVEfVwiLCR7aWQyWzBdfV1dXG5gXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlbmNvZGVyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZDIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShgJHtUWVBFX0VSUk9SfSR7ZGVmZXJyZWRJZH06JHtpZDJ9XG5gKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZW5jb2Rlci5zdHJpbmdpZmllZC5zbGljZShsYXN0U2VudEluZGV4ICsgMSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICBgJHtUWVBFX0VSUk9SfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyLnN0cmluZ2lmaWVkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxldGUgZW5jb2Rlci5kZWZlcnJlZFtOdW1iZXIoZGVmZXJyZWRJZCldO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShPYmplY3QudmFsdWVzKGVuY29kZXIuZGVmZXJyZWQpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoZW5jb2Rlci5kZWZlcnJlZCkpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZWFkYWJsZTtcbn1cbmZ1bmN0aW9uIHJhY2VTaWduYWwocHJvbWlzZSwgc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKVxuICAgIHJldHVybiBwcm9taXNlO1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNpZ25hbC5yZWFzb24gfHwgbmV3IEVycm9yKFwiU2lnbmFsIHdhcyBhYm9ydGVkLlwiKSk7XG4gIGNvbnN0IGFib3J0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbiB8fCBuZXcgRXJyb3IoXCJTaWduYWwgd2FzIGFib3J0ZWQuXCIpKTtcbiAgICB9KTtcbiAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG4gIGFib3J0LmNhdGNoKCgpID0+IHtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW2Fib3J0LCBwcm9taXNlXSk7XG59XG5leHBvcnQge1xuICBkZWNvZGUsXG4gIGVuY29kZVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJmNWJhMDVlYzE4NWIxOWY0YThiOThjMzQwZjgzZmJlMy5wbmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMTIxOTFiNDdjNjZhNDdmZGM3Y2Y3YTQxYjA1OWU5ZGUucG5nXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjQ1NjM2ZTEwZWNlMjczZmUyMzkwYTM1OWI3NDc1MmVmLnBuZ1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI1N2QxNzFiYzc2ZmNlM2Q5MmVhZjBiMDM0YzhkNmYxNS5wbmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYTY1NDMyZjdkM2U5ZWEyNDIzMWU2MmYyMDU5ZGViOTAucG5nXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjMwNzMxNGNhZjhlMGYzNTcwZmUyN2UwMmNiOTQ3YWNmLnBuZ1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI2YTYxMTEwMTQwYzU5NThkMDExYTEwODMxYmE0MmY4YS5wbmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMmFkNjQ5ZTQ1YTAxOWE5ZTQ5MDIxYTQ1YzQyNWFkYWUucG5nXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImE2OWRmNmNkMmY2YTY1OTA4MTUwN2VjMDAzMjI4MjM0LnBuZ1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI2NDg4YTA3MDhhNjhhNjNjZTkxZDFkOWUzYjMwOWI1My5wbmdcIjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQgaWNvbkZsdXggZnJvbSBcIi4uL2Fzc2V0cy9pY29uLTAyLnBuZ1wiO1xuaW1wb3J0IGljb25Nc2cgZnJvbSBcIi4uL2Fzc2V0cy9pY29uLTAzLnBuZ1wiO1xuaW1wb3J0IGljb25NYW5hZ2VyIGZyb20gXCIuLi9hc3NldHMvaWNvbi0wNC5wbmdcIjtcbmltcG9ydCBpY29uSGVscCBmcm9tIFwiLi4vYXNzZXRzL2ljb24tMDUucG5nXCI7XG5cblxuY29uc3QgRmFjaWxpdHlVc2VyID0gKCkgPT4gKFxuICAgIDxkaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudF9fYXJ0aWNsZVwiPlxuICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiY29udGVudF9fYXJ0aWNsZS0tZmVhdHVyZXNcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz17aWNvbkZsdXh9IGFsdD1cIkNlbnRyYWxpemVcIiAvPlxuICAgICAgICAgICAgICAgIDxwPkNlbnRyYWxpemVzIGNvbW11bmljYXRpb24gY2hhbm5lbHMgYW5kIHJlZHVjZXMgb3ZlcmhlYWQuPC9wPlxuICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiY29udGVudF9fYXJ0aWNsZS0tZmVhdHVyZXNcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz17aWNvbk1zZ30gYWx0PVwiQ29tbXVuaWNhdGlvbiBUb29sc1wiIC8+XG4gICAgICAgICAgICAgICAgPHA+QnJpbmdzIHRvZ2V0aGVyIGluc3RhbnQgbWVzc2FnaW5nLCB2b2ljZSBhbmQgdmlkZW8gY29tbXVuaWNhdGlvbiBpbiB0aGUgYnJvd3Nlci48L3A+XG4gICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJjb250ZW50X19hcnRpY2xlLS1mZWF0dXJlc1wiPlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtpY29uTWFuYWdlcn0gYWx0PVwiSW5mb3JtYXRpb24gTWFuYWdlclwiIC8+XG4gICAgICAgICAgICAgICAgPHA+Q2FwdHVyZXMgaW5mb3JtYXRpb24gYWNyb3NzIHRoZSBvcmdhbml6YXRpb24sIHJldGFpbnMgdGhlIGtub3dsZWRnZSwgYW5saXplcyBhbmQgaW1wcm92ZXMgaXQuPC9wPlxuICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17aWNvbkhlbHB9IGFsdD1cIkhlbHBcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2PiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPisxIDg0NSA4OTQgMTIzPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgdG89XCIvY29tcGFueS9jb250YWN0XCI+IGhlbHBAaHViZ2V0cy5jb208L0xpbms+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgXG4gICAgICAgICAgICA8L2FydGljbGU+ICAgICAgICAgICAgICAgICAgXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PiAgICAgICAgICBcbik7XG5cbmV4cG9ydCBkZWZhdWx0IEZhY2lsaXR5VXNlcjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTmF2TGlua30gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmltcG9ydCBsb2dvRm9vdGVyIGZyb20gJy4uL2Fzc2V0cy9sb2dvLWh1YmdldHMtZm9vdGVyLnBuZyc7XG5pbXBvcnQgdHdpdHRlciBmcm9tICcuLi9hc3NldHMvaWNvbi10d2l0dGVyLnBuZyc7XG5pbXBvcnQgeW91dHViZSBmcm9tICcuLi9hc3NldHMvaWNvbi15b3V0dWJlLnBuZyc7XG5cbmNvbnN0IEZvb3RlciA9ICgpID0+IChcbiAgICA8Zm9vdGVyPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnQtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvb3Rlcl9fbmF2XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2dvLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17bG9nb0Zvb3Rlcn0gYWx0PVwiaHViZ2V0c1wiIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb290ZXJfX25hdi0tbGlua3NcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg0Pk91ciBjb21wYW55PC9oND5cbiAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgdG89XCIvYWJvdXRcIiBjbGFzc05hbWU9XCJsaW5rXCI+QWJvdXQgVXM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIHRvPVwiL2Jsb2dcIiBjbGFzc05hbWU9XCJsaW5rXCI+QmxvZzwvTmF2TGluaz5cbiAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgdG89XCIvaGlyaW5nXCIgY2xhc3NOYW1lPVwibGlua1wiPldlIGFyZSBoaXJpbmc8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIHRvPVwiL3Rlcm1zXCJjIGNsYXNzTmFtZT1cImxpbmtcIj5UZXJtcyBvZiBTZXJ2aWNlPC9OYXZMaW5rPlxuICAgICAgICAgICAgICAgICAgICA8TmF2TGluayB0bz1cIi9jb250YWN0XCIgY2xhc3NOYW1lPVwibGlua1wiPkNvbnRhY3QgdXM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb290ZXJfX25hdi0tbGlua3NcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg0Pkh1YmdldHM8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8TmF2TGluayB0bz1cIi9wcm9ncmFtXCIgY2xhc3NOYW1lPVwibGlua1wiPkpvaW4gdGhlIHByb2dyYW08L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIHRvPVwiL2ZlYXR1cmVzXCIgY2xhc3NOYW1lPVwibGlua1wiPkZlYXR1cmVzPC9OYXZMaW5rPlxuICAgICAgICAgICAgICAgICAgICA8TmF2TGluayB0bz1cIi9zdGF0dXNcIiBjbGFzc05hbWU9XCJsaW5rXCI+Q3VycmVudCBTdGF0dXM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb290ZXJfX25hdi0tbGlua3NcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg0PlNvY2lhbDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic29jaWFsLWxpbmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXt0d2l0dGVyfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly90d2l0dGVyLmNvbS9odWJnZXRzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VHdpdHRlcjwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic29jaWFsLWxpbmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXt5b3V0dWJlfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ3EzT000ZzFvWVNiUjBHV1FZQ0V1QlFcIiB0YXJnZXQ9XCJfYmxhbmtcIj5Zb3V0dWJlPC9hPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiY29weVwiPlxuICAgICAgICAgICAgICAgICZjb3B5OyBDb3B5cmlnaHRzIDIwMTUgSHViZ2V0cywgSW5jXG4gICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgIDwvZGl2PiAgICAgICAgICAgICBcblxuICAgIDwvZm9vdGVyPlxuKTtcbmV4cG9ydCBkZWZhdWx0IEZvb3RlcjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuaW1wb3J0IGxvZ28gZnJvbSAnLi4vYXNzZXRzL2xvZ28taHViZ2V0cy5wbmcnO1xuXG5jb25zdCBIZWFkZXIgPSAoKSA9PiAoXG4gICAgPGhlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2dvXCI+XG4gICAgICAgICAgICAgICAgPExpbmsgdG89XCIvXCIgPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17bG9nb30gYWx0PVwiaHViZ2V0c1wiIHBsYWNlaG9sZGVyPVwiaHViZ2V0c1wiLz5cbiAgICAgICAgICAgICAgICA8L0xpbms+ICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICA8L2hlYWRlcj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlZ2lzdGVyVXNlciBmcm9tICcuL1JlZ2lzdGVyVXNlcic7XG5pbXBvcnQgRmFjaWxpdHlVc2VyIGZyb20gJy4vRmFjaWxpdGllc1VzZXInO1xuaW1wb3J0IE1haW5IZWFkZXIgZnJvbSAnLi9NYWluSGVhZGVyJztcblxuXG5jb25zdCBIb21lUGFnZSA9ICgpID0+IChcbiAgICA8ZGl2PlxuICAgICAgICA8TWFpbkhlYWRlciAvPlxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJmbGV4X19zZWN0aW9uXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnQtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4X19zZWN0aW9uLS1jb250ZW50XCI+ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPFJlZ2lzdGVyVXNlciAvPiAgICBcbiAgICAgICAgICAgICAgICAgICAgPEZhY2lsaXR5VXNlciAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvc2VjdGlvbj4gICAgICAgIFxuICAgIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSG9tZVBhZ2U7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgTWFpbkhlYWRlciA9ICgpID0+IChcbiAgICA8ZGl2PlxuICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJhcnRpY2xlX19jb250ZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnQtY29udGFpbmVyXCIgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXJ0aWNsZV9fdGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICA8aDE+Q3JlYXRlIG9yZ2FuaXphdGlvbjwvaDE+XG4gICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgU21hbGwgb3IgbGFyZ2UsIGFueSB0ZWFtIHdpbGwgaW5jcmVhc2UgcHJvZHVjdGl2aXR5IHdpdGggSHViZ2V0cy4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgICAgIEl0IGFsbG93cyB0ZWFtcyB0byBmaWx0ZXIgbm9pc2UgYW5kIGZvY3VzIG9uIHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2FydGljbGU+XG4gICAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBNYWluSGVhZGVyO1xuXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5jb25zdCBOb3RGb3VuZFBhZ2UgPSAoKSA9PiAoXG4gICAgPGRpdj5cbiAgICAgICAgNDA0ISAtIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBOb3RGb3VuZFBhZ2U7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHJlZ2lzdGVyIGZyb20gJy4uL2Fzc2V0cy9pY29uLTAxLnBuZyc7XG5pbXBvcnQgZXJyb3JJbWcgZnJvbSAnLi4vYXNzZXRzL2ljb24td2FybmluZy5wbmcnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdGVyVXNlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGUgPXtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7fSxcbiAgICAgICBcbiAgICB9O1xuXG4gICAgaGFuZGxlVmFsaWRhdGlvbiA9ICgpID0+e1xuICAgICAgICBsZXQgZmllbGRzID0gdGhpcy5zdGF0ZS5maWVsZHM7XG4gICAgICAgIGxldCBlcnJvcnMgPSB7fTtcbiAgICAgICAgbGV0IGZvcm1Jc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgIFxuICAgICAgICBpZigodHlwZW9mIGZpZWxkc1tcIm5hbWVcIl0gfHwgdHlwZW9mIGZpZWxkc1tcImxhc3ROYW1lXCJdKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmKCFmaWVsZHNbXCJuYW1lXCJdLm1hdGNoKC9eW2EtekEtWl0rJC8pKXtcbiAgICAgICAgICAgIGZvcm1Jc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBlcnJvcnNbXCJuYW1lXCJdID0gXCJPbmx5IGxldHRlcnNcIjtcbiAgICAgICAgICB9ICAgICAgXHRcbiAgICAgICAgfVxuICAgICAgICBpZighZmllbGRzW1wiZW1haWxcIl0gfHwgIWZpZWxkc1tcImxhc3ROYW1lXCJdIHx8ICFmaWVsZHNbXCJlbWFpbFwiXSB8fCAhZmllbGRzW1wiY29tcGFueVwiXSApe1xuICAgICAgICAgICAgZm9ybUlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVycm9yc1tcImVtYWlsXCJdID0gXCJDYW5ub3QgYmUgZW1wdHlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodHlwZW9mIGZpZWxkc1tcImVtYWlsXCJdICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGxldCBsYXN0QXRQb3MgPSBmaWVsZHNbXCJlbWFpbFwiXS5sYXN0SW5kZXhPZignQCcpO1xuICAgICAgICAgICAgbGV0IGxhc3REb3RQb3MgPSBmaWVsZHNbXCJlbWFpbFwiXS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgXG4gICAgICAgICAgICBpZiAoIShsYXN0QXRQb3MgPCBsYXN0RG90UG9zICYmIGxhc3RBdFBvcyA+IDAgJiYgZmllbGRzW1wiZW1haWxcIl0uaW5kZXhPZignQEAnKSA9PSAtMSAmJiBsYXN0RG90UG9zID4gMiAmJiAoZmllbGRzW1wiZW1haWxcIl0ubGVuZ3RoIC0gbGFzdERvdFBvcykgPiAyKSkge1xuICAgICAgICAgICAgICBmb3JtSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBlcnJvcnNbXCJlbWFpbFwiXSA9IFwiSW52YWxpZCBlLW1haWwgYWRyZXNzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICBcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtlcnJvcnM6IGVycm9yc30pO1xuICAgICAgICAgIHJldHVybiBmb3JtSXNWYWxpZDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgY29udGFjdFN1Ym1pdCA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYodGhpcy5oYW5kbGVWYWxpZGF0aW9uKCkpe1xuICAgICAgICAgIC8vYWxlcnQoXCJGb3JtIHN1Ym1pdHRlZFwiKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAvL2FsZXJ0KFwiRm9ybSBoYXMgZXJyb3JzXCIpXG4gICAgICAgIH1cbiAgICBcbiAgICAgIH1cbiAgICBcbiAgICAgIGhhbmRsZUNoYW5nZSA9IChmaWVsZCwgZSkgPT4geyAgICBcdFx0XG4gICAgICAgIGxldCBmaWVsZHMgPSB0aGlzLnN0YXRlLmZpZWxkcztcbiAgICAgICAgZmllbGRzW2ZpZWxkXSA9IGUudGFyZ2V0LnZhbHVlOyAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2ZpZWxkc30pO1xuICAgICAgfVxuXG4gIFxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICBsZXQgY2xhc3Nlcz1cIlwiOyBcbiAgICAgICAgY2xhc3Nlcys9ICh0aGlzLnN0YXRlLmVycm9yc1tcIm5hbWVcIl0gfHwgdGhpcy5zdGF0ZS5lcnJvcnNbXCJsYXN0TmFtZVwiXXx8IHRoaXMuc3RhdGUuZXJyb3JzW1wiZW1haWxcIl0gfHwgdGhpcy5zdGF0ZS5lcnJvcnNbXCJjb21wYW55XCJdKSAgPyBcImVycm9yXCIgOiBcIm9rXCI7ICBcbiAgICAgICAgXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VudGVyLXNwYW5cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBpZD1cInJlZ2lzdGVyLWltZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e3JlZ2lzdGVyfSAvPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlZ2lzdGVyLWZvcm1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gY2xhc3NOYW1lPVwid3JhcHBlclwiIG9uU3VibWl0PSB7dGhpcy5jb250YWN0U3VibWl0LmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3JhcHBlcl9fcm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3JhcHBlcl9fY29sLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwibmFtZVwiPkZpcnN0IG5hbWU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHJlZj1cIm5hbWVcIiB0eXBlPVwidGV4dFwiIHNpemU9XCIzMFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgXCJuYW1lXCIpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmZpZWxkc1tcIm5hbWVcIl19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pbnB1dD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19jb2wtNVwiPiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwibGFzdE5hbWVcIiA+TGFzdCBuYW1lPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZWZzPVwibGFzdE5hbWVcIiB0eXBlPVwidGV4dFwiIHNpc2U9XCIzMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCBcImxhc3ROYW1lXCIpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmZpZWxkc1tcImxhc3ROYW1lXCJdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19yb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19jb2wtMTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY29tcGFueVwiPkNvbXBhbnk8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHJlZnM9XCJjb21wYW55XCIgdHlwZT1cInRleHRcIiBzaXplPVwiMzBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgXCJjb21wYW55XCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZmllbGRzW1wiY29tcGFueVwiXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19yb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19jb2wtMTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiZW1haWxcIj5FLW1haWwgYWRkcmVzczwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVmcz1cImVtYWlsXCIgdHlwZT1cInRleHRcIiBzaXplPVwiMzBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgXCJlbWFpbFwiKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5maWVsZHNbXCJlbWFpbFwiXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc30gIHNyYz17ZXJyb3JJbWd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyX19yb3dcIj4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndyYXBwZXJfX2NvbC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uICBpZD1cInN1Ym1pdFwiIHZhbHVlPVwiU3VibWl0XCI+UmVnaXN0ZXI8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3JhcHBlcl9fY29sLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVycm9yc1tcImVtYWlsXCJdICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9XCJlcnJvclwiIGNsYXNzTmFtZT17Y2xhc3Nlc30+e3RoaXMuc3RhdGUuZXJyb3JzW1wiZW1haWxcIl19PC9zcGFuPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgIClcbiAgICB9XG59O1xuXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQnJvd3NlclJvdXRlciwgUm91dGUsIFN3aXRjaCwgTGluayAgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9IZWFkZXInO1xuaW1wb3J0IEhvbWVQYWdlIGZyb20gJy4uL2NvbXBvbmVudHMvSG9tZVBhZ2UnO1xuaW1wb3J0IEZvb3RlciBmcm9tICcuLi9jb21wb25lbnRzL0Zvb3Rlcic7XG5cbmltcG9ydCBOb3RGb3VuZFBhZ2UgZnJvbSAnLi4vY29tcG9uZW50cy9Ob3RGb3VuZFBhZ2UnO1xuXG5cbmNvbnN0IEFwcFJvdXRlciA9ICgpID0+IHtcblxuY29uc3Qgc3R5bGVQYWdlcyA9IHtcbiAgICBtYXhXaWR0aDogJzYwcmVtJyxcblxuICAgIG1hcmdpbjogJzAgYXV0bycsXG4gICAgcGFkZGluZzogJzNyZW0gMCAwIDAnLFxuICAgIHBhZGRpbmc6ICcwICRtLXNpemUnLFxuICAgIGhlaWdodDogJzUwcmVtJyxcbiAgICBmb250U2l6ZTogJzJlbScsXG4gICAgdGV4dEFsaWduOidjZW50ZXInLFxuICAgIGZvbnRXZWlnaHQ6IDUwMCxcbn0gIFxuIFxuXG4vL3BhZ2VzIE91ciBDb21wYW55XG5jb25zdCBBYm91dFVzID0gKCkgPT4gKFxuICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZVBhZ2VzfT5cbiAgICAgICAgICAgIDxwPiBUaGlzIGlzIGZyb20gbXkgY29tcG9uZW50IEFib3V0IFVzIFBhZ2U8L3A+XG4gICAgICAgICAgICA8TGluayB0bz1cIi9cIj5HbyBob21lPC9MaW5rPlxuICAgICAgICA8L2Rpdj5cbik7XG5cbmNvbnN0IEJsb2dQYWdlID0gKCkgPT4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlUGFnZXN9PlxuICAgICAgICA8cD5CbG9nIFBhZ2U8L3A+XG4gICAgICAgIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgPC9kaXY+XG4pO1xuXG5jb25zdCBDb250YWN0ID0gKCkgPT4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlUGFnZXN9PlxuICAgICAgICA8cD5Db250YWN0IFVzIFBhZ2U8L3A+XG4gICAgICAgIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgPC9kaXY+XG4pO1xuXG5jb25zdCBIaXJpbmdQYWdlID0gKCkgPT4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlUGFnZXN9PlxuICAgICAgICA8cD5XZSBhcmUgSGlyaW5nIFBhZ2U8L3A+XG4gICAgICAgIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgPC9kaXY+XG4pO1xuXG5jb25zdCBUZXJtc09mU2VydmljZSA9ICgpID0+IChcbiAgICA8ZGl2IHN0eWxlPXtzdHlsZVBhZ2VzfT5cbiAgICAgICAgPHA+VGVybXMgb2YgU2VydmljZSBQYWdlPC9wPlxuICAgICAgICA8TGluayB0bz1cIi9cIj5HbyBob21lPC9MaW5rPlxuICAgIDwvZGl2PlxuKTtcblxuLy9QYWdlcyBPdXIgaHViZ2V0c1xuY29uc3QgQ3VycmVudFN0YXR1cyA9ICgpID0+IChcblxuICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZVBhZ2VzfT5cbiAgICAgICAgICAgIDxwPlRoaXMgaXMgZnJvbSBteSBjb21wb25lbnQgQ3VycmVudCBTdGF0dXMgUGFnZTwvcD5cbiAgICAgICAgICAgIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgICAgIDwvZGl2PiAgICAgICAgXG4gKTsgICAgXG4gXG4gY29uc3QgRmVhdHVyZXMgPSAoKSA9PiAoXG4gICAgPGRpdiBzdHlsZT17c3R5bGVQYWdlc30+XG4gICAgICAgIDxwPkZlYXR1cmVzIFBhZ2U8L3A+XG4gICAgICAgIDxMaW5rIHRvPVwiL1wiPkdvIGhvbWU8L0xpbms+XG4gICAgPC9kaXY+XG4pO1xuXG5jb25zdCBQcm9ncmFtSHViZ2V0cyA9ICgpID0+IChcbiAgICA8ZGl2IHN0eWxlPXtzdHlsZVBhZ2VzfT5cbiAgICAgICAgPHA+Sm9pbiBUaGUgUHJvZ3JhbSBQYWdlPC9wPlxuICAgICAgICA8TGluayB0bz1cIi9cIj5HbyBob21lPC9MaW5rPlxuICAgIDwvZGl2PlxuKTtcblxuXG5cbnJldHVybihcblxuICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICA8ZGl2PiBcbiAgICAgICAgICAgIDxIZWFkZXIgLz5cbiAgICAgICAgICAgIDxSb3V0ZXM+XG4gICAgICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCIvXCIgY29tcG9uZW50PXtIb21lUGFnZX0gZXhhY3Q9e3RydWV9IC8+XG4gICAgICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCIvYWJvdXRcIiBjb21wb25lbnQ9e0Fib3V0VXN9IC8+XG4gICAgICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCIvYmxvZ1wiIGNvbXBvbmVudD17QmxvZ1BhZ2V9IC8+XG4gICAgICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCIvaGlyaW5nXCIgY29tcG9uZW50PXtIaXJpbmdQYWdlfSAvPlxuICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL3Rlcm1zXCIgY29tcG9uZW50PXtUZXJtc09mU2VydmljZX0gLz5cbiAgICAgICAgICAgICAgICA8Um91dGUgcGF0aD1cIi9jb250YWN0XCIgY29tcG9uZW50PXtDb250YWN0fSAvPlxuICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL3Byb2dyYW1cIiBjb21wb25lbnQ9e1Byb2dyYW1IdWJnZXRzfSAvPlxuICAgICAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL2ZlYXR1cmVzXCIgY29tcG9uZW50PXtGZWF0dXJlc30gLz5cbiAgICAgICAgICAgICAgICA8Um91dGUgcGF0aD1cIi9zdGF0dXNcIiBjb21wb25lbnQ9e0N1cnJlbnRTdGF0dXN9IC8+XG4gICAgICAgICAgICAgICAgPFJvdXRlIGNvbXBvbmVudD17Tm90Rm91bmRQYWdlfSAvPlxuICAgICAgICAgICAgPC9Sb3V0ZXM+XG4gICAgICAgICAgICA8Rm9vdGVyIC8+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvQnJvd3NlclJvdXRlcj5cbil9O1xuXG5leHBvcnQgZGVmYXVsdCBBcHBSb3V0ZXI7IiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuc2Nzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuc2Nzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICghc2NyaXB0VXJsIHx8ICEvXmh0dHAocz8pOi8udGVzdChzY3JpcHRVcmwpKSkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvXmJsb2I6LywgXCJcIikucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIl9fd2VicGFja19yZXF1aXJlX18ubmMgPSB1bmRlZmluZWQ7IiwiLy8gaW5zdGFsbCAtPiBpbXBvcnQgLT4gdXNlXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgQXBwUm91dGVyIGZyb20gJy4vcm91dGVycy9BcHBSb3V0ZXInXG5pbXBvcnQgJ25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcydcbmltcG9ydCAnLi9zYXNzL3N0eWxlcy5zY3NzJztcblxuXG4vLyB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuLy8gdmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgfVxufSk7XG5cblJlYWN0RE9NLnJlbmRlcig8TXlDb21wb25lbnQgLz4sIG5vZGUpO1xuXG5cbi8vIFJlYWN0RE9NLnJlbmRlcig8QXBwUm91dGVyIC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpO1xuICAgIl0sIm5hbWVzIjpbIlJlYWN0IiwiTGluayIsImljb25GbHV4IiwiaWNvbk1zZyIsImljb25NYW5hZ2VyIiwiaWNvbkhlbHAiLCJGYWNpbGl0eVVzZXIiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3JjIiwiYWx0IiwidG8iLCJOYXZMaW5rIiwibG9nb0Zvb3RlciIsInR3aXR0ZXIiLCJ5b3V0dWJlIiwiRm9vdGVyIiwiYyIsImhyZWYiLCJ0YXJnZXQiLCJpZCIsImxvZ28iLCJIZWFkZXIiLCJwbGFjZWhvbGRlciIsIlJlZ2lzdGVyVXNlciIsIk1haW5IZWFkZXIiLCJIb21lUGFnZSIsIk5vdEZvdW5kUGFnZSIsInJlZ2lzdGVyIiwiZXJyb3JJbWciLCJfUmVhY3QkQ29tcG9uZW50IiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsIl9jYWxsU3VwZXIiLCJjb25jYXQiLCJfZGVmaW5lUHJvcGVydHkiLCJmaWVsZHMiLCJlcnJvcnMiLCJzdGF0ZSIsImZvcm1Jc1ZhbGlkIiwiX3R5cGVvZiIsIm1hdGNoIiwibGFzdEF0UG9zIiwibGFzdEluZGV4T2YiLCJsYXN0RG90UG9zIiwiaW5kZXhPZiIsInNldFN0YXRlIiwiZSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlVmFsaWRhdGlvbiIsImZpZWxkIiwidmFsdWUiLCJfaW5oZXJpdHMiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJyZW5kZXIiLCJjbGFzc2VzIiwib25TdWJtaXQiLCJjb250YWN0U3VibWl0IiwiYmluZCIsImh0bWxGb3IiLCJyZWYiLCJ0eXBlIiwic2l6ZSIsIm9uQ2hhbmdlIiwiaGFuZGxlQ2hhbmdlIiwicmVmcyIsInNpc2UiLCJDb21wb25lbnQiLCJkZWZhdWx0IiwiQnJvd3NlclJvdXRlciIsIlJvdXRlIiwiU3dpdGNoIiwiQXBwUm91dGVyIiwic3R5bGVQYWdlcyIsIm1heFdpZHRoIiwibWFyZ2luIiwicGFkZGluZyIsIkFib3V0VXMiLCJzdHlsZSIsIkJsb2dQYWdlIiwiQ29udGFjdCIsIkhpcmluZ1BhZ2UiLCJUZXJtc09mU2VydmljZSIsIkN1cnJlbnRTdGF0dXMiLCJGZWF0dXJlcyIsIlByb2dyYW1IdWJnZXRzIiwiUm91dGVzIiwicGF0aCIsImNvbXBvbmVudCIsImV4YWN0IiwiUmVhY3RET00iLCJNeUNvbXBvbmVudCIsImNyZWF0ZUNsYXNzIiwiZGlzcGxheU5hbWUiLCJub2RlIl0sInNvdXJjZVJvb3QiOiIifQ==